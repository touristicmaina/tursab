import * as i0 from '@angular/core';
import { inject, NgZone, Renderer2, ChangeDetectorRef, input, booleanAttribute, numberAttribute, linkedSignal, output, viewChild, computed, afterRenderEffect, untracked, ChangeDetectionStrategy, Component, NgModule } from '@angular/core';
import merge from 'lodash-es/merge';
import { Chart, registerables } from 'chart.js';
import { customTooltips } from '@coreui/chartjs';

Chart.register(...registerables);
let nextId = 0;
class ChartjsComponent {
    get id() {
        return this.idInput();
    }
    constructor() {
        this.ngZone = inject(NgZone);
        this.renderer = inject(Renderer2);
        this.changeDetectorRef = inject(ChangeDetectorRef);
        /**
         * Enables custom html based tooltips instead of standard tooltips.
         * @return boolean
         * @default true
         */
        this.customTooltips = input(true, { transform: booleanAttribute });
        /**
         * The data object that is passed into the Chart.js chart (more info).
         */
        this.data = input();
        /**
         * A fallback when the canvas cannot be rendered. Can be used for accessible chart descriptions.
         */
        // @Input() fallbackContent?: TemplateRef<any>;
        /**
         * Height attribute applied to the rendered canvas.
         * @return number | undefined
         * @default null
         */
        this.height = input(null, { transform: (value) => numberAttribute(value, undefined) });
        /**
         * ID attribute applied to the rendered canvas.
         * @return string
         */
        this.idInput = input(`c-chartjs-${nextId++}`, { alias: 'id' });
        /**
         * The options object that is passed into the Chart.js chart.
         */
        this.optionsInput = input({}, { alias: 'options' });
        this.options = linkedSignal(this.optionsInput);
        /**
         * The plugins array that is passed into the Chart.js chart
         */
        this.plugins = input([]);
        /**
         * If true, will tear down and redraw chart on all updates.
         * @return boolean
         * @default false
         */
        this.redraw = input(false, { transform: booleanAttribute });
        /**
         * Chart.js chart type.
         * @return {'line' | 'bar' | 'radar' | 'doughnut' | 'polarArea' | 'bubble' | 'pie' | 'scatter'}
         */
        this.type = input('bar');
        /**
         * Width attribute applied to the rendered canvas.
         * @return number | undefined
         * @default null
         */
        this.width = input(null, { transform: (value) => numberAttribute(value, undefined) });
        /**
         * Put the chart into the wrapper div element.
         * @default true
         */
        this.wrapper = input(true, { transform: booleanAttribute });
        this.getDatasetAtEvent = output();
        this.getElementAtEvent = output();
        this.getElementsAtEvent = output();
        this.chartRef = output();
        this.canvasElement = viewChild.required('canvasElement');
        this.hostClasses = computed(() => {
            return {
                'chart-wrapper': this.wrapper()
            };
        });
        this.chartDataConfig = computed(() => {
            const { labels, datasets } = { ...this.data() };
            return {
                labels: labels ?? [],
                datasets: datasets ?? []
            };
        });
        this.chartOptions = computed(() => this.options() ?? {});
        this.chartConfig = computed(() => {
            this.chartCustomTooltips();
            return {
                data: this.chartDataConfig(),
                options: this.chartOptions(),
                plugins: this.plugins(),
                type: this.type()
            };
        });
        afterRenderEffect({
            read: () => {
                const canvasElement = this.canvasElement();
                this.ctx = canvasElement?.nativeElement?.getContext('2d');
                this.chartRender();
            }
        });
    }
    ngOnChanges(changes) {
        if (changes['data'] && !changes['data'].firstChange) {
            this.chartUpdate();
        }
    }
    ngOnDestroy() {
        this.chartDestroy();
    }
    handleClick($event) {
        if (!this.chart) {
            return;
        }
        const datasetAtEvent = this.chart.getElementsAtEventForMode($event, 'dataset', { intersect: true }, false);
        this.getDatasetAtEvent.emit(datasetAtEvent);
        const elementAtEvent = this.chart.getElementsAtEventForMode($event, 'nearest', { intersect: true }, false);
        this.getElementAtEvent.emit(elementAtEvent);
        const elementsAtEvent = this.chart.getElementsAtEventForMode($event, 'index', { intersect: true }, false);
        this.getElementsAtEvent.emit(elementsAtEvent);
    }
    chartDestroy() {
        this.chart?.destroy();
        this.chartRef.emit(undefined);
    }
    chartRender() {
        const canvasElement = this.canvasElement();
        if (!canvasElement?.nativeElement || !this.ctx || this.chart) {
            return;
        }
        this.ngZone.runOutsideAngular(() => {
            const config = this.chartConfig();
            if (config) {
                this.chart = new Chart(this.ctx, config);
                this.ngZone.run(() => {
                    this.renderer.setStyle(canvasElement.nativeElement, 'display', 'block');
                    this.changeDetectorRef.markForCheck();
                    this.chartRef.emit(this.chart);
                });
            }
        });
    }
    chartUpdate() {
        if (!this.chart) {
            return;
        }
        if (this.redraw()) {
            this.chartDestroy();
            this.chartRender();
            return;
        }
        const config = this.chartConfig();
        if (this.options()) {
            Object.assign(this.chart.options ?? {}, config.options ?? {});
        }
        if (!this.chart.config.data) {
            this.chart.config.data = { ...config.data };
            this.chartUpdateOutsideAngular();
        }
        if (this.chart) {
            Object.assign(this.chart.config.options ?? {}, config.options ?? {});
            Object.assign(this.chart.config.plugins ?? [], config.plugins ?? []);
            Object.assign(this.chart.config.data, config.data);
        }
        this.chartUpdateOutsideAngular();
    }
    chartUpdateOutsideAngular() {
        setTimeout(() => {
            this.ngZone.runOutsideAngular(() => {
                this.chart?.update();
                this.ngZone.run(() => {
                    this.changeDetectorRef.markForCheck();
                });
            });
        });
    }
    chartToBase64Image() {
        return this.chart?.toBase64Image();
    }
    chartCustomTooltips() {
        if (this.customTooltips()) {
            const options = this.options();
            const plugins = options?.plugins;
            const tooltip = options?.plugins?.tooltip;
            untracked(() => {
                this.options.set(merge({
                    ...options,
                    plugins: {
                        ...plugins,
                        tooltip: {
                            ...tooltip,
                            enabled: false,
                            mode: 'index',
                            position: 'nearest',
                            external: customTooltips
                        }
                    }
                }));
            });
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ChartjsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "19.2.2", type: ChartjsComponent, isStandalone: true, selector: "c-chart", inputs: { customTooltips: { classPropertyName: "customTooltips", publicName: "customTooltips", isSignal: true, isRequired: false, transformFunction: null }, data: { classPropertyName: "data", publicName: "data", isSignal: true, isRequired: false, transformFunction: null }, height: { classPropertyName: "height", publicName: "height", isSignal: true, isRequired: false, transformFunction: null }, idInput: { classPropertyName: "idInput", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, optionsInput: { classPropertyName: "optionsInput", publicName: "options", isSignal: true, isRequired: false, transformFunction: null }, plugins: { classPropertyName: "plugins", publicName: "plugins", isSignal: true, isRequired: false, transformFunction: null }, redraw: { classPropertyName: "redraw", publicName: "redraw", isSignal: true, isRequired: false, transformFunction: null }, type: { classPropertyName: "type", publicName: "type", isSignal: true, isRequired: false, transformFunction: null }, width: { classPropertyName: "width", publicName: "width", isSignal: true, isRequired: false, transformFunction: null }, wrapper: { classPropertyName: "wrapper", publicName: "wrapper", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { getDatasetAtEvent: "getDatasetAtEvent", getElementAtEvent: "getElementAtEvent", getElementsAtEvent: "getElementsAtEvent", chartRef: "chartRef" }, host: { properties: { "class": "hostClasses()", "style.height.px": "height()", "style.width.px": "width()" } }, viewQueries: [{ propertyName: "canvasElement", first: true, predicate: ["canvasElement"], descendants: true, isSignal: true }], exportAs: ["cChart"], usesOnChanges: true, ngImport: i0, template: "<canvas\n  #canvasElement\n  (click)=\"handleClick($event)\"\n  [height]=\"height() || null\"\n  [id]=\"id\"\n  [width]=\"width() || null\"\n  role=\"img\"\n  style=\"display: none;\"\n>\n  <ng-content />\n  <!--  <ng-container *ngTemplateOutlet=\"fallbackContent\"/>-->\n</canvas>\n", styles: [":host.chart-wrapper{display:block}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ChartjsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-chart', exportAs: 'cChart', changeDetection: ChangeDetectionStrategy.OnPush, host: {
                        '[class]': 'hostClasses()',
                        '[style.height.px]': 'height()',
                        '[style.width.px]': 'width()'
                    }, template: "<canvas\n  #canvasElement\n  (click)=\"handleClick($event)\"\n  [height]=\"height() || null\"\n  [id]=\"id\"\n  [width]=\"width() || null\"\n  role=\"img\"\n  style=\"display: none;\"\n>\n  <ng-content />\n  <!--  <ng-container *ngTemplateOutlet=\"fallbackContent\"/>-->\n</canvas>\n", styles: [":host.chart-wrapper{display:block}\n"] }]
        }], ctorParameters: () => [] });

class ChartjsModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ChartjsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: ChartjsModule, imports: [ChartjsComponent], exports: [ChartjsComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ChartjsModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ChartjsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        ChartjsComponent
                    ],
                    exports: [
                        ChartjsComponent
                    ]
                }]
        }] });

/*
 * Public API Surface of coreui-angular-chartjs
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ChartjsComponent, ChartjsModule };
//# sourceMappingURL=coreui-angular-chartjs.mjs.map
