import * as i0 from '@angular/core';
import { inject, ElementRef, Directive, input, Renderer2, effect, TemplateRef, booleanAttribute, untracked, NgModule, computed, Injectable, Component, linkedSignal, output, signal, afterNextRender, contentChildren, DestroyRef, RendererFactory2, PLATFORM_ID, Inject, forwardRef, ContentChildren, ContentChild, contentChild, numberAttribute, afterRender, viewChild, ViewContainerRef, ChangeDetectorRef, model, Pipe, Input, ViewChild, HostBinding, EventEmitter, Output, ChangeDetectionStrategy, HostListener, Injector, runInInjectionContext } from '@angular/core';
import { NgTemplateOutlet, DOCUMENT, NgClass, AsyncPipe, isPlatformServer, isPlatformBrowser, NgStyle } from '@angular/common';
import { animation, animate, style, AnimationBuilder, useAnimation, trigger, state, transition, group, query, animateChild } from '@angular/animations';
import { takeUntilDestroyed, toObservable } from '@angular/core/rxjs-interop';
import { fromEvent, Subject, BehaviorSubject, Observable, merge, takeWhile } from 'rxjs';
import * as i1 from '@angular/router';
import { RouterModule, Router, ActivatedRoute, NavigationEnd, RouterLink } from '@angular/router';
import { filter, tap, finalize, zipWith, withLatestFrom, debounceTime } from 'rxjs/operators';
import { createPopper } from '@popperjs/core';
import * as i1$1 from '@angular/cdk/a11y';
import { FocusKeyManager, FocusMonitor, A11yModule } from '@angular/cdk/a11y';
import { BreakpointObserver } from '@angular/cdk/layout';
import { IconDirective } from '@coreui/icons-angular';

var BreakpointInfix;
(function (BreakpointInfix) {
    BreakpointInfix["xs"] = "xs";
    BreakpointInfix["sm"] = "sm";
    BreakpointInfix["md"] = "md";
    BreakpointInfix["lg"] = "lg";
    BreakpointInfix["xl"] = "xl";
    BreakpointInfix["xxl"] = "xxl";
})(BreakpointInfix || (BreakpointInfix = {}));

class ElementRefDirective {
    constructor() {
        this.elementRef = inject(ElementRef);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ElementRefDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.2", type: ElementRefDirective, isStandalone: true, selector: "[cElementRef]", exportAs: ["cElementRef"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ElementRefDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cElementRef]',
                    exportAs: 'cElementRef'
                }]
        }] });

class HtmlAttributesDirective {
    constructor() {
        this.cHtmlAttr = input();
        this.#renderer = inject(Renderer2);
        this.#elementRef = inject(ElementRef);
        this.#attrEffect = effect(() => {
            const attribs = this.cHtmlAttr();
            for (const attr in attribs) {
                if (attr === 'style' && typeof attribs[attr] === 'object') {
                    this.setStyle(attribs[attr]);
                }
                else if (attr === 'class') {
                    this.addClass(attribs[attr]);
                }
                else {
                    this.setAttrib(attr, attribs[attr]);
                }
            }
        });
    }
    #renderer;
    #elementRef;
    #attrEffect;
    setStyle(styles) {
        for (const style in styles) {
            if (style) {
                this.#renderer.setStyle(this.#elementRef.nativeElement, style, styles[style]);
            }
        }
    }
    addClass(classes) {
        const classArray = Array.isArray(classes) ? classes : classes.split(' ');
        classArray
            .filter((element) => element.length > 0)
            .forEach((element) => {
            this.#renderer.addClass(this.#elementRef.nativeElement, element);
        });
    }
    setAttrib(key, value) {
        value !== null
            ? this.#renderer.setAttribute(this.#elementRef.nativeElement, key, value)
            : this.#renderer.removeAttribute(this.#elementRef.nativeElement, key);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: HtmlAttributesDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: HtmlAttributesDirective, isStandalone: true, selector: "[cHtmlAttr]", inputs: { cHtmlAttr: { classPropertyName: "cHtmlAttr", publicName: "cHtmlAttr", isSignal: true, isRequired: false, transformFunction: null } }, exportAs: ["cHtmlAttr"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: HtmlAttributesDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cHtmlAttr]',
                    exportAs: 'cHtmlAttr'
                }]
        }] });

class TemplateIdDirective {
    constructor() {
        this.templateRef = inject(TemplateRef);
        this.cTemplateId = input.required();
    }
    get id() {
        return this.cTemplateId();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TemplateIdDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: TemplateIdDirective, isStandalone: true, selector: "[cTemplateId]", inputs: { cTemplateId: { classPropertyName: "cTemplateId", publicName: "cTemplateId", isSignal: true, isRequired: true, transformFunction: null } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TemplateIdDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cTemplateId]'
                }]
        }] });

class ThemeDirective {
    constructor() {
        this.#hostElement = inject(ElementRef);
        this.#renderer = inject(Renderer2);
        /**
         * Add dark theme attribute.
         * @return 'dark' | 'light' | undefined
         */
        this.colorScheme = input();
        this.#colorSchemeChange = effect(() => {
            const colorScheme = this.colorScheme();
            colorScheme ? this.setTheme(colorScheme) : this.unsetTheme();
        });
        this.dark = input(false, { transform: booleanAttribute });
        this.#darkChange = effect(() => {
            const darkTheme = this.dark() || untracked(this.colorScheme) === 'dark';
            darkTheme ? this.setTheme('dark') : this.unsetTheme();
        });
    }
    #hostElement;
    #renderer;
    #colorSchemeChange;
    #darkChange;
    setTheme(theme) {
        if (theme) {
            this.#renderer.setAttribute(this.#hostElement.nativeElement, 'data-coreui-theme', theme);
        }
    }
    unsetTheme() {
        this.#renderer.removeAttribute(this.#hostElement.nativeElement, 'data-coreui-theme');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ThemeDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: ThemeDirective, isStandalone: true, selector: "[cTheme]", inputs: { colorScheme: { classPropertyName: "colorScheme", publicName: "colorScheme", isSignal: true, isRequired: false, transformFunction: null }, dark: { classPropertyName: "dark", publicName: "dark", isSignal: true, isRequired: false, transformFunction: null } }, exportAs: ["cTheme"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ThemeDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cTheme]',
                    exportAs: 'cTheme'
                }]
        }] });

class SharedModule {
    static forRoot() {
        return {
            ngModule: SharedModule,
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SharedModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: SharedModule, imports: [ElementRefDirective, HtmlAttributesDirective, TemplateIdDirective, ThemeDirective], exports: [ElementRefDirective, HtmlAttributesDirective, TemplateIdDirective, ThemeDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SharedModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SharedModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [ElementRefDirective, HtmlAttributesDirective, TemplateIdDirective, ThemeDirective],
                    exports: [ElementRefDirective, HtmlAttributesDirective, TemplateIdDirective, ThemeDirective],
                }]
        }] });

class AccordionButtonDirective {
    constructor() {
        /**
         * Toggles an accordion button collapsed state. Use in accordionHeaderTemplate. [docs]
         * @type boolean
         */
        this.collapsed = input(undefined);
        /**
         * Default type for cAccordionButton. [docs]
         * @type string
         * @default 'button'
         */
        this.type = input('button');
        this.hostClasses = computed(() => {
            return {
                'accordion-button': true,
                collapsed: this.collapsed()
            };
        });
        this.ariaExpanded = computed(() => !this.collapsed());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AccordionButtonDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: AccordionButtonDirective, isStandalone: true, selector: "[cAccordionButton]", inputs: { collapsed: { classPropertyName: "collapsed", publicName: "collapsed", isSignal: true, isRequired: false, transformFunction: null }, type: { classPropertyName: "type", publicName: "type", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.type": "type()", "attr.aria-expanded": "ariaExpanded()" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AccordionButtonDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cAccordionButton]',
                    host: { '[class]': 'hostClasses()', '[attr.type]': 'type()', '[attr.aria-expanded]': 'ariaExpanded()' }
                }]
        }] });

class AccordionService {
    constructor() {
        this.items = [];
        this.alwaysOpen = false;
    }
    addItem(item) {
        this.items.push(item);
    }
    removeItem(item) {
        const index = this.items.indexOf(item);
        if (index !== -1) {
            this.items.splice(index, 1);
        }
    }
    toggleItem(item) {
        item.itemVisible.update((value) => !value);
        this.closeOtherItems(item);
    }
    closeOtherItems(openItem) {
        if (!this.alwaysOpen) {
            this.items.forEach((item) => {
                if (item !== openItem) {
                    item.itemVisible.set(false);
                }
            });
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AccordionService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AccordionService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AccordionService, decorators: [{
            type: Injectable
        }] });

class AccordionComponent {
    constructor() {
        this.#accordionService = inject(AccordionService);
        /**
         * Removes the default background-color, some borders, and some rounded corners to render accordions edge-to-edge with their parent container.
         * @type boolean
         */
        this.flush = input(false, { transform: booleanAttribute });
        /**
         * Make accordion items stay open when another item is opened
         * @type boolean
         */
        this.alwaysOpen = input(false, { transform: booleanAttribute });
        this.#alwaysOpenEffect = effect(() => {
            this.#accordionService.alwaysOpen = this.alwaysOpen();
        });
        this.hostClasses = computed(() => ({
            accordion: true,
            'accordion-flush': this.flush()
        }));
    }
    #accordionService;
    #alwaysOpenEffect;
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AccordionComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: AccordionComponent, isStandalone: true, selector: "c-accordion", inputs: { flush: { classPropertyName: "flush", publicName: "flush", isSignal: true, isRequired: false, transformFunction: null }, alwaysOpen: { classPropertyName: "alwaysOpen", publicName: "alwaysOpen", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, providers: [AccordionService], exportAs: ["cAccordionItem"], ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AccordionComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-accordion', template: '<ng-content />', exportAs: 'cAccordionItem', providers: [AccordionService], host: { '[class]': 'hostClasses()' }, styles: [":host{display:block}\n"] }]
        }] });

const expandAnimation = animation([animate('{{ time }} {{ easing }}')]);
const collapseAnimation = animation([
    style({ height: '*', minHeight: '*' }),
    animate('{{ time }} {{ easing }}', style({ height: 0, minHeight: 0 }))
]);
const expandHorizontalAnimation = animation([animate('{{ time }} {{ easing }}')]);
const collapseHorizontalAnimation = animation([animate('{{ time }} {{ easing }}')]);

class CollapseDirective {
    #hostElement;
    #renderer;
    #animationBuilder;
    #player;
    constructor() {
        this.#hostElement = inject(ElementRef);
        this.#renderer = inject(Renderer2);
        this.#animationBuilder = inject(AnimationBuilder);
        this.#player = undefined;
        /**
         * @ignore
         */
        this.animateInput = input(true, { transform: booleanAttribute, alias: 'animate' });
        this.animate = linkedSignal({
            source: this.animateInput,
            computation: (value) => value
        });
        /**
         * Set horizontal collapsing to transition the width instead of height.
         * @type boolean
         * @default false
         */
        this.horizontal = input(false, { transform: booleanAttribute });
        /**
         * Toggle the visibility of collapsible element.
         * @type boolean
         * @default false
         */
        this.visibleInput = input(false, { transform: booleanAttribute, alias: 'visible' });
        this.visibleChange = output();
        this.visible = linkedSignal({ source: this.visibleInput, computation: (value) => value });
        this.#initialized = signal(false);
        this.#visibleEffect = effect(() => {
            const visible = this.visible();
            if (this.#initialized()) {
                this.createPlayer(visible);
            }
        });
        /**
         * Add `navbar` prop for grouping and hiding navbar contents by a parent breakpoint.
         * @type boolean
         * @default false
         */
        this.navbar = input(false, { transform: booleanAttribute });
        /**
         * @ignore
         */
        this.duration = input('350ms');
        /**
         * @ignore
         */
        this.transition = input('ease');
        /**
         * Event emitted on visibility change. [docs]
         * @type string
         */
        this.collapseChange = output();
        this.hostClasses = computed(() => {
            return {
                'navbar-collapse': this.navbar(),
                'collapse-horizontal': this.horizontal()
            };
        });
        afterNextRender({
            read: () => {
                this.#initialized.set(true);
            }
        });
    }
    #initialized;
    #visibleEffect;
    ngOnDestroy() {
        this.destroyPlayer();
    }
    toggle(visible = !this.visible()) {
        this.visible.set(visible);
    }
    destroyPlayer() {
        this.#player?.destroy();
        this.#player = undefined;
    }
    createPlayer(visible = this.visible()) {
        if (this.#player?.hasStarted()) {
            this.destroyPlayer();
        }
        const host = this.#hostElement.nativeElement;
        if (visible) {
            this.#renderer.removeStyle(host, 'display');
        }
        const duration = this.animate() ? this.duration() : '0ms';
        const expand = this.horizontal() ? expandHorizontalAnimation : expandAnimation;
        const collapse = this.horizontal() ? collapseHorizontalAnimation : collapseAnimation;
        const dimension = this.horizontal() ? 'width' : 'height';
        const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
        const scrollSize = `scroll${capitalizedDimension}`;
        const animationFactory = this.#animationBuilder?.build(useAnimation(visible ? expand : collapse, { params: { time: duration, easing: this.transition() } }));
        this.#player = animationFactory.create(host);
        !visible && host.offsetHeight && host.style[dimension] && host.scrollHeight;
        this.#renderer.setStyle(host, dimension, visible ? 0 : `${host.getBoundingClientRect()[dimension]}px`);
        this.#player.onStart(() => {
            this.setMaxSize();
            this.#renderer.removeClass(host, 'collapse');
            this.#renderer.addClass(host, 'collapsing');
            this.#renderer.removeClass(host, 'show');
            this.#renderer.setStyle(host, dimension, visible ? `${host[scrollSize]}px` : '');
            this.collapseChange?.emit(visible ? 'opening' : 'collapsing');
        });
        this.#player.onDone(() => {
            this.#renderer.removeClass(host, 'collapsing');
            this.#renderer.addClass(host, 'collapse');
            if (visible) {
                this.#renderer.addClass(host, 'show');
                this.#renderer.setStyle(host, dimension, '');
            }
            else {
                this.#renderer.removeClass(host, 'show');
            }
            this.collapseChange?.emit(visible ? 'open' : 'collapsed');
            this.destroyPlayer();
            this.visibleChange.emit(visible);
        });
        this.#player?.play();
    }
    setMaxSize() {
        const host = this.#hostElement.nativeElement;
        if (this.horizontal()) {
            host.scrollWidth > 0 && this.#renderer.setStyle(host, 'maxWidth', `${host.scrollWidth}px`);
            // } else {
            //   host.scrollHeight > 0 && this.#renderer.setStyle(host, 'maxHeight', `${host.scrollHeight}px`);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CollapseDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: CollapseDirective, isStandalone: true, selector: "[cCollapse]", inputs: { animateInput: { classPropertyName: "animateInput", publicName: "animate", isSignal: true, isRequired: false, transformFunction: null }, horizontal: { classPropertyName: "horizontal", publicName: "horizontal", isSignal: true, isRequired: false, transformFunction: null }, visibleInput: { classPropertyName: "visibleInput", publicName: "visible", isSignal: true, isRequired: false, transformFunction: null }, navbar: { classPropertyName: "navbar", publicName: "navbar", isSignal: true, isRequired: false, transformFunction: null }, duration: { classPropertyName: "duration", publicName: "duration", isSignal: true, isRequired: false, transformFunction: null }, transition: { classPropertyName: "transition", publicName: "transition", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { visibleChange: "visibleChange", collapseChange: "collapseChange" }, host: { properties: { "class": "hostClasses()", "style": "{ display: \"none\" }" } }, exportAs: ["cCollapse"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CollapseDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cCollapse]',
                    exportAs: 'cCollapse',
                    host: { '[class]': 'hostClasses()', '[style]': '{ display: "none" }' }
                }]
        }], ctorParameters: () => [] });

class CollapseModule {
    static forRoot() {
        return { ngModule: CollapseModule, providers: [] };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CollapseModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: CollapseModule, imports: [CollapseDirective], exports: [CollapseDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CollapseModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CollapseModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [CollapseDirective],
                    imports: [CollapseDirective]
                }]
        }] });

let nextId$2 = 0;
class AccordionItemComponent {
    constructor() {
        this.#accordionService = inject(AccordionService);
        /**
         * Toggle an accordion item programmatically
         * @return boolean
         * @default false
         */
        // eslint-disable-next-line @angular-eslint/no-input-rename
        this.visibleInput = input(false, { transform: booleanAttribute, alias: 'visible' });
        this.itemVisible = signal(false);
        this.#visibleInputChange = effect(() => {
            this.visible = this.visibleInput();
        });
        this.contentId = `accordion-item-${nextId$2++}`;
        this.contentTemplates = contentChildren(TemplateIdDirective, { descendants: true });
        this.templates = computed(() => {
            return this.contentTemplates().reduce((acc, child) => {
                acc[child.id] = child.templateRef;
                return acc;
            }, {});
        });
    }
    #accordionService;
    #visibleInputChange;
    set visible(value) {
        this.itemVisible.set(value);
    }
    get visible() {
        return this.itemVisible();
    }
    get itemContext() {
        return { $implicit: this.itemVisible() };
    }
    ngOnInit() {
        this.#accordionService.addItem(this);
    }
    ngOnDestroy() {
        this.#accordionService.removeItem(this);
    }
    toggleItem() {
        this.#accordionService.toggleItem(this);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AccordionItemComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "19.2.2", type: AccordionItemComponent, isStandalone: true, selector: "c-accordion-item", inputs: { visibleInput: { classPropertyName: "visibleInput", publicName: "visible", isSignal: true, isRequired: false, transformFunction: null } }, host: { classAttribute: "accordion-item" }, queries: [{ propertyName: "contentTemplates", predicate: TemplateIdDirective, descendants: true, isSignal: true }], exportAs: ["cAccordionItem"], ngImport: i0, template: "@let tmpl = templates();\n<ng-container>\n  <div class=\"accordion-header\">\n    <ng-container *ngTemplateOutlet=\"tmpl['accordionHeaderTemplate'] || defaultAccordionHeaderTemplate; context: itemContext\" />\n  </div>\n  <div class=\"accordion-collapse\" cCollapse [visible]=\"itemVisible()\" [attr.aria-expanded]=\"itemVisible()\" [id]=\"contentId\">\n    <ng-container *ngTemplateOutlet=\"tmpl['accordionBodyTemplate'] || defaultAccordionBodyTemplate; context: itemContext\" />\n  </div>\n</ng-container>\n\n<ng-template #defaultAccordionHeaderTemplate>\n  <button cAccordionButton [collapsed]=\"!itemVisible()\" [attr.aria-controls]=\"contentId\" (click)=\"toggleItem()\">\n    <ng-container\n      *ngTemplateOutlet=\"tmpl['accordionHeader'] || defaultAccordionHeaderContentTemplate; context: itemContext\">\n    </ng-container>\n  </button>\n</ng-template>\n\n<ng-template #defaultAccordionHeaderContentTemplate>\n  <ng-content />\n</ng-template>\n\n<ng-template #defaultAccordionBodyTemplate>\n  <div class=\"accordion-body\">\n    <ng-container\n      *ngTemplateOutlet=\"tmpl['accordionBody'] || defaultAccordionBodyContentTemplate; context: itemContext\">\n    </ng-container>\n  </div>\n</ng-template>\n\n<ng-template #defaultAccordionBodyContentTemplate>\n  <ng-content />\n</ng-template>\n", styles: [":host{display:block;overflow:hidden}\n"], dependencies: [{ kind: "directive", type: AccordionButtonDirective, selector: "[cAccordionButton]", inputs: ["collapsed", "type"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: CollapseDirective, selector: "[cCollapse]", inputs: ["animate", "horizontal", "visible", "navbar", "duration", "transition"], outputs: ["visibleChange", "collapseChange"], exportAs: ["cCollapse"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AccordionItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-accordion-item', exportAs: 'cAccordionItem', imports: [AccordionButtonDirective, NgTemplateOutlet, CollapseDirective], host: { class: 'accordion-item' }, template: "@let tmpl = templates();\n<ng-container>\n  <div class=\"accordion-header\">\n    <ng-container *ngTemplateOutlet=\"tmpl['accordionHeaderTemplate'] || defaultAccordionHeaderTemplate; context: itemContext\" />\n  </div>\n  <div class=\"accordion-collapse\" cCollapse [visible]=\"itemVisible()\" [attr.aria-expanded]=\"itemVisible()\" [id]=\"contentId\">\n    <ng-container *ngTemplateOutlet=\"tmpl['accordionBodyTemplate'] || defaultAccordionBodyTemplate; context: itemContext\" />\n  </div>\n</ng-container>\n\n<ng-template #defaultAccordionHeaderTemplate>\n  <button cAccordionButton [collapsed]=\"!itemVisible()\" [attr.aria-controls]=\"contentId\" (click)=\"toggleItem()\">\n    <ng-container\n      *ngTemplateOutlet=\"tmpl['accordionHeader'] || defaultAccordionHeaderContentTemplate; context: itemContext\">\n    </ng-container>\n  </button>\n</ng-template>\n\n<ng-template #defaultAccordionHeaderContentTemplate>\n  <ng-content />\n</ng-template>\n\n<ng-template #defaultAccordionBodyTemplate>\n  <div class=\"accordion-body\">\n    <ng-container\n      *ngTemplateOutlet=\"tmpl['accordionBody'] || defaultAccordionBodyContentTemplate; context: itemContext\">\n    </ng-container>\n  </div>\n</ng-template>\n\n<ng-template #defaultAccordionBodyContentTemplate>\n  <ng-content />\n</ng-template>\n", styles: [":host{display:block;overflow:hidden}\n"] }]
        }] });

class AccordionModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AccordionModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: AccordionModule, imports: [AccordionButtonDirective,
            AccordionComponent,
            AccordionItemComponent], exports: [AccordionComponent,
            AccordionButtonDirective,
            AccordionItemComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AccordionModule, providers: [
            AccordionService
        ] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AccordionModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        AccordionButtonDirective,
                        AccordionComponent,
                        AccordionItemComponent
                    ],
                    exports: [
                        AccordionComponent,
                        AccordionButtonDirective,
                        AccordionItemComponent
                    ],
                    providers: [
                        AccordionService
                    ]
                }]
        }] });

class AlertHeadingDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AlertHeadingDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.2", type: AlertHeadingDirective, isStandalone: true, selector: "[cAlertHeading]", host: { classAttribute: "alert-heading" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AlertHeadingDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cAlertHeading]',
                    host: { class: 'alert-heading' }
                }]
        }] });

class AlertLinkDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AlertLinkDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.2", type: AlertLinkDirective, isStandalone: true, selector: "[cAlertLink]", host: { classAttribute: "alert-link" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AlertLinkDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cAlertLink]',
                    host: { class: 'alert-link' }
                }]
        }] });

class ButtonDirective {
    constructor() {
        /**
         * Toggle the active state for the component. [docs]
         * @type InputSignalWithTransform<boolean, unknown>
         */
        this.active = input(false, { transform: booleanAttribute });
        /**
         * Sets the color context of the component to one of CoreUI’s themed colors. [docs]
         * @type InputSignal<Colors>
         */
        this.color = input('primary');
        /**
         * Toggle the disabled state for the component.
         * @type InputSignalWithTransform<boolean, unknown>
         */
        this.disabled = input(false, { transform: booleanAttribute });
        /**
         * Select the shape of the component.
         * @type InputSignal<Shapes>
         */
        this.shape = input();
        /**
         * Size the component small or large.
         * @type InputSignal<'sm' | 'lg' | ''>
         */
        this.size = input('');
        /**
         * Specifies the type of button. Always specify the type attribute for the `<button>` element.
         * Different browsers may use different default types for the `<button>` element.
         * @type InputSignal<ButtonType>
         * @default 'button'
         */
        this.type = input('button');
        /**
         * Set the button variant to an outlined button or a ghost button.
         * @type InputSignal<'ghost' | 'outline' | undefined>
         */
        this.variant = input();
        this.hostClasses = computed(() => {
            return {
                btn: true,
                [`btn-${this.color()}`]: !!this.color() && !this.variant(),
                [`btn-${this.variant()}`]: !!this.variant() && !this.color(),
                [`btn-${this.variant()}-${this.color()}`]: !!this.variant() && !!this.color(),
                [`btn-${this.size()}`]: !!this.size(),
                [`${this.shape()}`]: !!this.shape(),
                active: this.active(),
                disabled: this._disabled()
            };
        });
        this._disabled = computed(() => this.disabled());
        this.ariaDisabled = computed(() => {
            return this._disabled() ? true : null;
        });
        this.attrDisabled = computed(() => {
            return this._disabled() ? '' : null;
        });
        this.tabIndex = computed(() => {
            return this._disabled() ? '-1' : null;
        });
        this.isActive = computed(() => {
            return this.active() || null;
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ButtonDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: ButtonDirective, isStandalone: true, selector: "[cButton]", inputs: { active: { classPropertyName: "active", publicName: "active", isSignal: true, isRequired: false, transformFunction: null }, color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null }, shape: { classPropertyName: "shape", publicName: "shape", isSignal: true, isRequired: false, transformFunction: null }, size: { classPropertyName: "size", publicName: "size", isSignal: true, isRequired: false, transformFunction: null }, type: { classPropertyName: "type", publicName: "type", isSignal: true, isRequired: false, transformFunction: null }, variant: { classPropertyName: "variant", publicName: "variant", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.aria-disabled": "ariaDisabled()", "attr.aria-pressed": "isActive()", "attr.disabled": "attrDisabled()", "attr.tabindex": "tabIndex()", "attr.type": "type()" }, classAttribute: "btn" }, exportAs: ["cButton"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ButtonDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cButton]',
                    exportAs: 'cButton',
                    host: {
                        class: 'btn',
                        '[class]': 'hostClasses()',
                        '[attr.aria-disabled]': 'ariaDisabled()',
                        '[attr.aria-pressed]': 'isActive()',
                        '[attr.disabled]': 'attrDisabled()',
                        '[attr.tabindex]': 'tabIndex()',
                        '[attr.type]': 'type()'
                    }
                }]
        }] });

class ButtonCloseDirective extends ButtonDirective {
    constructor() {
        super(...arguments);
        /**
         * Change the default color to white.
         * @type boolean
         * @deprecated 5.0.0. Use `cButtonClose.dark` instead.
         */
        this.white = input(false, { transform: booleanAttribute });
        this.hostClasses = computed(() => {
            return {
                btn: true,
                'btn-close': true,
                'btn-close-white': this.white(),
                [`btn-${this.size()}`]: !!this.size(),
                active: this.active(),
                disabled: this._disabled()
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ButtonCloseDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: ButtonCloseDirective, isStandalone: true, selector: "[cButtonClose]", inputs: { white: { classPropertyName: "white", publicName: "white", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.aria-disabled": "ariaDisabled()", "attr.aria-pressed": "isActive()", "attr.disabled": "attrDisabled()", "attr.tabindex": "tabIndex()", "attr.type": "type()" }, classAttribute: "btn btn-close" }, usesInheritance: true, hostDirectives: [{ directive: ThemeDirective, inputs: ["dark", "dark"] }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ButtonCloseDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cButtonClose]',
                    hostDirectives: [{ directive: ThemeDirective, inputs: ['dark'] }],
                    host: {
                        class: 'btn btn-close',
                        '[class]': 'hostClasses()',
                        '[attr.aria-disabled]': 'ariaDisabled()',
                        '[attr.aria-pressed]': 'isActive()',
                        '[attr.disabled]': 'attrDisabled()',
                        '[attr.tabindex]': 'tabIndex()',
                        '[attr.type]': 'type()'
                    }
                }]
        }] });

class ButtonModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ButtonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: ButtonModule, imports: [ButtonDirective,
            ButtonCloseDirective], exports: [ButtonDirective,
            ButtonCloseDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ButtonModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ButtonModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        ButtonDirective,
                        ButtonCloseDirective
                    ],
                    exports: [
                        ButtonDirective,
                        ButtonCloseDirective
                    ]
                }]
        }] });

class AlertComponent {
    constructor() {
        /**
         * Sets the color context of the component to one of CoreUI’s themed colors.
         * @return Colors
         * @default 'primary'
         */
        this.color = input('primary');
        /**
         * Default role for alert. [docs]
         * @return string
         * @default 'alert'
         */
        this.role = input('alert');
        /**
         * Set the alert variant to a solid.
         * @return string
         */
        this.variant = input();
        /**
         * Optionally adds a close button to alert and allow it to self dismiss.
         * @return boolean
         * @default false
         */
        this.dismissibleInput = input(false, { transform: booleanAttribute, alias: 'dismissible' });
        this.#dismissible = linkedSignal({
            source: this.dismissibleInput,
            computation: (value) => {
                return value;
            }
        });
        /**
         * Adds animation for dismissible alert.
         * @return boolean
         */
        this.fade = input(false, { transform: booleanAttribute });
        /**
         * Toggle the visibility of alert component.
         * @return boolean
         */
        this.visibleInput = input(true, { transform: booleanAttribute, alias: 'visible' });
        this.#visible = linkedSignal({
            source: this.visibleInput,
            computation: (value) => {
                return value;
            }
        });
        this.hide = signal(false);
        /**
         * Event triggered on the alert dismiss.
         */
        this.visibleChange = output();
        this.contentTemplates = contentChildren(TemplateIdDirective, { descendants: true });
        this.templates = computed(() => {
            return this.contentTemplates().reduce((acc, child) => {
                acc[child.id] = child.templateRef;
                return acc;
            }, {});
        });
        this.hostClasses = computed(() => {
            const color = this.color();
            const variant = this.variant();
            return {
                alert: true,
                'alert-dismissible': this.dismissible,
                fade: this.fade(),
                show: !this.hide(),
                [`alert-${color}`]: !!color && variant !== 'solid',
                [`bg-${color}`]: !!color && variant === 'solid',
                'text-white': !!color && variant === 'solid'
            };
        });
    }
    #dismissible;
    set dismissible(value) {
        this.#dismissible.set(value);
    }
    get dismissible() {
        return this.#dismissible();
    }
    #visible;
    set visible(value) {
        if (this.#visible() !== value) {
            this.#visible.set(value);
            this.visibleChange.emit(value);
        }
    }
    get visible() {
        return this.#visible();
    }
    get animateType() {
        return this.visible ? 'show' : 'hide';
    }
    onAnimationStart($event) {
        this.onAnimationEvent($event);
    }
    onAnimationDone($event) {
        this.onAnimationEvent($event);
    }
    onAnimationEvent(event) {
        this.hide.set(event.phaseName === 'start' && event.toState === 'show');
        if (event.phaseName === 'done') {
            this.hide.set(event.toState === 'hide' || event.toState === 'void');
            if (event.toState === 'show') {
                this.hide.set(false);
            }
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AlertComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.2", type: AlertComponent, isStandalone: true, selector: "c-alert", inputs: { color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null }, variant: { classPropertyName: "variant", publicName: "variant", isSignal: true, isRequired: false, transformFunction: null }, dismissibleInput: { classPropertyName: "dismissibleInput", publicName: "dismissible", isSignal: true, isRequired: false, transformFunction: null }, fade: { classPropertyName: "fade", publicName: "fade", isSignal: true, isRequired: false, transformFunction: null }, visibleInput: { classPropertyName: "visibleInput", publicName: "visible", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { visibleChange: "visibleChange" }, host: { listeners: { "@fadeInOut.start": "onAnimationStart($event)", "@fadeInOut.done": "onAnimationDone($event)" }, properties: { "@.disabled": "!fade()", "@fadeInOut": "animateType", "attr.role": "role()", "class": "hostClasses()" } }, queries: [{ propertyName: "contentTemplates", predicate: TemplateIdDirective, descendants: true, isSignal: true }], exportAs: ["cAlert"], ngImport: i0, template: "@if (visible || !hide()) {\n  @if (dismissible) {\n    <ng-container *ngTemplateOutlet=\"templates()?.['alertButtonCloseTemplate'] || defaultAlertButtonCloseTemplate\" />\n  }\n  <ng-content />\n}\n<ng-template #defaultAlertButtonCloseTemplate>\n  <button (click)=\"visible=false\" aria-label=\"Close\" cButtonClose></button>\n</ng-template>\n", styles: [":host{display:block;overflow:hidden}\n"], dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: ButtonCloseDirective, selector: "[cButtonClose]", inputs: ["white"] }], animations: [
            trigger('fadeInOut', [
                state('show', style({ opacity: 1, height: '*', padding: '*', border: '*', margin: '*' })),
                state('hide', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                state('void', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                transition('show => hide', [animate('.3s ease-out')]),
                transition('hide => show', [animate('.3s ease-in')]),
                transition('show => void', [animate('.3s ease-out')]),
                transition('void => show', [animate('.3s ease-in')])
            ])
        ] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AlertComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-alert', exportAs: 'cAlert', imports: [NgTemplateOutlet, ButtonCloseDirective], animations: [
                        trigger('fadeInOut', [
                            state('show', style({ opacity: 1, height: '*', padding: '*', border: '*', margin: '*' })),
                            state('hide', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                            state('void', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                            transition('show => hide', [animate('.3s ease-out')]),
                            transition('hide => show', [animate('.3s ease-in')]),
                            transition('show => void', [animate('.3s ease-out')]),
                            transition('void => show', [animate('.3s ease-in')])
                        ])
                    ], host: {
                        '[@.disabled]': '!fade()',
                        '[@fadeInOut]': 'animateType',
                        '[attr.role]': 'role()',
                        '[class]': 'hostClasses()',
                        '(@fadeInOut.start)': 'onAnimationStart($event)',
                        '(@fadeInOut.done)': 'onAnimationDone($event)'
                    }, template: "@if (visible || !hide()) {\n  @if (dismissible) {\n    <ng-container *ngTemplateOutlet=\"templates()?.['alertButtonCloseTemplate'] || defaultAlertButtonCloseTemplate\" />\n  }\n  <ng-content />\n}\n<ng-template #defaultAlertButtonCloseTemplate>\n  <button (click)=\"visible=false\" aria-label=\"Close\" cButtonClose></button>\n</ng-template>\n", styles: [":host{display:block;overflow:hidden}\n"] }]
        }] });

class AlertModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AlertModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: AlertModule, imports: [AlertComponent,
            AlertHeadingDirective,
            AlertLinkDirective], exports: [AlertComponent,
            AlertHeadingDirective,
            AlertLinkDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AlertModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AlertModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        AlertComponent,
                        AlertHeadingDirective,
                        AlertLinkDirective
                    ],
                    exports: [
                        AlertComponent,
                        AlertHeadingDirective,
                        AlertLinkDirective
                    ]
                }]
        }] });

class AlignDirective {
    constructor() {
        /**
         * Set vertical alignment of inline, inline-block, inline-table, and table cell elements
         * @return Alignment
         */
        this.align = input(undefined, { alias: 'cAlign' });
        this.hostClasses = computed(() => {
            const align = this.align();
            return {
                [`align-${align}`]: !!align
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AlignDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: AlignDirective, isStandalone: true, selector: "[cAlign]", inputs: { align: { classPropertyName: "align", publicName: "cAlign", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, exportAs: ["cAlign"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AlignDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cAlign]',
                    exportAs: 'cAlign',
                    host: { '[class]': 'hostClasses()' }
                }]
        }] });

class BgColorDirective {
    constructor() {
        /**
         * Set the background of an element to any contextual class
         */
        this.cBgColor = input('');
        /**
         * Add linear gradient as background image to the backgrounds.
         * @return boolean
         */
        this.gradient = input();
        this.hostClasses = computed(() => {
            const color = this.cBgColor();
            return {
                [`bg-${color}`]: !!color,
                'bg-gradient': this.gradient()
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: BgColorDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: BgColorDirective, isStandalone: true, selector: "[cBgColor]", inputs: { cBgColor: { classPropertyName: "cBgColor", publicName: "cBgColor", isSignal: true, isRequired: false, transformFunction: null }, gradient: { classPropertyName: "gradient", publicName: "gradient", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, exportAs: ["cBgColor"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: BgColorDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cBgColor]',
                    exportAs: 'cBgColor',
                    host: { '[class]': 'hostClasses()' }
                }]
        }] });

class BorderDirective {
    constructor() {
        /**
         * Add or remove an element’s borders
         * @return Border
         */
        this.cBorder = input(true);
        this.hostClasses = computed(() => {
            const border = this.cBorder();
            if (typeof border === 'boolean') {
                return { border: border };
            }
            if (typeof border === 'number' || typeof border === 'string') {
                return {
                    border: true,
                    [`border-${border}`]: true
                };
            }
            if (typeof border === 'object') {
                const borderObj = {
                    top: undefined,
                    end: undefined,
                    bottom: undefined,
                    start: undefined,
                    color: undefined,
                    ...border
                };
                // @ts-ignore
                const keys = Object.keys(borderObj).filter((key) => borderObj[key] !== undefined);
                const classes = {};
                keys.forEach((key) => {
                    // @ts-ignore
                    const val = borderObj[key];
                    if (typeof val === 'boolean') {
                        // @ts-ignore
                        classes[`border-${key}`] = true;
                    }
                    else if (typeof val === 'number' || typeof val === 'string') {
                        // @ts-ignore
                        classes[`border-${key}-${val}`] = true;
                    }
                    else if (typeof val === 'object') {
                        if ('color' in val) {
                            // @ts-ignore
                            classes[`border-${key}-${val.color}`] = true;
                        }
                        if ('width' in val) {
                            // @ts-ignore
                            classes[`border-${key}-${val.width}`] = true;
                        }
                    }
                });
                return Object.entries(classes).length === 0 ? { border: false } : classes;
            }
            return { border: false };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: BorderDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: BorderDirective, isStandalone: true, selector: "[cBorder]", inputs: { cBorder: { classPropertyName: "cBorder", publicName: "cBorder", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, exportAs: ["cBorder"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: BorderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cBorder]',
                    exportAs: 'cBorder',
                    host: { '[class]': 'hostClasses()' }
                }]
        }] });

class RoundedDirective {
    constructor() {
        /**
         * Set border radius variant and radius size
         * @type Rounded
         */
        this.cRounded = input(true);
        this.hostClasses = computed(() => {
            const rounded = this.cRounded();
            if (typeof rounded === 'boolean') {
                return { rounded: rounded };
            }
            if (typeof rounded === 'number' || typeof rounded === 'string') {
                return {
                    [`rounded-${rounded}`]: true
                };
            }
            if (typeof rounded === 'object') {
                const roundedObj = {
                    top: undefined,
                    end: undefined,
                    bottom: undefined,
                    start: undefined,
                    circle: undefined,
                    pill: undefined,
                    size: undefined,
                    ...rounded
                };
                // @ts-ignore
                const keys = Object.keys(roundedObj).filter((key) => roundedObj[key] !== undefined);
                const classes = {};
                keys.forEach((key) => {
                    // @ts-ignore
                    const val = roundedObj[key];
                    if (typeof val === 'boolean') {
                        // @ts-ignore
                        classes[`rounded-${key}`] = val;
                    }
                    else {
                        // @ts-ignore
                        classes[`rounded-${val}`] = true;
                    }
                });
                // console.log('rounded keys', keys, classes);
                return Object.entries(classes).length === 0 ? { rounded: false } : classes;
            }
            return { rounded: false };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: RoundedDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: RoundedDirective, isStandalone: true, selector: "[cRounded]", inputs: { cRounded: { classPropertyName: "cRounded", publicName: "cRounded", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, exportAs: ["cRounded"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: RoundedDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cRounded]',
                    exportAs: 'cRounded',
                    host: { '[class]': 'hostClasses()' }
                }]
        }] });

class ShadowOnScrollDirective {
    #destroyRef;
    #document;
    #elementRef;
    #scrolled;
    #scrollEffect;
    #observable;
    #shadowClass;
    constructor() {
        this.#destroyRef = inject(DestroyRef);
        this.#document = inject(DOCUMENT);
        this.#elementRef = inject(ElementRef);
        this.#scrolled = signal(false);
        this.#scrollEffect = effect(() => {
            this.#elementRef.nativeElement.classList.toggle(this.#shadowClass, this.#scrolled());
        });
        this.#shadowClass = 'shadow-sm';
        this.cShadowOnScroll = input(true);
        this.#shadowOnScrollEffect = effect(() => {
            const value = this.cShadowOnScroll();
            untracked(() => {
                this.#scrolled.set(false);
                if (value) {
                    this.#shadowClass = value === true ? 'shadow' : `shadow-${value}`;
                    this.#observable = fromEvent(this.#document, 'scroll')
                        .pipe(takeUntilDestroyed(this.#destroyRef))
                        .subscribe((scrolled) => {
                        this.#scrolled.set(this.#document.documentElement.scrollTop > 0);
                    });
                }
                else {
                    this.#observable?.unsubscribe();
                }
            });
        });
        this.#destroyRef.onDestroy(() => {
            this.#scrollEffect?.destroy();
        });
    }
    #shadowOnScrollEffect;
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ShadowOnScrollDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: ShadowOnScrollDirective, isStandalone: true, selector: "[cShadowOnScroll]", inputs: { cShadowOnScroll: { classPropertyName: "cShadowOnScroll", publicName: "cShadowOnScroll", isSignal: true, isRequired: false, transformFunction: null } }, exportAs: ["cShadowOnScroll"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ShadowOnScrollDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cShadowOnScroll]',
                    exportAs: 'cShadowOnScroll'
                }]
        }], ctorParameters: () => [] });

class TextColorDirective {
    constructor() {
        /**
         * Set text-color of element
         * @type TextColors
         */
        this.color = input('', { alias: 'cTextColor' });
        this.hostClasses = computed(() => {
            const color = this.color();
            return {
                [`text-${color}`]: !!color
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TextColorDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: TextColorDirective, isStandalone: true, selector: "[cTextColor]", inputs: { color: { classPropertyName: "color", publicName: "cTextColor", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TextColorDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cTextColor]',
                    host: {
                        '[class]': 'hostClasses()'
                    }
                }]
        }] });

class TextBgColorDirective {
    constructor() {
        /**
         * Set text-bg-color of element
         * @type Colors
         */
        this.textBgColor = input('', { alias: 'cTextBgColor' });
        this.hostClasses = computed(() => {
            const color = this.textBgColor();
            return {
                [`text-bg-${color}`]: !!color
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TextBgColorDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: TextBgColorDirective, isStandalone: true, selector: "[cTextBgColor]", inputs: { textBgColor: { classPropertyName: "textBgColor", publicName: "cTextBgColor", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TextBgColorDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cTextBgColor]',
                    host: {
                        '[class]': 'hostClasses()'
                    }
                }]
        }] });

const UTILITY_DIRECTIVES = [
    AlignDirective,
    BgColorDirective,
    BorderDirective,
    RoundedDirective,
    ShadowOnScrollDirective,
    TextColorDirective,
    TextBgColorDirective
];
class UtilitiesModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: UtilitiesModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: UtilitiesModule, imports: [AlignDirective,
            BgColorDirective,
            BorderDirective,
            RoundedDirective,
            ShadowOnScrollDirective,
            TextColorDirective,
            TextBgColorDirective], exports: [AlignDirective,
            BgColorDirective,
            BorderDirective,
            RoundedDirective,
            ShadowOnScrollDirective,
            TextColorDirective,
            TextBgColorDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: UtilitiesModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: UtilitiesModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...UTILITY_DIRECTIVES],
                    exports: [...UTILITY_DIRECTIVES]
                }]
        }] });

class AvatarComponent {
    constructor() {
        /**
         * Sets the background color context of the component to one of CoreUI’s themed colors.
         * @type Colors
         */
        this.color = input();
        /**
         * Select the shape of the component.
         * @type Shapes
         */
        this.shape = input();
        /**
         * Size the component small, large, or extra large.
         * @default 'md'
         */
        this.size = input('md');
        /**
         * The alt attribute for the img element alternate text.
         * @type string
         */
        this.alt = input('');
        /**
         * The src attribute for the img element.
         * @type string
         */
        this.src = input();
        /**
         * Sets the color context of the status indicator to one of CoreUI’s themed colors.
         * @type Colors
         */
        this.status = input();
        /**
         * Sets the text color of the component to one of CoreUI’s themed colors.
         * via TextColorDirective
         * @type TextColors
         */
        this.textColor = input();
        this.statusClass = computed(() => {
            return {
                'avatar-status': true,
                [`bg-${this.status()}`]: !!this.status()
            };
        });
        this.hostClasses = computed(() => {
            return {
                avatar: true,
                [`avatar-${this.size()}`]: !!this.size(),
                [`bg-${this.color()}`]: !!this.color(),
                [`${this.shape()}`]: !!this.shape()
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AvatarComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.2", type: AvatarComponent, isStandalone: true, selector: "c-avatar", inputs: { color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null }, shape: { classPropertyName: "shape", publicName: "shape", isSignal: true, isRequired: false, transformFunction: null }, size: { classPropertyName: "size", publicName: "size", isSignal: true, isRequired: false, transformFunction: null }, alt: { classPropertyName: "alt", publicName: "alt", isSignal: true, isRequired: false, transformFunction: null }, src: { classPropertyName: "src", publicName: "src", isSignal: true, isRequired: false, transformFunction: null }, status: { classPropertyName: "status", publicName: "status", isSignal: true, isRequired: false, transformFunction: null }, textColor: { classPropertyName: "textColor", publicName: "textColor", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "avatar" }, hostDirectives: [{ directive: TextColorDirective, inputs: ["cTextColor", "textColor"] }], ngImport: i0, template: "<ng-content>\n  @if (src()) {\n    @defer (prefetch on idle) {\n      <img src=\"{{src() ?? ''}}\" class=\"avatar-img\" alt=\"{{alt()}}\" />\n    } @placeholder () {\n      <svg aria-label=\"Avatar placeholder\"\n           focusable=\"false\"\n           preserveAspectRatio=\"xMidYMid slice\"\n           role=\"img\"\n           xmlns=\"http://www.w3.org/2000/svg\"\n           class=\"avatar-img\"\n           style=\"position: absolute; width: 100%; height: 100%; inset: 0;\">\n        <rect fill=\"#868e96\" height=\"100%\" width=\"100%\"></rect>\n      </svg>\n    }\n  }\n</ng-content>\n@if (!!status()) {\n  <span [ngClass]=\"statusClass()\"></span>\n}\n\n", styles: [":host .avatar-img{object-fit:cover}\n"], dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AvatarComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-avatar', imports: [NgClass], hostDirectives: [
                        {
                            directive: TextColorDirective,
                            inputs: ['cTextColor: textColor']
                        }
                    ], host: { class: 'avatar', '[class]': 'hostClasses()' }, template: "<ng-content>\n  @if (src()) {\n    @defer (prefetch on idle) {\n      <img src=\"{{src() ?? ''}}\" class=\"avatar-img\" alt=\"{{alt()}}\" />\n    } @placeholder () {\n      <svg aria-label=\"Avatar placeholder\"\n           focusable=\"false\"\n           preserveAspectRatio=\"xMidYMid slice\"\n           role=\"img\"\n           xmlns=\"http://www.w3.org/2000/svg\"\n           class=\"avatar-img\"\n           style=\"position: absolute; width: 100%; height: 100%; inset: 0;\">\n        <rect fill=\"#868e96\" height=\"100%\" width=\"100%\"></rect>\n      </svg>\n    }\n  }\n</ng-content>\n@if (!!status()) {\n  <span [ngClass]=\"statusClass()\"></span>\n}\n\n", styles: [":host .avatar-img{object-fit:cover}\n"] }]
        }] });

class AvatarModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AvatarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: AvatarModule, imports: [AvatarComponent], exports: [AvatarComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AvatarModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: AvatarModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        AvatarComponent
                    ],
                    exports: [
                        AvatarComponent
                    ]
                }]
        }] });

class BadgeComponent {
    constructor() {
        /**
         * Sets the color context of the component to one of CoreUI’s themed colors.
         * @type Colors
         */
        this.color = input();
        /**
         * Position badge in one of the corners of a link or button.
         * @type BadgePositions
         */
        this.position = input();
        /**
         * Select the shape of the component.
         * @type Shapes
         */
        this.shape = input();
        /**
         * Size the component small.
         */
        this.size = input();
        /**
         * Sets the text color of the component to one of CoreUI’s themed colors.
         * via TextColorDirective
         * @type TextColors
         */
        this.textColor = input();
        /**
         * Sets the component's color scheme to one of CoreUI's themed colors, ensuring the text color contrast adheres to the WCAG 4.5:1 contrast ratio standard for accessibility.
         * via TextBgColorDirective
         * @type Colors
         * @since 5.0.0
         */
        this.textBgColor = input();
        this.hostClasses = computed(() => {
            const position = this.position();
            const positionClasses = {
                'position-absolute': !!position,
                'translate-middle': !!position,
                'top-0': position?.includes('top'),
                'top-100': position?.includes('bottom'),
                'start-100': position?.includes('end'),
                'start-0': position?.includes('start')
            };
            return Object.assign({
                badge: true,
                [`bg-${this.color()}`]: !!this.color(),
                [`badge-${this.size()}`]: !!this.size(),
                [`${this.shape()}`]: !!this.shape()
            }, !!position ? positionClasses : {});
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: BadgeComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: BadgeComponent, isStandalone: true, selector: "c-badge", inputs: { color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null }, position: { classPropertyName: "position", publicName: "position", isSignal: true, isRequired: false, transformFunction: null }, shape: { classPropertyName: "shape", publicName: "shape", isSignal: true, isRequired: false, transformFunction: null }, size: { classPropertyName: "size", publicName: "size", isSignal: true, isRequired: false, transformFunction: null }, textColor: { classPropertyName: "textColor", publicName: "textColor", isSignal: true, isRequired: false, transformFunction: null }, textBgColor: { classPropertyName: "textBgColor", publicName: "textBgColor", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "badge" }, hostDirectives: [{ directive: TextColorDirective, inputs: ["cTextColor", "textColor"] }, { directive: TextBgColorDirective, inputs: ["cTextBgColor", "textBgColor"] }], ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: BadgeComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-badge',
                    template: '<ng-content />',
                    hostDirectives: [
                        { directive: TextColorDirective, inputs: ['cTextColor: textColor'] },
                        { directive: TextBgColorDirective, inputs: ['cTextBgColor: textBgColor'] }
                    ],
                    host: {
                        class: 'badge',
                        '[class]': 'hostClasses()'
                    }
                }]
        }] });

class BadgeModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: BadgeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: BadgeModule, imports: [BadgeComponent], exports: [BadgeComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: BadgeModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: BadgeModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        BadgeComponent
                    ],
                    exports: [
                        BadgeComponent
                    ]
                }]
        }] });

class BackdropService {
    constructor() {
        this.#backdropClick = new Subject();
        this.backdropClick$ = this.#backdropClick.asObservable();
        this.#document = inject(DOCUMENT);
        this.#rendererFactory = inject(RendererFactory2);
        this.#renderer = this.#rendererFactory.createRenderer(null, null);
        this.scrollbarWidth = this.#scrollbarWidth;
        this.#scrollBarVisible = true;
    }
    #backdropClick;
    #document;
    #rendererFactory;
    #renderer;
    #unListen;
    get #scrollbarWidth() {
        // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
        const documentWidth = this.#document.documentElement.clientWidth;
        const scrollbarWidth = Math.abs((this.#document.defaultView?.innerWidth ?? documentWidth) - documentWidth);
        return `${scrollbarWidth}px`;
    }
    setBackdrop(type = 'modal') {
        const backdropElement = this.#renderer.createElement('div');
        this.#renderer.addClass(backdropElement, `${type}-backdrop`);
        this.#renderer.addClass(backdropElement, 'fade');
        this.#renderer.appendChild(this.#document.body, backdropElement);
        this.#unListen = this.#renderer.listen(backdropElement, 'click', (e) => {
            this.onClickHandler();
        });
        this.scrollbarWidth = this.#scrollbarWidth;
        setTimeout(() => {
            this.#renderer.addClass(backdropElement, 'show');
            // this.hideScrollbar();
        });
        this.activeBackdrop = backdropElement;
        return backdropElement;
    }
    clearBackdrop(backdropElement) {
        if (backdropElement) {
            this.#unListen();
            this.#renderer.removeClass(backdropElement, 'show');
            setTimeout(() => {
                if (this.activeBackdrop === backdropElement) {
                    this.resetScrollbar();
                }
                this.#renderer.removeChild(this.#document.body, backdropElement);
                backdropElement = undefined;
            }, 300);
        }
        return undefined;
    }
    get #isRTL() {
        return [this.#document.documentElement.dir, this.#document.body.dir].includes('rtl');
    }
    #scrollBarVisible;
    hideScrollbar() {
        if (this.#scrollBarVisible) {
            this.#renderer.setStyle(this.#document.body, 'overflow', 'hidden');
            this.#renderer.setStyle(this.#document.body, `padding-${this.#isRTL ? 'left' : 'right'}`, this.scrollbarWidth);
            this.#scrollBarVisible = false;
        }
    }
    resetScrollbar() {
        this.#renderer.removeStyle(this.#document.body, 'overflow');
        this.#renderer.removeStyle(this.#document.body, `padding-${this.#isRTL ? 'left' : 'right'}`);
        this.#scrollBarVisible = true;
    }
    onClickHandler() {
        this.#backdropClick.next(true);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: BackdropService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: BackdropService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: BackdropService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class BreadcrumbItemComponent {
    constructor() {
        /**
         * Toggle the active state for the component. [docs]
         * @return boolean
         */
        this.active = input(undefined, { transform: booleanAttribute });
        /**
         * The `url` prop for the inner `[routerLink]` directive. [docs]
         * @type string
         */
        this.url = input();
        /**
         * Additional html attributes for link. [docs]
         * @type INavAttributes
         */
        this.attributes = input();
        /**
         * Some `NavigationExtras` props for the inner `[routerLink]` directive and `routerLinkActiveOptions`. [docs]
         * @type INavLinkProps
         */
        this.linkProps = input();
        this.ariaCurrent = computed(() => {
            return this.active() ? 'page' : null;
        });
        this.hostClasses = computed(() => {
            return {
                'breadcrumb-item': true,
                active: this.active()
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: BreadcrumbItemComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.2", type: BreadcrumbItemComponent, isStandalone: true, selector: "c-breadcrumb-item", inputs: { active: { classPropertyName: "active", publicName: "active", isSignal: true, isRequired: false, transformFunction: null }, url: { classPropertyName: "url", publicName: "url", isSignal: true, isRequired: false, transformFunction: null }, attributes: { classPropertyName: "attributes", publicName: "attributes", isSignal: true, isRequired: false, transformFunction: null }, linkProps: { classPropertyName: "linkProps", publicName: "linkProps", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.aria-current": "ariaCurrent()", "class": "hostClasses()" } }, exportAs: ["breadcrumbItem"], ngImport: i0, template: "@if (!active()) {\n  <a [routerLink]=\"url()\"\n     [cHtmlAttr]=\"attributes() ?? {}\"\n     [target]=\"attributes()?.['target']\"\n     [queryParams]=\"linkProps()?.queryParams ?? null\"\n     [fragment]=\"linkProps()?.fragment\"\n     [queryParamsHandling]=\"linkProps()?.queryParamsHandling ?? null\"\n     [preserveFragment]=\"linkProps()?.preserveFragment ?? false\"\n     [skipLocationChange]=\"linkProps()?.skipLocationChange ?? false\"\n     [replaceUrl]=\"linkProps()?.replaceUrl ?? false\"\n     [state]=\"linkProps()?.state ?? {}\"\n  >\n    <ng-container *ngTemplateOutlet=\"defaultBreadcrumbItemContentTemplate\" />\n  </a>\n} @else {\n  <span [cHtmlAttr]=\"attributes() ?? {}\">\n      <ng-container *ngTemplateOutlet=\"defaultBreadcrumbItemContentTemplate\" />\n  </span>\n}\n\n<ng-template #defaultBreadcrumbItemContentTemplate>\n  <ng-content />\n</ng-template>\n", styles: [":host{display:list-item;text-align:-webkit-match-parent;text-align:match-parent}\n"], dependencies: [{ kind: "ngmodule", type: RouterModule }, { kind: "directive", type: i1.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "info", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: HtmlAttributesDirective, selector: "[cHtmlAttr]", inputs: ["cHtmlAttr"], exportAs: ["cHtmlAttr"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: BreadcrumbItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-breadcrumb-item', imports: [RouterModule, NgTemplateOutlet, HtmlAttributesDirective], exportAs: 'breadcrumbItem', host: {
                        '[attr.aria-current]': 'ariaCurrent()',
                        '[class]': 'hostClasses()'
                    }, template: "@if (!active()) {\n  <a [routerLink]=\"url()\"\n     [cHtmlAttr]=\"attributes() ?? {}\"\n     [target]=\"attributes()?.['target']\"\n     [queryParams]=\"linkProps()?.queryParams ?? null\"\n     [fragment]=\"linkProps()?.fragment\"\n     [queryParamsHandling]=\"linkProps()?.queryParamsHandling ?? null\"\n     [preserveFragment]=\"linkProps()?.preserveFragment ?? false\"\n     [skipLocationChange]=\"linkProps()?.skipLocationChange ?? false\"\n     [replaceUrl]=\"linkProps()?.replaceUrl ?? false\"\n     [state]=\"linkProps()?.state ?? {}\"\n  >\n    <ng-container *ngTemplateOutlet=\"defaultBreadcrumbItemContentTemplate\" />\n  </a>\n} @else {\n  <span [cHtmlAttr]=\"attributes() ?? {}\">\n      <ng-container *ngTemplateOutlet=\"defaultBreadcrumbItemContentTemplate\" />\n  </span>\n}\n\n<ng-template #defaultBreadcrumbItemContentTemplate>\n  <ng-content />\n</ng-template>\n", styles: [":host{display:list-item;text-align:-webkit-match-parent;text-align:match-parent}\n"] }]
        }] });

class BreadcrumbComponent {
    constructor() {
        /**
         * Default aria-label for breadcrumb. [docs]
         * @return string
         * @default 'breadcrumb'
         */
        this.ariaLabel = input('breadcrumb');
        /**
         * Default role for breadcrumb. [docs]
         * @return string
         * @default 'navigation'
         */
        this.role = input('navigation');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: BreadcrumbComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: BreadcrumbComponent, isStandalone: true, selector: "c-breadcrumb", inputs: { ariaLabel: { classPropertyName: "ariaLabel", publicName: "ariaLabel", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.aria-label": "ariaLabel()", "attr.role": "role()" }, classAttribute: "breadcrumb" }, ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: BreadcrumbComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-breadcrumb',
                    template: '<ng-content />',
                    host: {
                        class: 'breadcrumb',
                        '[attr.aria-label]': 'ariaLabel()',
                        '[attr.role]': 'role()'
                    }
                }]
        }] });

class BreadcrumbRouterService {
    #router;
    #activatedRoute;
    #breadcrumbsBehaviorSubject;
    constructor() {
        this.#router = inject(Router);
        this.#activatedRoute = inject(ActivatedRoute);
        this.outlet = 'primary';
        this.#breadcrumbsBehaviorSubject = new BehaviorSubject(new Array());
        this.breadcrumbs$ = this.#breadcrumbsBehaviorSubject.asObservable();
        this.#router.events
            .pipe(takeUntilDestroyed(), filter((event) => event instanceof NavigationEnd))
            .subscribe((event) => {
            const breadcrumbs = [];
            let currentRoute = this.#activatedRoute.root;
            let url = '';
            do {
                const childrenRoutes = currentRoute.children;
                currentRoute = null;
                childrenRoutes.forEach((childRoute) => {
                    // console.log('breadcrumb event', event, 'route', route);
                    if (childRoute.outlet === this.outlet) {
                        const routeSnapshot = childRoute.snapshot;
                        url += '/' + routeSnapshot.url.map((segment) => segment.path).join('/');
                        breadcrumbs.push({
                            label: routeSnapshot.data['title'] ?? routeSnapshot.title ?? '',
                            url,
                            queryParams: routeSnapshot.queryParams
                        });
                        currentRoute = childRoute;
                    }
                });
            } while (currentRoute);
            this.#breadcrumbsBehaviorSubject.next(Object.assign([], breadcrumbs));
            return breadcrumbs;
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: BreadcrumbRouterService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: BreadcrumbRouterService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: BreadcrumbRouterService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [] });

class BreadcrumbRouterComponent {
    constructor() {
        this.service = inject(BreadcrumbRouterService);
        /**
         * Optional array of IBreadcrumbItem to override default BreadcrumbRouter behavior. [docs]
         * @return IBreadcrumbItem[]
         */
        this.items = input();
        this.setup = effect(() => {
            const items = this.items();
            if (items && items.length > 0) {
                this.breadcrumbs = new Observable((observer) => {
                    const itemsValue = this.items();
                    if (itemsValue) {
                        observer.next(itemsValue);
                    }
                });
            }
        });
    }
    ngOnInit() {
        this.breadcrumbs = this.service.breadcrumbs$;
    }
    ngOnDestroy() {
        this.breadcrumbs = undefined;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: BreadcrumbRouterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.2", type: BreadcrumbRouterComponent, isStandalone: true, selector: "c-breadcrumb-router, [cBreadcrumbRouter]", inputs: { items: { classPropertyName: "items", publicName: "items", isSignal: true, isRequired: false, transformFunction: null } }, ngImport: i0, template: "<c-breadcrumb class=\"m-0\">\n  @for (breadcrumb of breadcrumbs | async; track breadcrumb; let last = $last) {\n    @if (breadcrumb?.label && (breadcrumb?.url?.slice(-1) === '/' || last)) {\n      <c-breadcrumb-item\n        [active]=\"last\"\n        [url]=\"breadcrumb?.url\"\n        [attributes]=\"breadcrumb?.attributes\"\n        [linkProps]=\"breadcrumb?.linkProps\"\n      >\n        {{ breadcrumb?.label }}\n      </c-breadcrumb-item>\n    }\n  }\n</c-breadcrumb>\n", dependencies: [{ kind: "component", type: BreadcrumbComponent, selector: "c-breadcrumb", inputs: ["ariaLabel", "role"] }, { kind: "component", type: BreadcrumbItemComponent, selector: "c-breadcrumb-item", inputs: ["active", "url", "attributes", "linkProps"], exportAs: ["breadcrumbItem"] }, { kind: "pipe", type: AsyncPipe, name: "async" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: BreadcrumbRouterComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-breadcrumb-router, [cBreadcrumbRouter]', imports: [BreadcrumbComponent, BreadcrumbItemComponent, AsyncPipe], template: "<c-breadcrumb class=\"m-0\">\n  @for (breadcrumb of breadcrumbs | async; track breadcrumb; let last = $last) {\n    @if (breadcrumb?.label && (breadcrumb?.url?.slice(-1) === '/' || last)) {\n      <c-breadcrumb-item\n        [active]=\"last\"\n        [url]=\"breadcrumb?.url\"\n        [attributes]=\"breadcrumb?.attributes\"\n        [linkProps]=\"breadcrumb?.linkProps\"\n      >\n        {{ breadcrumb?.label }}\n      </c-breadcrumb-item>\n    }\n  }\n</c-breadcrumb>\n" }]
        }] });

class BreadcrumbModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: BreadcrumbModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: BreadcrumbModule, imports: [BreadcrumbComponent,
            BreadcrumbItemComponent,
            BreadcrumbRouterComponent], exports: [BreadcrumbComponent,
            BreadcrumbItemComponent,
            BreadcrumbRouterComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: BreadcrumbModule, providers: [BreadcrumbRouterService], imports: [BreadcrumbItemComponent,
            BreadcrumbRouterComponent] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: BreadcrumbModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        BreadcrumbComponent,
                        BreadcrumbItemComponent,
                        BreadcrumbRouterComponent
                    ],
                    exports: [
                        BreadcrumbComponent,
                        BreadcrumbItemComponent,
                        BreadcrumbRouterComponent
                    ],
                    providers: [BreadcrumbRouterService]
                }]
        }] });

class ButtonGroupComponent {
    constructor() {
        /**
         * Size the component small or large.
         * @type { 'sm' | 'lg' }
         */
        this.size = input();
        /**
         * Create a set of buttons that appear vertically stacked rather than horizontally. Split button dropdowns are not supported here.
         * @type boolean
         */
        this.vertical = input(false, { transform: booleanAttribute });
        /**
         * Default role attr for ButtonGroup. [docs]
         * @type InputSignal<string>
         * @default 'group'
         */
        this.role = input('group');
        this.hostClasses = computed(() => {
            return {
                'btn-group': !this.vertical(),
                'btn-group-vertical': this.vertical(),
                [`btn-group-${this.size()}`]: !!this.size()
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ButtonGroupComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: ButtonGroupComponent, isStandalone: true, selector: "c-button-group", inputs: { size: { classPropertyName: "size", publicName: "size", isSignal: true, isRequired: false, transformFunction: null }, vertical: { classPropertyName: "vertical", publicName: "vertical", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.role": "role()", "class": "hostClasses()" } }, ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ButtonGroupComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-button-group',
                    template: '<ng-content />',
                    host: { '[attr.role]': 'role()', '[class]': 'hostClasses()' }
                }]
        }] });

class ButtonToolbarComponent {
    constructor() {
        /**
         * Default role attr for ButtonToolbar. [docs]
         * @type InputSignal<string>
         * @default 'toolbar'
         */
        this.role = input('toolbar');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ButtonToolbarComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: ButtonToolbarComponent, isStandalone: true, selector: "c-button-toolbar", inputs: { role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.role": "role()" }, classAttribute: "btn-toolbar" }, ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ButtonToolbarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-button-toolbar',
                    template: '<ng-content />',
                    host: { class: 'btn-toolbar', '[attr.role]': 'role()' }
                }]
        }] });

class ButtonGroupModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ButtonGroupModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: ButtonGroupModule, imports: [ButtonGroupComponent, ButtonToolbarComponent], exports: [ButtonGroupComponent, ButtonToolbarComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ButtonGroupModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ButtonGroupModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [ButtonGroupComponent, ButtonToolbarComponent],
                    exports: [ButtonGroupComponent, ButtonToolbarComponent]
                }]
        }] });

class CalloutComponent {
    constructor() {
        /**
         * Sets the color context of the component to one of CoreUI’s themed colors.
         * @type Colors
         */
        this.color = input();
        this.hostClasses = computed(() => {
            const color = this.color();
            return {
                callout: true,
                [`callout-${color}`]: !!color
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CalloutComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: CalloutComponent, isStandalone: true, selector: "c-callout, [cCallout]", inputs: { color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "callout" }, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CalloutComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-callout, [cCallout]', template: '<ng-content />', host: { class: 'callout', '[class]': 'hostClasses()' }, styles: [":host{display:block}\n"] }]
        }] });

class CalloutModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CalloutModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: CalloutModule, imports: [CalloutComponent], exports: [CalloutComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CalloutModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CalloutModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [CalloutComponent],
                    imports: [CalloutComponent]
                }]
        }] });

class CardComponent {
    constructor() {
        /**
         * Sets the color context of the component to one of CoreUI’s themed colors.
         * @type Colors
         */
        this.color = input();
        /**
         * Sets the text color context of the component to one of CoreUI’s themed colors.
         * via TextColorDirective
         * @type TextColors
         */
        this.textColor = input();
        /**
         * Sets the component's color scheme to one of CoreUI themed colors, ensuring the text color contrast adheres to the WCAG 4.5:1 contrast ratio standard for accessibility.
         * via TextBgColorDirective
         * @type Colors
         * @since 5.0.0
         */
        this.textBgColor = input();
        this.hostClasses = computed(() => {
            const color = this.color();
            return {
                card: true,
                [`bg-${color}`]: !!color
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: CardComponent, isStandalone: true, selector: "c-card, [c-card]", inputs: { color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null }, textColor: { classPropertyName: "textColor", publicName: "textColor", isSignal: true, isRequired: false, transformFunction: null }, textBgColor: { classPropertyName: "textBgColor", publicName: "textBgColor", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "card" }, hostDirectives: [{ directive: TextColorDirective, inputs: ["cTextColor", "textColor"] }, { directive: TextBgColorDirective, inputs: ["cTextBgColor", "textBgColor"] }], ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-card, [c-card]',
                    template: '<ng-content />',
                    hostDirectives: [
                        { directive: TextColorDirective, inputs: ['cTextColor: textColor'] },
                        { directive: TextBgColorDirective, inputs: ['cTextBgColor: textBgColor'] }
                    ],
                    host: { class: 'card', '[class]': 'hostClasses()' }
                }]
        }] });

class CardBodyComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardBodyComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: CardBodyComponent, isStandalone: true, selector: "c-card-body, [c-card-body]", host: { classAttribute: "card-body" }, ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardBodyComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-card-body, [c-card-body]',
                    template: '<ng-content />',
                    host: { class: 'card-body' }
                }]
        }] });

class CardFooterComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardFooterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: CardFooterComponent, isStandalone: true, selector: "c-card-footer, [c-card-footer]", host: { classAttribute: "card-footer" }, ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardFooterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-card-footer, [c-card-footer]',
                    template: '<ng-content />',
                    host: { class: 'card-footer' }
                }]
        }] });

class CardGroupComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardGroupComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: CardGroupComponent, isStandalone: true, selector: "c-card-group, [c-card-group]", host: { classAttribute: "card-group" }, ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardGroupComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-card-group, [c-card-group]',
                    template: '<ng-content />',
                    host: { class: 'card-group' }
                }]
        }] });

class CardHeaderComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardHeaderComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: CardHeaderComponent, isStandalone: true, selector: "c-card-header, [c-card-header]", host: { classAttribute: "card-header" }, ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardHeaderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-card-header, [c-card-header]',
                    template: '<ng-content />',
                    host: { class: 'card-header' }
                }]
        }] });

class CardHeaderActionsComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardHeaderActionsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: CardHeaderActionsComponent, isStandalone: true, selector: "c-card-header-actions, [c-card-header-actions]", host: { classAttribute: "card-header-actions" }, ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardHeaderActionsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-card-header-actions, [c-card-header-actions]',
                    template: '<ng-content />',
                    host: { class: 'card-header-actions' }
                }]
        }] });

class CardImgDirective {
    constructor() {
        /**
         * Optionally orientate the image to the top, bottom, or make it overlaid across the card.
         * @type {'top | 'bottom'}
         */
        this.orientation = input(undefined, { alias: 'cCardImg' });
        this.hostClasses = computed(() => {
            const orientation = this.orientation();
            const suffix = !!orientation ? `-${orientation}` : '';
            const horizontal = ['start', 'end'].includes(orientation ?? '-') ? orientation : undefined;
            return {
                [`card-img${suffix}`]: !horizontal,
                'img-fluid': !!horizontal,
                [`rounded-${horizontal}`]: !!horizontal
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardImgDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: CardImgDirective, isStandalone: true, selector: "[cCardImg]", inputs: { orientation: { classPropertyName: "orientation", publicName: "cCardImg", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardImgDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cCardImg]',
                    host: { '[class]': 'hostClasses()' }
                }]
        }] });

class CardImgOverlayComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardImgOverlayComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: CardImgOverlayComponent, isStandalone: true, selector: "c-card-img-overlay", host: { classAttribute: "card-img-overlay" }, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardImgOverlayComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-card-img-overlay', template: '<ng-content />', host: { class: 'card-img-overlay' }, styles: [":host{display:block}\n"] }]
        }] });

class CardLinkDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardLinkDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.2", type: CardLinkDirective, isStandalone: true, selector: "[cCardLink]", host: { classAttribute: "card-link" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardLinkDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cCardLink]',
                    host: { class: 'card-link' }
                }]
        }] });

class CardSubtitleDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardSubtitleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.2", type: CardSubtitleDirective, isStandalone: true, selector: "[cCardSubtitle]", host: { classAttribute: "card-subtitle" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardSubtitleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cCardSubtitle]',
                    host: { class: 'card-subtitle' }
                }]
        }] });

class CardTextDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardTextDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.2", type: CardTextDirective, isStandalone: true, selector: "[cCardText]", host: { classAttribute: "card-text" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardTextDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cCardText]',
                    host: { class: 'card-text' }
                }]
        }] });

class CardTitleDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardTitleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.2", type: CardTitleDirective, isStandalone: true, selector: "[cCardTitle]", host: { classAttribute: "card-title" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardTitleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cCardTitle]',
                    host: { class: 'card-title' }
                }]
        }] });

class CardModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: CardModule, imports: [CardComponent,
            CardBodyComponent,
            CardFooterComponent,
            CardGroupComponent,
            CardHeaderComponent,
            CardHeaderActionsComponent,
            CardImgDirective,
            CardImgOverlayComponent,
            CardLinkDirective,
            CardSubtitleDirective,
            CardTextDirective,
            CardTitleDirective], exports: [CardComponent,
            CardBodyComponent,
            CardFooterComponent,
            CardGroupComponent,
            CardHeaderComponent,
            CardHeaderActionsComponent,
            CardImgDirective,
            CardImgOverlayComponent,
            CardLinkDirective,
            CardSubtitleDirective,
            CardTextDirective,
            CardTitleDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CardModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CardComponent,
                        CardBodyComponent,
                        CardFooterComponent,
                        CardGroupComponent,
                        CardHeaderComponent,
                        CardHeaderActionsComponent,
                        CardImgDirective,
                        CardImgOverlayComponent,
                        CardLinkDirective,
                        CardSubtitleDirective,
                        CardTextDirective,
                        CardTitleDirective
                    ],
                    exports: [
                        CardComponent,
                        CardBodyComponent,
                        CardFooterComponent,
                        CardGroupComponent,
                        CardHeaderComponent,
                        CardHeaderActionsComponent,
                        CardImgDirective,
                        CardImgOverlayComponent,
                        CardLinkDirective,
                        CardSubtitleDirective,
                        CardTextDirective,
                        CardTitleDirective
                    ]
                }]
        }] });

class IntersectionService {
    constructor() {
        this.platformId = inject(PLATFORM_ID);
        this.#intersecting = new BehaviorSubject({ isIntersecting: false });
        this.intersecting$ = this.#intersecting.asObservable();
        this.defaultObserverOptions = {
            root: null,
            rootMargin: '0px',
            threshold: 0.2
        };
        this.hostElementRefs = new Map();
    }
    #intersecting;
    createIntersectionObserver(hostElement, observerOptions = this.defaultObserverOptions) {
        if (isPlatformServer(this.platformId)) {
            this.#intersecting.next({ isIntersecting: true, hostElement });
            return;
        }
        const options = { ...this.defaultObserverOptions, ...observerOptions };
        const handleIntersect = (entries, observer) => {
            entries.forEach((entry) => {
                this.#intersecting.next({ isIntersecting: entry.isIntersecting, hostElement });
            });
        };
        this.hostElementRefs.set(hostElement, new IntersectionObserver(handleIntersect, options));
        this.hostElementRefs.get(hostElement)?.observe(hostElement.nativeElement);
    }
    unobserve(elementRef) {
        this.hostElementRefs.get(elementRef)?.unobserve(elementRef.nativeElement);
        this.hostElementRefs.set(elementRef, null);
        this.hostElementRefs.delete(elementRef);
    }
    ngOnDestroy() {
        this.hostElementRefs.forEach((observer, elementRef) => {
            observer?.unobserve(elementRef.nativeElement);
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: IntersectionService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: IntersectionService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: IntersectionService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class ListenersService {
    constructor() {
        this.renderer = inject(Renderer2);
        this.listeners = new Map();
    }
    setListeners({ hostElement, trigger, callbackOn, callbackOff, callbackToggle, }) {
        const host = hostElement.nativeElement;
        const triggers = Array.isArray(trigger) ? trigger : trigger?.split(' ') ?? [];
        if (triggers?.includes('click')) {
            typeof callbackToggle === 'function' &&
                this.listeners.set('click', this.renderer.listen(host, 'click', callbackToggle));
        }
        if (triggers?.includes('focus')) {
            typeof callbackOn === 'function' &&
                this.listeners.set('focus', this.renderer.listen(host, 'focus', callbackOn));
        }
        if (triggers?.includes('focusin')) {
            typeof callbackOff === 'function' &&
                this.listeners.set('focusout', this.renderer.listen(host, 'focusout', callbackOff));
            typeof callbackOn === 'function' &&
                this.listeners.set('focusin', this.renderer.listen(host, 'focusin', callbackOn));
        }
        if (triggers?.includes('click') || triggers?.includes('focus')) {
            typeof callbackOff === 'function' &&
                this.listeners.set('blur', this.renderer.listen(host, 'blur', callbackOff));
        }
        if (triggers?.includes('hover')) {
            typeof callbackOn === 'function' &&
                this.listeners.set('mouseenter', this.renderer.listen(host, 'mouseenter', callbackOn));
            typeof callbackOff === 'function' &&
                this.listeners.set('mouseleave', this.renderer.listen(host, 'mouseleave', callbackOff));
        }
    }
    clearListeners() {
        this.listeners.forEach((unListen, key) => {
            unListen();
        });
        this.listeners.forEach((unListen, key) => {
            // @ts-ignore
            this.listeners.set(key, null);
        });
        this.listeners.clear();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ListenersService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ListenersService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ListenersService, decorators: [{
            type: Injectable
        }] });

class ClassToggleService {
    #document = inject(DOCUMENT);
    #rendererFactory = inject(RendererFactory2);
    #renderer;
    constructor() {
        this.#renderer = this.#rendererFactory.createRenderer(null, null);
    }
    toggle(selector, className) {
        const element = this.#document.querySelector(selector);
        if (element) {
            element.classList.contains(className)
                ? this.#renderer.removeClass(element, className)
                : this.#renderer.addClass(element, className);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ClassToggleService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ClassToggleService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ClassToggleService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [] });

class InMemoryStorageService {
    #storage = new Map();
    setItem(key, data) {
        this.#storage.set(key, JSON.stringify(data));
    }
    getItem(key) {
        return this.#storage.has(key) ? JSON.parse(this.#storage.get(key) ?? 'null') : undefined;
    }
    removeItem(key) {
        this.#storage.delete(key);
    }
    clear() {
        this.#storage.clear();
    }
    get length() {
        return this.#storage.size;
    }
    key(index) {
        return Array.from(this.#storage.keys())[index];
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: InMemoryStorageService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: InMemoryStorageService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: InMemoryStorageService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class LocalStorageService {
    constructor() {
        this.platformId = inject(PLATFORM_ID);
        this.document = inject(DOCUMENT);
        this.#data$ = new BehaviorSubject(null);
        this.data$ = this.#data$.asObservable();
        this.#localStorage =
            isPlatformBrowser(this.platformId) && this.document.defaultView
                ? this.document.defaultView?.localStorage
                : new InMemoryStorageService();
    }
    #localStorage;
    #data$;
    setItem(key, data) {
        this.#localStorage.setItem(key, JSON.stringify(data));
        this.#data$.next({ key, data });
    }
    getItem(key) {
        const data = JSON.parse(this.#localStorage.getItem(key) || 'null');
        this.#data$.next({ key, data });
        return data;
    }
    removeItem(key) {
        this.#localStorage.removeItem(key);
        this.#data$.next({ key, data: null });
    }
    clear() {
        this.#localStorage.clear();
        this.#data$.next(null);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: LocalStorageService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: LocalStorageService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: LocalStorageService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [] });

class ColorModeService {
    #destroyRef;
    #document;
    #localStorage;
    #colorModeEffect;
    constructor() {
        this.#destroyRef = inject(DestroyRef);
        this.#document = inject(DOCUMENT);
        this.#localStorage = inject(LocalStorageService);
        this.eventName = signal('ColorSchemeChange');
        this.localStorageItemName = signal(undefined);
        this.localStorageItemName$ = toObservable(this.localStorageItemName);
        this.colorMode = signal(undefined);
        this.#colorModeEffect = effect(() => {
            const colorMode = this.colorMode();
            if (colorMode) {
                const localStorageItemName = this.localStorageItemName();
                localStorageItemName && this.setStoredTheme(localStorageItemName, colorMode);
                this.#setTheme(colorMode);
            }
        });
        afterNextRender({
            read: () => {
                this.localStorageItemName$
                    .pipe(tap((params) => {
                    this.colorMode.set(this.getDefaultScheme(params));
                }), takeUntilDestroyed(this.#destroyRef))
                    .subscribe();
            }
        });
    }
    getStoredTheme(localStorageItemName) {
        return this.#localStorage.getItem(localStorageItemName);
    }
    setStoredTheme(localStorageItemName, colorMode) {
        return this.#localStorage.setItem(localStorageItemName, colorMode);
    }
    removeStoredTheme(localStorageItemName) {
        this.#localStorage.removeItem(localStorageItemName);
    }
    getDefaultScheme(localStorageItemName) {
        if (this.#document.defaultView === undefined) {
            return this.getDatasetTheme();
        }
        const storedTheme = localStorageItemName && this.getStoredTheme(localStorageItemName);
        return storedTheme ?? this.getDatasetTheme();
    }
    getPrefersColorScheme() {
        return this.#document.defaultView?.matchMedia('(prefers-color-scheme: dark)').matches
            ? 'dark'
            : this.#document.defaultView?.matchMedia('(prefers-color-scheme: light)').matches
                ? 'light'
                : undefined;
    }
    getDatasetTheme() {
        return this.#document.documentElement.dataset['coreuiTheme'];
    }
    #setTheme(colorMode) {
        this.#document.documentElement.dataset['coreuiTheme'] =
            colorMode === 'auto' ? this.getPrefersColorScheme() : colorMode;
        const event = new Event(this.eventName());
        this.#document.documentElement.dispatchEvent(event);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ColorModeService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ColorModeService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ColorModeService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: () => [] });

class UIDService {
    #document = inject(DOCUMENT);
    getUID(prefix = 'random-id') {
        let uid = prefix;
        do {
            uid = `${prefix}-${Math.floor(Math.random() * 1000000).toString(10)}`;
        } while (this.#document.getElementById(uid));
        return uid;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: UIDService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: UIDService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: UIDService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class RtlService {
    #document = inject(DOCUMENT);
    isRTL(element) {
        if (element) {
            return element.closest('[dir="rtl"]') !== null;
        }
        return this.#document?.documentElement?.dir === 'rtl' || this.#document?.body?.dir === 'rtl';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: RtlService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: RtlService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: RtlService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class CarouselService {
    constructor() {
        this.#carouselIndex = new BehaviorSubject({});
        this.carouselIndex$ = this.#carouselIndex.asObservable();
    }
    #carouselIndex;
    setIndex(index) {
        this.#carouselIndex.next(index);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CarouselService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CarouselService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CarouselService, decorators: [{
            type: Injectable
        }] });

class CarouselState {
    #carouselService = inject(CarouselService);
    #state = {
        activeItemIndex: -1,
        animate: true,
        items: [],
        direction: 'next',
        transition: 'slide',
        interval: 0
    };
    get state() {
        return this.#state;
    }
    set state(state) {
        const prevState = { ...this.#state };
        const nextState = { ...this.#state, ...state };
        this.#state = nextState;
        if (prevState.activeItemIndex !== nextState.activeItemIndex) {
            const activeItemIndex = this.state.activeItemIndex || 0;
            const itemInterval = (this.state.items && this.state.items[activeItemIndex]?.interval()) || -1;
            this.#carouselService.setIndex({
                active: nextState.activeItemIndex,
                interval: itemInterval,
                lastItemIndex: (nextState.items?.length ?? 0) - 1
            });
        }
    }
    setItems(newItems) {
        if (newItems.length) {
            const itemsArray = newItems;
            itemsArray.forEach((item, i) => {
                item.index = i;
            });
            this.state = {
                items: [...itemsArray]
            };
        }
        else {
            this.reset();
        }
    }
    setNextIndex(nextIndex) {
        this.#carouselService.setIndex(nextIndex);
    }
    direction(direction = 'next') {
        this.state = { direction };
        const { activeItemIndex = -1, items } = this.state;
        const itemsCount = items?.length ?? 0;
        if (itemsCount > 0) {
            return direction === 'next'
                ? activeItemIndex === itemsCount - 1
                    ? 0
                    : activeItemIndex + 1
                : activeItemIndex === 0
                    ? itemsCount - 1
                    : activeItemIndex - 1;
        }
        else {
            return 0;
        }
    }
    reset() {
        this.state = {
            activeItemIndex: -1,
            animate: true,
            items: [],
            direction: 'next',
            transition: 'slide',
            interval: 0
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CarouselState, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CarouselState }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CarouselState, decorators: [{
            type: Injectable
        }] });

class CarouselConfig {
    constructor() {
        /* Animate transition of slides */
        this.activeIndex = 0;
        /* Animate transition of slides */
        this.animate = true;
        /* Default direction of auto changing of slides */
        this.direction = 'next';
        /* Default interval of auto changing of slides */
        this.interval = 0;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CarouselConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CarouselConfig, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CarouselConfig, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class CarouselComponent {
    #hostElement;
    #carouselService;
    #carouselState;
    #intersectionService;
    #listenersService;
    constructor(config) {
        this.config = config;
        this.#hostElement = inject(ElementRef);
        this.#carouselService = inject(CarouselService);
        this.#carouselState = inject(CarouselState);
        this.#intersectionService = inject(IntersectionService);
        this.#listenersService = inject(ListenersService);
        /**
         * Index of the active item.
         * @return number
         */
        this.activeIndexInput = input(0, { alias: 'activeIndex' });
        this.activeIndex = linkedSignal({
            source: this.activeIndexInput,
            computation: (value) => value
        });
        /**
         * Carousel automatically starts cycle items.
         * @return boolean
         */
        this.animateInput = input(true, { alias: 'animate' });
        this.animate = linkedSignal({
            source: this.animateInput,
            computation: (value) => value
        });
        /**
         * Carousel direction. [docs]
         * @return {'next' | 'prev'}
         */
        this.directionInput = input('next', { alias: 'direction' });
        this.direction = linkedSignal({
            source: this.directionInput,
            computation: (value) => value
        });
        /**
         * The amount of time to delay between automatically cycling an item. If false, carousel will not automatically cycle.
         * @return number
         * @default 0
         */
        this.intervalInput = input(0, { alias: 'interval' });
        this.interval = linkedSignal({
            source: this.intervalInput,
            computation: (value) => value
        });
        this.#intervalEffect = effect(() => {
            const interval = this.interval();
            this.#carouselState.state = { interval: interval };
            interval ? this.setTimer() : this.resetTimer();
        });
        /**
         * Sets which event handlers you’d like provided to your pause prop. You can specify one trigger or an array of them.
         * @return {'hover' | 'focus' | 'click'}
         */
        this.pause = input('hover');
        /**
         * Support left/right swipe interactions on touchscreen devices.
         * @return boolean
         * @default true
         */
        this.touch = input(true);
        /**
         * Set type of the transition.
         * @return {'slide' | 'crossfade'}
         * @default 'slide'
         */
        this.transition = input('slide');
        /**
         * Set whether the carousel should cycle continuously or have hard stops.
         * @return boolean
         * @default true
         */
        this.wrap = input(true);
        /**
         * Event emitted on carousel item change. [docs]
         * @return number
         */
        this.itemChange = output();
        this.activeItemInterval = 0;
        this.#destroyRef = inject(DestroyRef);
        this.#visible = true;
        this.loadConfig();
    }
    loadConfig() {
        this.activeIndex.set(this.config?.activeIndex ?? this.activeIndex());
        this.animate.set(this.config?.animate ?? this.animate());
        this.direction.set(this.config?.direction ?? this.direction());
        this.interval.set(this.config?.interval ?? this.interval());
    }
    #intervalEffect;
    #destroyRef;
    ngOnInit() {
        this.carouselStateSubscribe();
    }
    ngOnDestroy() {
        this.resetTimer();
        this.clearListeners();
        this.swipeSubscribe(false);
    }
    ngAfterContentInit() {
        this.intersectionServiceSubscribe();
        this.#carouselState.state = {
            activeItemIndex: this.activeIndex(),
            animate: this.animate(),
            interval: this.interval(),
            transition: this.transition()
        };
        this.setListeners();
        this.swipeSubscribe();
    }
    setListeners() {
        const config = {
            hostElement: this.#hostElement,
            trigger: this.pause() || [],
            callbackOff: () => {
                this.setTimer();
            },
            callbackOn: () => {
                this.resetTimer();
            }
        };
        this.#listenersService.setListeners(config);
    }
    clearListeners() {
        this.#listenersService.clearListeners();
    }
    set visible(value) {
        this.#visible = value;
    }
    get visible() {
        return this.#visible;
    }
    #visible;
    setTimer() {
        const interval = this.activeItemInterval || this.interval();
        const direction = this.direction();
        this.resetTimer();
        if (interval > 0) {
            this.timerId = setTimeout(() => {
                const nextIndex = this.#carouselState.direction(direction);
                this.#carouselState.state = { activeItemIndex: nextIndex };
            }, interval);
        }
    }
    resetTimer() {
        clearTimeout(this.timerId);
        this.timerId = undefined;
    }
    carouselStateSubscribe() {
        this.#carouselService.carouselIndex$.pipe(takeUntilDestroyed(this.#destroyRef)).subscribe((nextItem) => {
            if ('active' in nextItem && typeof nextItem.active === 'number') {
                this.itemChange.emit(nextItem.active);
            }
            this.activeItemInterval =
                typeof nextItem.interval === 'number' && nextItem.interval > -1 ? nextItem.interval : this.interval();
            const direction = this.direction();
            const isLastItem = (nextItem.active === nextItem.lastItemIndex && direction === 'next') ||
                (nextItem.active === 0 && direction === 'prev');
            !this.wrap() && isLastItem ? this.resetTimer() : this.setTimer();
        });
    }
    intersectionServiceSubscribe() {
        this.#intersectionService.createIntersectionObserver(this.#hostElement);
        this.#intersectionService.intersecting$
            .pipe(filter((next) => next.hostElement === this.#hostElement), finalize(() => {
            this.#intersectionService.unobserve(this.#hostElement);
        }), takeUntilDestroyed(this.#destroyRef))
            .subscribe((next) => {
            this.visible = next.isIntersecting;
            next.isIntersecting ? this.setTimer() : this.resetTimer();
        });
    }
    swipeSubscribe(subscribe = true) {
        if (this.touch() && subscribe) {
            const carouselElement = this.#hostElement.nativeElement;
            const touchStart$ = fromEvent(carouselElement, 'touchstart');
            const touchEnd$ = fromEvent(carouselElement, 'touchend');
            const touchMove$ = fromEvent(carouselElement, 'touchmove');
            this.swipeSubscription = touchStart$
                .pipe(zipWith(touchEnd$.pipe(withLatestFrom(touchMove$))), takeUntilDestroyed(this.#destroyRef))
                .subscribe(([touchstart, [touchend, touchmove]]) => {
                touchstart.stopPropagation();
                touchmove.stopPropagation();
                const distanceX = touchstart.touches[0]?.clientX - touchmove.touches[0]?.clientX || 0;
                if (Math.abs(distanceX) > 0.3 * carouselElement.clientWidth && touchstart.timeStamp <= touchmove.timeStamp) {
                    const nextIndex = this.#carouselState.direction(distanceX > 0 ? 'next' : 'prev');
                    this.#carouselState.state = { activeItemIndex: nextIndex };
                }
            });
        }
        else {
            this.swipeSubscription?.unsubscribe();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CarouselComponent, deps: [{ token: CarouselConfig }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: CarouselComponent, isStandalone: true, selector: "c-carousel", inputs: { activeIndexInput: { classPropertyName: "activeIndexInput", publicName: "activeIndex", isSignal: true, isRequired: false, transformFunction: null }, animateInput: { classPropertyName: "animateInput", publicName: "animate", isSignal: true, isRequired: false, transformFunction: null }, directionInput: { classPropertyName: "directionInput", publicName: "direction", isSignal: true, isRequired: false, transformFunction: null }, intervalInput: { classPropertyName: "intervalInput", publicName: "interval", isSignal: true, isRequired: false, transformFunction: null }, pause: { classPropertyName: "pause", publicName: "pause", isSignal: true, isRequired: false, transformFunction: null }, touch: { classPropertyName: "touch", publicName: "touch", isSignal: true, isRequired: false, transformFunction: null }, transition: { classPropertyName: "transition", publicName: "transition", isSignal: true, isRequired: false, transformFunction: null }, wrap: { classPropertyName: "wrap", publicName: "wrap", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { itemChange: "itemChange" }, host: { properties: { "class.carousel-fade": "transition() === \"crossfade\" && animate()" }, classAttribute: "carousel slide" }, providers: [CarouselService, CarouselState, ListenersService], exportAs: ["cCarousel"], hostDirectives: [{ directive: ThemeDirective, inputs: ["dark", "dark"] }], ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CarouselComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-carousel', template: '<ng-content />', providers: [CarouselService, CarouselState, ListenersService], hostDirectives: [{ directive: ThemeDirective, inputs: ['dark'] }], exportAs: 'cCarousel', host: {
                        class: 'carousel slide',
                        '[class.carousel-fade]': 'transition() === "crossfade" && animate()'
                    }, styles: [":host{display:block}\n"] }]
        }], ctorParameters: () => [{ type: CarouselConfig, decorators: [{
                    type: Inject,
                    args: [CarouselConfig]
                }] }] });

class CarouselCaptionComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CarouselCaptionComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: CarouselCaptionComponent, isStandalone: true, selector: "c-carousel-caption", host: { properties: { "class.carousel-caption": "true" } }, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CarouselCaptionComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-carousel-caption', template: '<ng-content />', host: {
                        '[class.carousel-caption]': 'true'
                    }, styles: [":host{display:block}\n"] }]
        }] });

class CarouselControlComponent {
    constructor() {
        this.#carouselState = inject(CarouselState);
        /**
         * Carousel control caption. [docs]
         * @return string
         */
        this.captionInput = input(undefined, { alias: 'caption' });
        this.caption = linkedSignal({
            source: this.captionInput,
            computation: (value) => {
                return !!value ? value : this.direction() === 'prev' ? 'Previous' : 'Next';
            }
        });
        /**
         * Carousel control direction.
         * @return {'next' | 'prev'}
         */
        this.direction = input('next');
        /**
         * Carousel control role.
         * @return string
         */
        this.role = input('button');
        this.hostClasses = computed(() => {
            return `carousel-control-${this.direction()}`;
        });
        this.carouselControlIconClass = computed(() => {
            return `carousel-control-${this.direction()}-icon`;
        });
    }
    #carouselState;
    onKeyUp($event) {
        if ($event.key === 'Enter') {
            this.#play();
        }
        if ($event.key === 'ArrowLeft') {
            this.#play('prev');
        }
        if ($event.key === 'ArrowRight') {
            this.#play('next');
        }
    }
    onClick($event) {
        this.#play();
    }
    #play(direction = this.direction()) {
        const nextIndex = this.#carouselState.direction(direction);
        this.#carouselState.state = { activeItemIndex: nextIndex };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CarouselControlComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: CarouselControlComponent, isStandalone: true, selector: "c-carousel-control", inputs: { captionInput: { classPropertyName: "captionInput", publicName: "caption", isSignal: true, isRequired: false, transformFunction: null }, direction: { classPropertyName: "direction", publicName: "direction", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "keyup": "onKeyUp($event)", "click": "onClick($event)" }, properties: { "attr.role": "role()", "class": "hostClasses()" } }, exportAs: ["cCarouselControl"], ngImport: i0, template: "<ng-content>\n  <span [attr.aria-hidden]=\"true\" [class]=\"carouselControlIconClass()\"></span>\n  <span class=\"visually-hidden\">{{ caption() }}</span>\n</ng-content>\n" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CarouselControlComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-carousel-control', exportAs: 'cCarouselControl', host: {
                        '[attr.role]': 'role()',
                        '[class]': 'hostClasses()',
                        '(keyup)': 'onKeyUp($event)',
                        '(click)': 'onClick($event)'
                    }, template: "<ng-content>\n  <span [attr.aria-hidden]=\"true\" [class]=\"carouselControlIconClass()\"></span>\n  <span class=\"visually-hidden\">{{ caption() }}</span>\n</ng-content>\n" }]
        }] });

class CarouselIndicatorsComponent {
    constructor() {
        this.#destroyRef = inject(DestroyRef);
        this.#carouselService = inject(CarouselService);
        this.#carouselState = inject(CarouselState);
        this.items = [];
        this.active = 0;
        this.contentTemplates = contentChildren(TemplateIdDirective, { descendants: true });
        this.templates = computed(() => {
            return this.contentTemplates().reduce((acc, child) => {
                acc[child.id] = child.templateRef;
                return acc;
            }, {});
        });
    }
    #destroyRef;
    #carouselService;
    #carouselState;
    ngOnInit() {
        this.#carouselService.carouselIndex$.pipe(takeUntilDestroyed(this.#destroyRef)).subscribe((nextIndex) => {
            this.items = this.#carouselState?.state?.items?.map((item) => item.index) ?? [];
            if ('active' in nextIndex) {
                this.active = nextIndex.active ?? 0;
            }
        });
    }
    onClick(index) {
        if (index !== this.active) {
            const direction = index < this.active ? 'prev' : 'next';
            this.#carouselState.state = { direction, activeItemIndex: index };
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CarouselIndicatorsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.2", type: CarouselIndicatorsComponent, isStandalone: true, selector: "c-carousel-indicators", host: { classAttribute: "carousel-indicators" }, queries: [{ propertyName: "contentTemplates", predicate: TemplateIdDirective, descendants: true, isSignal: true }], exportAs: ["cCarouselIndicators"], ngImport: i0, template: "@let tmpl = templates();\n<ng-container *ngTemplateOutlet=\"tmpl['carouselIndicatorsTemplate'] || defaultCarouselIndicatorsTemplate; context: {$implicit: items, active: active}\" />\n\n<ng-template #defaultCarouselIndicatorsTemplate>\n  @for (item of items; track item; let i = $index) {\n    <button\n      [attr.data-coreui-target]=\"i\"\n      type=\"button\"\n      (click)=\"onClick(i)\"\n      [class]=\"{ active: active === i }\"\n      [attr.aria-current]=\"active === i\">\n    </button>\n  }\n</ng-template>\n", dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CarouselIndicatorsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-carousel-indicators', exportAs: 'cCarouselIndicators', imports: [NgTemplateOutlet], host: { class: 'carousel-indicators' }, template: "@let tmpl = templates();\n<ng-container *ngTemplateOutlet=\"tmpl['carouselIndicatorsTemplate'] || defaultCarouselIndicatorsTemplate; context: {$implicit: items, active: active}\" />\n\n<ng-template #defaultCarouselIndicatorsTemplate>\n  @for (item of items; track item; let i = $index) {\n    <button\n      [attr.data-coreui-target]=\"i\"\n      type=\"button\"\n      (click)=\"onClick(i)\"\n      [class]=\"{ active: active === i }\"\n      [attr.aria-current]=\"active === i\">\n    </button>\n  }\n</ng-template>\n" }]
        }] });

class CarouselItemComponent {
    #destroyRef;
    #carouselService;
    constructor() {
        this.#destroyRef = inject(DestroyRef);
        this.#carouselService = inject(CarouselService);
        /**
         * @ignore
         */
        this.activeInput = input(false, { transform: booleanAttribute, alias: 'active' });
        this.active = linkedSignal({
            source: this.activeInput,
            computation: (value) => {
                return value;
            }
        });
        /**
         * Time delay before cycling to next item. If -1, uses carousel interval value.
         * @return number
         * @default -1
         */
        this.interval = input(-1);
        /**
         * Carousel item role.
         * @return string
         * @default 'group'
         */
        this.role = input('group');
        this.#carouselService.carouselIndex$.pipe(takeUntilDestroyed(this.#destroyRef)).subscribe((nextIndex) => {
            if ('active' in nextIndex) {
                this.active.set(nextIndex.active === this.index);
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CarouselItemComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.2", type: CarouselItemComponent, isStandalone: true, selector: "c-carousel-item", inputs: { activeInput: { classPropertyName: "activeInput", publicName: "active", isSignal: true, isRequired: false, transformFunction: null }, interval: { classPropertyName: "interval", publicName: "interval", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class.active": "active()", "attr.role": "role()" }, classAttribute: "carousel-item" }, exportAs: ["cCarouselItem"], ngImport: i0, template: "@if (active()) {\n  <ng-content />\n}\n", styles: [":host{display:block}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CarouselItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-carousel-item', exportAs: 'cCarouselItem', host: {
                        class: 'carousel-item',
                        '[class.active]': 'active()',
                        '[attr.role]': 'role()'
                    }, template: "@if (active()) {\n  <ng-content />\n}\n", styles: [":host{display:block}\n"] }]
        }], ctorParameters: () => [] });

function toSlideLeft(fromState, toState) {
    return toState.left === true && toState.type === 'slide';
}
function toSlideRight(fromState, toState) {
    return toState.left === false && toState.type === 'slide';
}
function toFadeLeft(fromState, toState) {
    return toState.left === true && toState.type !== 'slide';
}
function toFadeRight(fromState, toState) {
    return toState.left === false && toState.type !== 'slide';
}
const slideAnimationLeft = animation(group([
    query(':leave', [
        animate('0.6s ease-in-out', style({
            transform: 'translateX(-100%)'
        }))
    ], { optional: true }),
    query(':enter', [
        style({
            transform: 'translateX(100%)'
        }),
        animate('0.6s ease-in-out', style('*'))
    ], { optional: true })
]));
const slideAnimationRight = animation(group([
    query(':enter', [
        style({
            transform: 'translateX(-100%)'
        }),
        animate('0.6s ease-in-out', style('*'))
    ], { optional: true }),
    query(':leave', [
        animate('0.6s ease-in-out', style({
            transform: 'translateX(100%)'
        }))
    ], { optional: true })
]));
const fadeAnimationLeft = animation(group([
    query(':leave', [
        animate('0.9s ease-in-out', style({
            zIndex: 0,
            opacity: 0
        }))
    ], { optional: true }),
    query(':enter', [
        style({
            zIndex: 1,
            opacity: 1
        }),
        animate('0.6s ease-in-out', style('*'))
    ], { optional: true })
]));
const fadeAnimationRight = animation(group([
    query(':enter', [
        style({
            zIndex: 1,
            opacity: 1
        }),
        animate('0.6s ease-in-out', style('*'))
    ], { optional: true }),
    query(':leave', [
        animate('0.9s ease-in-out', style({
            zIndex: 0,
            opacity: 0
        }))
    ], { optional: true })
]));
const carouselPlay = trigger('carouselPlay', [
    state('*', style({ transform: 'translateX(0)', display: 'block', opacity: 1 })),
    transition(toFadeLeft, useAnimation(fadeAnimationLeft)),
    transition(toFadeRight, useAnimation(fadeAnimationRight)),
    transition(toSlideLeft, useAnimation(slideAnimationLeft)),
    transition(toSlideRight, useAnimation(slideAnimationRight))
]);

class CarouselInnerComponent {
    constructor() {
        this.#carouselState = inject(CarouselState);
        this.activeIndex = signal(undefined);
        this.animate = signal(true);
        this.interval = signal(0);
        this.slide = signal({ left: true });
        this.transition = signal('crossfade');
        this.slideType = computed(() => {
            return { left: this.slide().left, type: this.transition() };
        });
        this.ariaLive = computed(() => {
            return this.interval() ? 'off' : 'polite';
        });
        this.contentItems = contentChildren(CarouselItemComponent);
        this.#prevContentItems = signal([]);
    }
    #carouselState;
    #prevContentItems;
    ngAfterContentInit() {
        this.setItems();
    }
    ngAfterContentChecked() {
        this.setItems();
        const state = this.#carouselState?.state;
        const nextIndex = state?.activeItemIndex;
        const nextDirection = state?.direction;
        if (this.activeIndex() !== nextIndex) {
            this.animate.set(state?.animate ?? false);
            this.activeIndex.set(state?.activeItemIndex);
            this.interval.set(state?.interval ?? 0);
            this.slide.set({ left: nextDirection === 'next' });
            this.transition.set(state?.transition ?? 'slide');
        }
    }
    setItems() {
        const contentItems = this.contentItems();
        if (this.#prevContentItems() !== contentItems) {
            this.#prevContentItems.set([...contentItems]);
            this.#carouselState.setItems(contentItems);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CarouselInnerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "19.2.2", type: CarouselInnerComponent, isStandalone: true, selector: "c-carousel-inner", host: { properties: { "@carouselPlay": "slideType()", "@.disabled": "!animate()", "attr.aria-live": "ariaLive()" }, classAttribute: "carousel-inner" }, queries: [{ propertyName: "contentItems", predicate: CarouselItemComponent, isSignal: true }], ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"], animations: [carouselPlay] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CarouselInnerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-carousel-inner', animations: [carouselPlay], template: '<ng-content />', host: {
                        class: 'carousel-inner',
                        '[@carouselPlay]': 'slideType()',
                        '[@.disabled]': '!animate()',
                        '[attr.aria-live]': 'ariaLive()'
                    }, styles: [":host{display:block}\n"] }]
        }] });

class CarouselModule {
    static forRoot() {
        return { ngModule: CarouselModule, providers: [] };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CarouselModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: CarouselModule, imports: [CarouselComponent,
            CarouselCaptionComponent,
            CarouselControlComponent,
            CarouselIndicatorsComponent,
            CarouselInnerComponent,
            CarouselItemComponent], exports: [CarouselComponent,
            CarouselCaptionComponent,
            CarouselControlComponent,
            CarouselIndicatorsComponent,
            CarouselInnerComponent,
            CarouselItemComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CarouselModule, providers: [CarouselService, CarouselState, CarouselConfig] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: CarouselModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CarouselComponent,
                        CarouselCaptionComponent,
                        CarouselControlComponent,
                        CarouselIndicatorsComponent,
                        CarouselInnerComponent,
                        CarouselItemComponent
                    ],
                    providers: [CarouselService, CarouselState, CarouselConfig],
                    exports: [
                        CarouselComponent,
                        CarouselCaptionComponent,
                        CarouselControlComponent,
                        CarouselIndicatorsComponent,
                        CarouselInnerComponent,
                        CarouselItemComponent
                    ]
                }]
        }] });

class DropdownDividerDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: DropdownDividerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.2", type: DropdownDividerDirective, isStandalone: true, selector: "[cDropdownDivider]", host: { classAttribute: "dropdown-divider" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: DropdownDividerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cDropdownDivider]',
                    host: { class: 'dropdown-divider' }
                }]
        }] });

class DropdownHeaderDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: DropdownHeaderDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.2", type: DropdownHeaderDirective, isStandalone: true, selector: "[cDropdownHeader]", host: { classAttribute: "dropdown-header" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: DropdownHeaderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cDropdownHeader]',
                    host: { class: 'dropdown-header' }
                }]
        }] });

class DropdownService {
    constructor() {
        this.dropdownState = new BehaviorSubject({});
        this.dropdownState$ = this.dropdownState.asObservable();
    }
    toggle(state) {
        this.dropdownState.next(state);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: DropdownService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: DropdownService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: DropdownService, decorators: [{
            type: Injectable
        }] });

class DropdownMenuDirective {
    constructor() {
        this.#destroyRef = inject(DestroyRef);
        this.elementRef = inject(ElementRef);
        this.#dropdownService = inject(DropdownService);
        /**
         * Set alignment of dropdown menu.
         * @return 'start' | 'end'
         */
        this.alignment = input();
        /**
         * Toggle the visibility of dropdown menu component.
         * @return boolean
         */
        this.visibleInput = input(false, { transform: booleanAttribute, alias: 'visible' });
        this.visible = linkedSignal({
            source: this.visibleInput,
            computation: (value) => value
        });
        this.hostClasses = computed(() => {
            const alignment = this.alignment();
            const visible = this.visible();
            return {
                'dropdown-menu': true,
                [`dropdown-menu-${alignment}`]: !!alignment,
                show: visible
            };
        });
        this.hostStyles = computed(() => {
            // workaround for popper position calculate (see also: dropdown.component)
            const visible = this.visible();
            return {
                visibility: visible ? null : '',
                display: visible ? null : ''
            };
        });
    }
    #destroyRef;
    #dropdownService;
    #focusKeyManager;
    onKeyDown($event) {
        if (!this.visible()) {
            return;
        }
        if (['Space', 'ArrowDown'].includes($event.code)) {
            $event.preventDefault();
        }
        this.#focusKeyManager.onKeydown($event);
    }
    onKeyUp($event) {
        if (!this.visible()) {
            return;
        }
        if (['Tab'].includes($event.key)) {
            if (this.#focusKeyManager.activeItem) {
                $event.shiftKey ? this.#focusKeyManager.setPreviousItemActive() : this.#focusKeyManager.setNextItemActive();
            }
            else {
                this.#focusKeyManager.setFirstItemActive();
            }
        }
    }
    ngAfterContentInit() {
        this.focusKeyManagerInit();
        this.dropdownItemsContent.changes
            .pipe(tap((change) => {
            this.focusKeyManagerInit();
        }), takeUntilDestroyed(this.#destroyRef))
            .subscribe();
    }
    ngOnInit() {
        this.#dropdownService.dropdownState$
            .pipe(tap((state) => {
            if ('visible' in state) {
                this.visible.update((visible) => (state.visible === 'toggle' ? !visible : state.visible));
                if (!this.visible()) {
                    this.#focusKeyManager?.setActiveItem(-1);
                }
            }
        }), takeUntilDestroyed(this.#destroyRef))
            .subscribe();
    }
    focusKeyManagerInit() {
        this.#focusKeyManager = new FocusKeyManager(this.dropdownItemsContent)
            .withHomeAndEnd()
            .withPageUpDown()
            .withWrap()
            .skipPredicate((dropdownItem) => dropdownItem.disabled === true);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: DropdownMenuDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: DropdownMenuDirective, isStandalone: true, selector: "[cDropdownMenu]", inputs: { alignment: { classPropertyName: "alignment", publicName: "alignment", isSignal: true, isRequired: false, transformFunction: null }, visibleInput: { classPropertyName: "visibleInput", publicName: "visible", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "keydown": "onKeyDown($event)", "keyup": "onKeyUp($event)" }, properties: { "class": "hostClasses()", "style": "hostStyles()" }, classAttribute: "dropdown-menu" }, queries: [{ propertyName: "dropdownItemsContent", predicate: i0.forwardRef(() => DropdownItemDirective), descendants: true }], exportAs: ["cDropdownMenu"], hostDirectives: [{ directive: ThemeDirective, inputs: ["dark", "dark"] }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: DropdownMenuDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cDropdownMenu]',
                    exportAs: 'cDropdownMenu',
                    hostDirectives: [{ directive: ThemeDirective, inputs: ['dark'] }],
                    host: {
                        class: 'dropdown-menu',
                        '[class]': 'hostClasses()',
                        '[style]': 'hostStyles()',
                        '(keydown)': 'onKeyDown($event)',
                        '(keyup)': 'onKeyUp($event)'
                    }
                }]
        }], propDecorators: { dropdownItemsContent: [{
                type: ContentChildren,
                args: [forwardRef(() => DropdownItemDirective), { descendants: true }]
            }] } });

// lightweight injection token
class DropdownToken {
}
class DropdownToggleDirective {
    constructor() {
        // injections
        this.#destroyRef = inject(DestroyRef);
        this.elementRef = inject(ElementRef);
        this.#dropdownService = inject(DropdownService);
        this.dropdown = inject(DropdownToken, { optional: true });
        /**
         * Reference to dropdown component.
         * @return DropdownComponent | undefined
         * @default undefined
         */
        this.dropdownComponent = input();
        /**
         * Disables the toggler.
         * @return boolean
         * @default false
         */
        this.disabled = input(false, { transform: booleanAttribute });
        /**
         * Enables pseudo element caret on toggler.
         * @return boolean
         */
        this.caret = input(true);
        /**
         * Create split button dropdowns with virtually the same markup as single button dropdowns,
         * but with the addition of `.dropdown-toggle-split` class for proper spacing around the dropdown caret.
         * @return boolean
         * @default false
         */
        this.split = input(false, { transform: booleanAttribute });
        this.hostClasses = computed(() => {
            return {
                'dropdown-toggle': this.caret(),
                'dropdown-toggle-split': this.split(),
                disabled: this.disabled()
            };
        });
        this.#ariaExpanded = signal(false);
    }
    // injections
    #destroyRef;
    #dropdownService;
    #ariaExpanded;
    get ariaExpanded() {
        return this.#ariaExpanded();
    }
    onClick($event) {
        $event.preventDefault();
        !this.disabled() && this.#dropdownService.toggle({ visible: 'toggle', dropdown: this.dropdown });
    }
    ngAfterViewInit() {
        const dropdownComponent = this.dropdownComponent();
        if (dropdownComponent) {
            this.dropdown = dropdownComponent;
            this.#dropdownService = dropdownComponent?.dropdownService;
        }
        if (this.dropdown) {
            const dropdown = this.dropdown;
            dropdown?.visibleChange?.subscribe((visible) => {
                this.#ariaExpanded.set(visible);
            });
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: DropdownToggleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: DropdownToggleDirective, isStandalone: true, selector: "[cDropdownToggle]", inputs: { dropdownComponent: { classPropertyName: "dropdownComponent", publicName: "dropdownComponent", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null }, caret: { classPropertyName: "caret", publicName: "caret", isSignal: true, isRequired: false, transformFunction: null }, split: { classPropertyName: "split", publicName: "split", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "onClick($event)" }, properties: { "class": "hostClasses()", "attr.aria-expanded": "ariaExpanded" } }, providers: [{ provide: DropdownToken, useExisting: forwardRef(() => DropdownComponent) }], exportAs: ["cDropdownToggle"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: DropdownToggleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cDropdownToggle]',
                    providers: [{ provide: DropdownToken, useExisting: forwardRef(() => DropdownComponent) }],
                    exportAs: 'cDropdownToggle',
                    host: {
                        '[class]': 'hostClasses()',
                        '[attr.aria-expanded]': 'ariaExpanded',
                        '(click)': 'onClick($event)'
                    }
                }]
        }] });
class DropdownComponent {
    constructor(document, elementRef, renderer, ngZone, changeDetectorRef, dropdownService) {
        this.document = document;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.changeDetectorRef = changeDetectorRef;
        this.dropdownService = dropdownService;
        /**
         * Set alignment of dropdown menu.
         * @return {'start' | 'end' | { xs: 'start' | 'end' } | { sm: 'start' | 'end' } | { md: 'start' | 'end' } | { lg: 'start' | 'end' } | { xl: 'start' | 'end'} | { xxl: 'start' | 'end'}}
         */
        this.alignment = input();
        /**
         * Automatically close dropdown when clicking outside the dropdown menu.
         */
        this.autoClose = input(true);
        /**
         * Sets a specified  direction and location of the dropdown menu.
         * @return 'dropup' | 'dropend' | 'dropstart'
         */
        this.direction = input();
        /**
         * Describes the placement of your component after Popper.js has applied all the modifiers
         * that may have flipped or altered the originally provided placement property.
         * @return Placement
         */
        this.placement = input('bottom-start');
        /**
         * If you want to disable dynamic positioning set this property to `false`.
         * @return boolean
         * @default true
         */
        this.popper = input(true, { transform: booleanAttribute });
        /**
         * Optional popper Options object, placement prop takes precedence over
         * @return Partial<Options>
         */
        this.popperOptionsInput = input({}, { alias: 'popperOptions' });
        this.popperOptionsEffect = effect(() => {
            this.popperOptions = { ...untracked(this.#popperOptions), ...this.popperOptionsInput() };
        });
        this.#popperOptions = signal({
            placement: this.placement(),
            modifiers: [],
            strategy: 'absolute'
        });
        /**
         * Set the dropdown variant to a btn-group, dropdown, input-group, and nav-item.
         */
        this.variant = input('dropdown');
        /**
         * Toggle the visibility of dropdown menu component.
         * @return boolean
         * @default false
         */
        this.visibleInput = input(false, { transform: booleanAttribute, alias: 'visible' });
        this.visible = linkedSignal({
            source: this.visibleInput,
            computation: (value) => value
        });
        this.visibleEffect = effect(() => {
            const visible = this.visible();
            this.activeTrap = visible;
            visible ? this.createPopperInstance() : this.destroyPopperInstance();
            this.setVisibleState(visible);
            this.visibleChange.emit(visible);
        });
        this.visibleChange = output();
        this.dropdownContext = { $implicit: this.visible() };
        this.activeTrap = false;
        this.listeners = [];
        this.hostClasses = computed(() => {
            const direction = this.direction();
            const variant = this.variant();
            return {
                dropdown: (variant === 'dropdown' || variant === 'nav-item') && !direction,
                [`${direction}`]: !!direction,
                [`${variant}`]: !!variant,
                dropup: direction === 'dropup' || direction === 'dropup-center',
                show: this.visible()
            };
        });
        // todo: find better solution
        this.hostStyle = computed(() => {
            return this.variant() === 'input-group' ? { display: 'contents' } : {};
        });
        this.dropdownStateSubscribe();
    }
    set popperOptions(value) {
        this.#popperOptions.update((popperOptions) => ({ ...popperOptions, ...value }));
    }
    get popperOptions() {
        let placement = this.placement();
        switch (this.direction()) {
            case 'dropup': {
                placement = 'top-start';
                break;
            }
            case 'dropend': {
                placement = 'right-start';
                break;
            }
            case 'dropstart': {
                placement = 'left-start';
                break;
            }
            case 'center': {
                placement = 'bottom';
                break;
            }
            case 'dropup-center': {
                placement = 'top';
                break;
            }
        }
        if (this.alignment() === 'end') {
            placement = 'bottom-end';
        }
        this.#popperOptions.update((value) => ({ ...value, placement: placement }));
        return this.#popperOptions();
    }
    #popperOptions;
    onHostClick($event) {
        this.clickedTarget = $event.target;
    }
    dropdownStateSubscribe(subscribe = true) {
        if (subscribe) {
            this.dropdownStateSubscription = this.dropdownService.dropdownState$
                .pipe(filter((state) => {
                return this === state.dropdown;
            }))
                .subscribe((state) => {
                if ('visible' in state) {
                    state?.visible === 'toggle' ? this.toggleDropdown() : this.visible.set(state.visible);
                }
            });
        }
        else {
            this.dropdownStateSubscription?.unsubscribe();
        }
    }
    toggleDropdown() {
        this.visible.update((visible) => !visible);
    }
    onClick(event) {
        if (!this._toggler?.elementRef.nativeElement.contains(event.target?.closest('[cDropdownToggle]'))) {
            this.toggleDropdown();
        }
    }
    ngAfterContentInit() {
        if (this.variant() === 'nav-item') {
            this.renderer.addClass(this._toggler.elementRef.nativeElement, 'nav-link');
        }
    }
    ngOnInit() {
        this.setVisibleState(this.visible());
    }
    ngOnDestroy() {
        this.clearListeners();
        this.dropdownStateSubscribe(false);
        this.destroyPopperInstance();
    }
    setVisibleState(value) {
        this.dropdownService.toggle({ visible: value, dropdown: this });
    }
    // todo: turn off popper in navbar-nav
    createPopperInstance() {
        if (this._toggler && this._menu) {
            this.ngZone.runOutsideAngular(() => {
                // workaround for popper position calculate (see also: dropdown-menu.component)
                this._menu.elementRef.nativeElement.style.visibility = 'hidden';
                this._menu.elementRef.nativeElement.style.display = 'block';
                if (this.popper()) {
                    this.popperInstance = createPopper(this._toggler.elementRef.nativeElement, this._menu.elementRef.nativeElement, { ...this.popperOptions });
                }
                this.ngZone.run(() => {
                    this.setListeners();
                    this.changeDetectorRef.markForCheck();
                    this.changeDetectorRef.detectChanges();
                });
            });
        }
    }
    destroyPopperInstance() {
        this.clearListeners();
        this.popperInstance?.destroy();
        this.popperInstance = undefined;
        this.changeDetectorRef.markForCheck();
    }
    setListeners() {
        this.listeners.push(this.renderer.listen(this.document, 'click', (event) => {
            const target = event.target;
            if (this._menuElementRef?.nativeElement.contains(event.target)) {
                this.clickedTarget = target;
            }
            if (this._toggler?.elementRef.nativeElement.contains(event.target)) {
                return;
            }
            const autoClose = this.autoClose();
            if (autoClose === true) {
                this.setVisibleState(false);
                return;
            }
            if (this.clickedTarget === target && autoClose === 'inside') {
                this.setVisibleState(false);
                return;
            }
            if (this.clickedTarget !== target && autoClose === 'outside') {
                this.setVisibleState(false);
                return;
            }
        }));
        this.listeners.push(this.renderer.listen(this.elementRef.nativeElement, 'keyup', (event) => {
            if (event.key === 'Escape' && this.autoClose() !== false) {
                event.stopPropagation();
                this.setVisibleState(false);
                return;
            }
        }));
        this.listeners.push(this.renderer.listen(this.document, 'keyup', (event) => {
            if (event.key === 'Tab' &&
                this.autoClose() !== false &&
                !this.elementRef.nativeElement.contains(event.target)) {
                this.setVisibleState(false);
                return;
            }
        }));
    }
    clearListeners() {
        this.listeners.forEach((unListen) => {
            unListen();
        });
        // @ts-ignore
        this.listeners.fill(undefined);
        this.listeners = [];
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: DropdownComponent, deps: [{ token: DOCUMENT }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }, { token: DropdownService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: DropdownComponent, isStandalone: true, selector: "c-dropdown", inputs: { alignment: { classPropertyName: "alignment", publicName: "alignment", isSignal: true, isRequired: false, transformFunction: null }, autoClose: { classPropertyName: "autoClose", publicName: "autoClose", isSignal: true, isRequired: false, transformFunction: null }, direction: { classPropertyName: "direction", publicName: "direction", isSignal: true, isRequired: false, transformFunction: null }, placement: { classPropertyName: "placement", publicName: "placement", isSignal: true, isRequired: false, transformFunction: null }, popper: { classPropertyName: "popper", publicName: "popper", isSignal: true, isRequired: false, transformFunction: null }, popperOptionsInput: { classPropertyName: "popperOptionsInput", publicName: "popperOptions", isSignal: true, isRequired: false, transformFunction: null }, variant: { classPropertyName: "variant", publicName: "variant", isSignal: true, isRequired: false, transformFunction: null }, visibleInput: { classPropertyName: "visibleInput", publicName: "visible", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { visibleChange: "visibleChange" }, host: { listeners: { "click": "onHostClick($event)" }, properties: { "class": "hostClasses()", "style": "hostStyle()" } }, providers: [DropdownService], queries: [{ propertyName: "_toggler", first: true, predicate: DropdownToggleDirective, descendants: true }, { propertyName: "_menu", first: true, predicate: DropdownMenuDirective, descendants: true }, { propertyName: "_menuElementRef", first: true, predicate: DropdownMenuDirective, descendants: true, read: ElementRef }], exportAs: ["cDropdown"], hostDirectives: [{ directive: ThemeDirective, inputs: ["dark", "dark"] }], ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host-context(.dropdown,.dropup):not(.btn-group){display:block}:host-context(.dropstart,.dropend):not(.btn-group){display:inline-flex}:host-context(html:not([dir=rtl])) :host-context(.input-group) :host:first-child::ng-deep :first-child{border-top-right-radius:0;border-bottom-right-radius:0}:host-context(html:not([dir=rtl])) :host-context(.input-group) :host:first-child::ng-deep :not(:first-child):not(.dropdown-menu){margin-left:-1px;border-top-left-radius:0;border-bottom-left-radius:0}:host-context(html:not([dir=rtl])) :host-context(.input-group) :host:first-child::ng-deep :not(:first-child):not(.dropdown-menu):not(:only-of-type){border-top-right-radius:0;border-bottom-right-radius:0}:host-context(html:not([dir=rtl])) :host-context(.input-group) :host:last-child::ng-deep :first-child{border-top-left-radius:0;border-bottom-left-radius:0}:host-context(html:not([dir=rtl])) :host-context(.input-group) :host:last-child::ng-deep :first-child:not(:only-of-type){border-top-right-radius:0;border-bottom-right-radius:0}:host-context(html:not([dir=rtl])) :host-context(.input-group) :host:last-child::ng-deep :not(:first-child):not(.dropdown-menu){margin-left:-1px;border-top-left-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl] .input-group) :host{direction:rtl}:host-context([dir=rtl] .input-group) :host:first-child::ng-deep :first-child{border-top-left-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl] .input-group) :host:first-child::ng-deep :not(:first-child):not(.dropdown-menu){margin-right:-1px;border-top-right-radius:0;border-bottom-right-radius:0}:host-context([dir=rtl] .input-group) :host:first-child::ng-deep :not(:first-child):not(.dropdown-menu):not(:only-of-type){border-top-left-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl] .input-group) :host:last-child::ng-deep :first-child{border-top-right-radius:0;border-bottom-right-radius:0}:host-context([dir=rtl] .input-group) :host:last-child::ng-deep :first-child:not(:only-of-type){border-top-left-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl] .input-group) :host:last-child::ng-deep :not(:first-child):not(.dropdown-menu){margin-right:-1px;border-top-right-radius:0;border-bottom-right-radius:0}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: DropdownComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-dropdown', template: '<ng-content />', exportAs: 'cDropdown', providers: [DropdownService], hostDirectives: [{ directive: ThemeDirective, inputs: ['dark'] }], host: {
                        '[class]': 'hostClasses()',
                        '[style]': 'hostStyle()',
                        '(click)': 'onHostClick($event)'
                    }, styles: [":host-context(.dropdown,.dropup):not(.btn-group){display:block}:host-context(.dropstart,.dropend):not(.btn-group){display:inline-flex}:host-context(html:not([dir=rtl])) :host-context(.input-group) :host:first-child::ng-deep :first-child{border-top-right-radius:0;border-bottom-right-radius:0}:host-context(html:not([dir=rtl])) :host-context(.input-group) :host:first-child::ng-deep :not(:first-child):not(.dropdown-menu){margin-left:-1px;border-top-left-radius:0;border-bottom-left-radius:0}:host-context(html:not([dir=rtl])) :host-context(.input-group) :host:first-child::ng-deep :not(:first-child):not(.dropdown-menu):not(:only-of-type){border-top-right-radius:0;border-bottom-right-radius:0}:host-context(html:not([dir=rtl])) :host-context(.input-group) :host:last-child::ng-deep :first-child{border-top-left-radius:0;border-bottom-left-radius:0}:host-context(html:not([dir=rtl])) :host-context(.input-group) :host:last-child::ng-deep :first-child:not(:only-of-type){border-top-right-radius:0;border-bottom-right-radius:0}:host-context(html:not([dir=rtl])) :host-context(.input-group) :host:last-child::ng-deep :not(:first-child):not(.dropdown-menu){margin-left:-1px;border-top-left-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl] .input-group) :host{direction:rtl}:host-context([dir=rtl] .input-group) :host:first-child::ng-deep :first-child{border-top-left-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl] .input-group) :host:first-child::ng-deep :not(:first-child):not(.dropdown-menu){margin-right:-1px;border-top-right-radius:0;border-bottom-right-radius:0}:host-context([dir=rtl] .input-group) :host:first-child::ng-deep :not(:first-child):not(.dropdown-menu):not(:only-of-type){border-top-left-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl] .input-group) :host:last-child::ng-deep :first-child{border-top-right-radius:0;border-bottom-right-radius:0}:host-context([dir=rtl] .input-group) :host:last-child::ng-deep :first-child:not(:only-of-type){border-top-left-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl] .input-group) :host:last-child::ng-deep :not(:first-child):not(.dropdown-menu){margin-right:-1px;border-top-right-radius:0;border-bottom-right-radius:0}\n"] }]
        }], ctorParameters: () => [{ type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: DropdownService }], propDecorators: { _toggler: [{
                type: ContentChild,
                args: [DropdownToggleDirective]
            }], _menu: [{
                type: ContentChild,
                args: [DropdownMenuDirective]
            }], _menuElementRef: [{
                type: ContentChild,
                args: [DropdownMenuDirective, { read: ElementRef }]
            }] } });

class DropdownItemDirective {
    constructor() {
        this.#elementRef = inject(ElementRef);
        this.#dropdownService = inject(DropdownService);
        this.dropdown = inject(DropdownComponent, { optional: true });
        /**
         * Set active state to a dropdown-item.
         * @return boolean
         * @default undefined
         */
        this.active = input();
        /**
         * Configure dropdown-item close dropdown behavior.
         * @return boolean
         * @default true
         */
        this.autoClose = input(true);
        /**
         * Disables a dropdown-item.
         * @return boolean
         * @default undefined
         */
        this.disabledInput = input(false, { transform: booleanAttribute, alias: 'disabled' });
        this.disabledEffect = linkedSignal({
            source: this.disabledInput,
            computation: (value) => value
        });
        this.ariaCurrent = computed(() => {
            return this.active() ? 'true' : null;
        });
        this.hostClasses = computed(() => {
            return {
                'dropdown-item': true,
                active: this.active(),
                disabled: this.disabled
            };
        });
        this.tabIndexInput = input(null, { alias: 'tabIndex' });
        this.tabIndex = linkedSignal({
            source: this.tabIndexInput,
            computation: (value) => (this.disabled ? '-1' : value)
        });
    }
    #elementRef;
    #dropdownService;
    set disabled(value) {
        this.disabledEffect.set(value);
    }
    get disabled() {
        return this.disabledEffect();
    }
    focus(origin) {
        this.#elementRef?.nativeElement?.focus();
    }
    getLabel() {
        return this.#elementRef?.nativeElement?.textContent.trim();
    }
    onClick($event) {
        this.handleInteraction();
    }
    onKeyUp($event) {
        if ($event.key === 'Enter') {
            this.handleInteraction();
        }
    }
    handleInteraction() {
        if (this.autoClose()) {
            this.#dropdownService.toggle({ visible: 'toggle', dropdown: this.dropdown });
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: DropdownItemDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: DropdownItemDirective, isStandalone: true, selector: "[cDropdownItem]", inputs: { active: { classPropertyName: "active", publicName: "active", isSignal: true, isRequired: false, transformFunction: null }, autoClose: { classPropertyName: "autoClose", publicName: "autoClose", isSignal: true, isRequired: false, transformFunction: null }, disabledInput: { classPropertyName: "disabledInput", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null }, tabIndexInput: { classPropertyName: "tabIndexInput", publicName: "tabIndex", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "onClick($event)", "keyup": "onKeyUp($event)" }, properties: { "class": "hostClasses()", "attr.tabindex": "tabIndex()", "attr.aria-current": "ariaCurrent()", "attr.aria-disabled": "disabled || null" }, classAttribute: "dropdown-item" }, exportAs: ["cDropdownItem"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: DropdownItemDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cDropdownItem]',
                    exportAs: 'cDropdownItem',
                    host: {
                        class: 'dropdown-item',
                        '[class]': 'hostClasses()',
                        '[attr.tabindex]': 'tabIndex()',
                        '[attr.aria-current]': 'ariaCurrent()',
                        '[attr.aria-disabled]': 'disabled || null',
                        '(click)': 'onClick($event)',
                        '(keyup)': 'onKeyUp($event)'
                    }
                }]
        }] });

class DropdownItemPlainDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: DropdownItemPlainDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.2", type: DropdownItemPlainDirective, isStandalone: true, selector: "[cDropdownItemPlain]", host: { classAttribute: "dropdown-item-text" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: DropdownItemPlainDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cDropdownItemPlain]',
                    host: { class: 'dropdown-item-text' }
                }]
        }] });

class DropdownCloseDirective {
    constructor() {
        this.#dropdownService = inject(DropdownService);
        this.dropdown = inject(DropdownComponent, { optional: true });
        /**
         * Disables a dropdown-close directive.
         * @return boolean
         * @default false
         */
        this.disabledInput = input(false, { transform: booleanAttribute, alias: 'disabled' });
        this.disabled = linkedSignal({
            source: this.disabledInput,
            computation: (value) => value || null
        });
        this.dropdownComponent = input();
        this.tabIndexInput = input(null, { alias: 'tabIndex' });
        this.tabIndex = linkedSignal({
            source: this.tabIndexInput,
            computation: (value) => (this.disabled() ? '-1' : value)
        });
    }
    #dropdownService;
    ngAfterViewInit() {
        const dropdownComponent = this.dropdownComponent();
        if (dropdownComponent) {
            this.dropdown = dropdownComponent;
            this.#dropdownService = dropdownComponent?.dropdownService;
        }
    }
    onClick($event) {
        this.handleToggle();
    }
    onKeyUp($event) {
        if ($event.key === 'Enter') {
            this.handleToggle();
        }
    }
    handleToggle() {
        if (!this.disabled()) {
            this.#dropdownService.toggle({ visible: false, dropdown: this.dropdown });
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: DropdownCloseDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: DropdownCloseDirective, isStandalone: true, selector: "[cDropdownClose]", inputs: { disabledInput: { classPropertyName: "disabledInput", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null }, dropdownComponent: { classPropertyName: "dropdownComponent", publicName: "dropdownComponent", isSignal: true, isRequired: false, transformFunction: null }, tabIndexInput: { classPropertyName: "tabIndexInput", publicName: "tabIndex", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "onClick($event)", "keyup": "onKeyUp($event)" }, properties: { "class.disabled": "disabled()", "attr.aria-disabled": "disabled() || null", "attr.tabindex": "tabIndex()" } }, exportAs: ["cDropdownClose"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: DropdownCloseDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cDropdownClose]',
                    exportAs: 'cDropdownClose',
                    host: {
                        '[class.disabled]': 'disabled()',
                        '[attr.aria-disabled]': 'disabled() || null',
                        '[attr.tabindex]': 'tabIndex()',
                        '(click)': 'onClick($event)',
                        '(keyup)': 'onKeyUp($event)'
                    }
                }]
        }] });

class DropdownModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: DropdownModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: DropdownModule, imports: [DropdownComponent,
            DropdownCloseDirective,
            DropdownDividerDirective,
            DropdownHeaderDirective,
            DropdownItemDirective,
            DropdownItemPlainDirective,
            DropdownMenuDirective,
            DropdownToggleDirective], exports: [DropdownComponent,
            DropdownCloseDirective,
            DropdownDividerDirective,
            DropdownHeaderDirective,
            DropdownItemDirective,
            DropdownItemPlainDirective,
            DropdownMenuDirective,
            DropdownToggleDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: DropdownModule, providers: [DropdownService] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: DropdownModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        DropdownComponent,
                        DropdownCloseDirective,
                        DropdownDividerDirective,
                        DropdownHeaderDirective,
                        DropdownItemDirective,
                        DropdownItemPlainDirective,
                        DropdownMenuDirective,
                        DropdownToggleDirective
                    ],
                    exports: [
                        DropdownComponent,
                        DropdownCloseDirective,
                        DropdownDividerDirective,
                        DropdownHeaderDirective,
                        DropdownItemDirective,
                        DropdownItemPlainDirective,
                        DropdownMenuDirective,
                        DropdownToggleDirective
                    ],
                    providers: [DropdownService]
                }]
        }] });

class FooterComponent {
    constructor() {
        /**
         * Place footer in non-static positions. [docs]
         * @type Positions
         */
        this.position = input();
        /**
         * Default role for footer. [docs]
         * @type string
         * @default 'contentinfo'
         */
        this.role = input('contentinfo');
        this.hostClasses = computed(() => {
            return {
                footer: true,
                [`footer-${this.position()}`]: !!this.position()
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FooterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: FooterComponent, isStandalone: true, selector: "c-footer, [cFooter]", inputs: { position: { classPropertyName: "position", publicName: "position", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.role": "role()" }, classAttribute: "footer" }, ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FooterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-footer, [cFooter]',
                    template: '<ng-content />',
                    host: {
                        class: 'footer',
                        '[class]': 'hostClasses()',
                        '[attr.role]': 'role()'
                    }
                }]
        }] });

class FooterModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FooterModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: FooterModule, imports: [FooterComponent], exports: [FooterComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FooterModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FooterModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [FooterComponent],
                    exports: [FooterComponent]
                }]
        }] });

class FormDirective {
    constructor() {
        /**
         * Mark a form as validated. If you set it `true`, all validation styles will be applied to the form. [docs]
         * @return boolean
         * @default false
         */
        this.validated = input(false, { transform: booleanAttribute });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FormDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: FormDirective, isStandalone: true, selector: "form[cForm]", inputs: { validated: { classPropertyName: "validated", publicName: "validated", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class.was-validated": "validated()" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FormDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'form[cForm]',
                    host: { '[class.was-validated]': 'validated()' }
                }]
        }] });

class FormFeedbackComponent {
    constructor() {
        /**
         * If your form layout allows it, you can display validation feedback in a styled tooltip.
         * @default false
         */
        this.tooltip = input(false, { transform: booleanAttribute });
        /**
         * Set component validation state to valid.
         * @default undefined
         */
        this.valid = input();
        this.hostClasses = computed(() => {
            const status = this.valid() === true ? 'valid' : 'invalid';
            const type = this.tooltip() ? 'tooltip' : 'feedback';
            return {
                [`${status}-${type}`]: true
                // 'valid-feedback': valid === true && !tooltip,
                // 'valid-tooltip': valid === true && tooltip,
                // 'invalid-feedback': valid !== true && !tooltip,
                // 'invalid-tooltip': valid !== true && tooltip
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FormFeedbackComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: FormFeedbackComponent, isStandalone: true, selector: "c-form-feedback", inputs: { tooltip: { classPropertyName: "tooltip", publicName: "tooltip", isSignal: true, isRequired: false, transformFunction: null }, valid: { classPropertyName: "valid", publicName: "valid", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FormFeedbackComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-form-feedback',
                    template: '<ng-content />',
                    host: { '[class]': 'hostClasses()' }
                }]
        }] });

class InputGroupComponent {
    constructor() {
        /**
         * Size the component small or large.
         */
        this.sizing = input();
        this.hostClasses = computed(() => {
            const sizing = this.sizing();
            return {
                'input-group': true,
                [`input-group-${sizing}`]: !!sizing
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: InputGroupComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: InputGroupComponent, isStandalone: true, selector: "c-input-group", inputs: { sizing: { classPropertyName: "sizing", publicName: "sizing", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "input-group" }, ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: InputGroupComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-input-group',
                    template: '<ng-content />',
                    host: { class: 'input-group', '[class]': 'hostClasses()' }
                }]
        }] });

class FormSelectDirective {
    constructor() {
        /**
         * Size the component small or large.
         * @default undefined
         */
        this.sizing = input();
        /**
         * Set component validation state to valid.
         * @default undefined
         */
        this.valid = input();
        this.hostClasses = computed(() => {
            const sizing = this.sizing();
            const valid = this.valid();
            return {
                'form-select': true,
                [`form-select-${sizing}`]: !!sizing,
                'is-valid': valid === true,
                'is-invalid': valid === false
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FormSelectDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: FormSelectDirective, isStandalone: true, selector: "select[cSelect]", inputs: { sizing: { classPropertyName: "sizing", publicName: "sizing", isSignal: true, isRequired: false, transformFunction: null }, valid: { classPropertyName: "valid", publicName: "valid", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "form-select" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FormSelectDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'select[cSelect]',
                    host: { class: 'form-select', '[class]': 'hostClasses()' }
                }]
        }] });

class FormLabelDirective {
    constructor() {
        /**
         * For horizontal forms set labels to 'col' and make them vertically centered with their associated form controls.
         * @default ''
         */
        this.col = input('', { alias: 'cLabel' });
        /**
         * Size the label small or large.
         * @default ''
         */
        this.sizing = input();
        this.hostClasses = computed(() => {
            const col = this.col();
            const sizing = this.sizing();
            return {
                'form-label': true,
                'col-form-label': col === 'col',
                [`col-form-label-${sizing}`]: !!sizing && col === 'col'
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FormLabelDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: FormLabelDirective, isStandalone: true, selector: "[cLabel]", inputs: { col: { classPropertyName: "col", publicName: "cLabel", isSignal: true, isRequired: false, transformFunction: null }, sizing: { classPropertyName: "sizing", publicName: "sizing", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "form-label" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FormLabelDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cLabel]',
                    host: { class: 'form-label', '[class]': 'hostClasses()' }
                }]
        }] });

class FormCheckLabelDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FormCheckLabelDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.2", type: FormCheckLabelDirective, isStandalone: true, selector: "label[cFormCheckLabel]", host: { classAttribute: "form-check-label" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FormCheckLabelDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'label[cFormCheckLabel]',
                    host: { class: 'form-check-label' }
                }]
        }] });

class FormCheckComponent {
    constructor() {
        /**
         * Group checkboxes or radios on the same horizontal row.
         * @default false
         */
        this.inline = input(false, { transform: booleanAttribute });
        /**
         * Put checkboxes or radios on the opposite side.
         * @default false
         * @since 4.4.7
         */
        this.reverse = input(false, { transform: booleanAttribute });
        /**
         * Size the component large or extra large. Works only with `[switch]="true"` [docs]
         * @default undefined
         */
        this.sizing = input();
        /**
         * Render a toggle switch on for checkbox.
         * @type boolean
         * @default false
         */
        this.switch = input(false, { transform: booleanAttribute });
        this.formCheckLabel = contentChild(FormCheckLabelDirective);
        this.formCheckClass = computed(() => !!this.formCheckLabel());
        this.hostClasses = computed(() => {
            const sizing = this.sizing();
            const isSwitch = this.switch();
            return {
                'form-check': !!this.formCheckLabel(),
                'form-switch': isSwitch,
                [`form-switch-${sizing}`]: isSwitch && !!sizing,
                'form-check-inline': this.inline(),
                'form-check-reverse': this.reverse()
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FormCheckComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "19.2.2", type: FormCheckComponent, isStandalone: true, selector: "c-form-check", inputs: { inline: { classPropertyName: "inline", publicName: "inline", isSignal: true, isRequired: false, transformFunction: null }, reverse: { classPropertyName: "reverse", publicName: "reverse", isSignal: true, isRequired: false, transformFunction: null }, sizing: { classPropertyName: "sizing", publicName: "sizing", isSignal: true, isRequired: false, transformFunction: null }, switch: { classPropertyName: "switch", publicName: "switch", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, queries: [{ propertyName: "formCheckLabel", first: true, predicate: FormCheckLabelDirective, descendants: true, isSignal: true }], exportAs: ["cFormCheck"], ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FormCheckComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-form-check',
                    template: '<ng-content />',
                    exportAs: 'cFormCheck',
                    host: { '[class]': 'hostClasses()' }
                }]
        }] });

class FormCheckInputDirective {
    constructor() {
        this.#renderer = inject(Renderer2);
        this.#hostElement = inject(ElementRef);
        /**
         * Specifies the type of component.
         * @default 'checkbox'
         */
        this.type = input('checkbox');
        /**
         * Set component indeterminate state.
         * @default false
         */
        this.indeterminateInput = input(false, { transform: booleanAttribute, alias: 'indeterminate' });
        this.#indeterminateEffect = effect(() => {
            const indeterminate = this.indeterminateInput();
            if (untracked(this.#indeterminate) !== indeterminate) {
                const htmlInputElement = this.#hostElement.nativeElement;
                if (indeterminate) {
                    this.#renderer.setProperty(htmlInputElement, 'checked', false);
                }
                this.#renderer.setProperty(htmlInputElement, 'indeterminate', indeterminate);
                this.#indeterminate.set(indeterminate);
            }
        });
        this.#indeterminate = signal(false);
        /**
         * Set component validation state to valid.
         * @default undefined
         */
        this.valid = input();
        this.hostClasses = computed(() => {
            const valid = this.valid();
            return {
                'form-check-input': true,
                'is-valid': valid === true,
                'is-invalid': valid === false
            };
        });
        /**
         * Set component checked state.
         * @default false
         */
        this.checkedInput = input(false, { transform: booleanAttribute, alias: 'checked' });
        this.#checkedEffect = effect(() => {
            const checked = this.checkedInput();
            const htmlInputElement = this.#hostElement?.nativeElement;
            if (htmlInputElement) {
                this.#renderer.setProperty(htmlInputElement, 'checked', checked);
            }
        });
    }
    #renderer;
    #hostElement;
    #indeterminateEffect;
    get indeterminate() {
        return this.#indeterminate();
    }
    #indeterminate;
    #checkedEffect;
    get checked() {
        return this.#hostElement?.nativeElement?.checked;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FormCheckInputDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: FormCheckInputDirective, isStandalone: true, selector: "input[cFormCheckInput]", inputs: { type: { classPropertyName: "type", publicName: "type", isSignal: true, isRequired: false, transformFunction: null }, indeterminateInput: { classPropertyName: "indeterminateInput", publicName: "indeterminate", isSignal: true, isRequired: false, transformFunction: null }, valid: { classPropertyName: "valid", publicName: "valid", isSignal: true, isRequired: false, transformFunction: null }, checkedInput: { classPropertyName: "checkedInput", publicName: "checked", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.type": "type()" }, classAttribute: "form-check-input" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FormCheckInputDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'input[cFormCheckInput]',
                    host: {
                        class: 'form-check-input',
                        '[class]': 'hostClasses()',
                        '[attr.type]': 'type()'
                    }
                }]
        }] });

class FormControlDirective {
    constructor() {
        this.#hostElement = inject(ElementRef);
        /**
         * Size the component small or large.
         * @default undefined
         */
        this.sizing = input();
        /**
         * Set component validation state to valid.
         * @default undefined
         */
        this.valid = input();
        /**
         * Specifies the type of input element.
         */
        this.type = input('text');
        /**
         * Render the component styled as plain text. Removes the default form field styling and preserve the correct margin and padding. Recommend to use alongside `readonly`
         * @default false
         */
        this.plaintext = input(false, { transform: booleanAttribute });
        this.hostClasses = computed(() => {
            const type = this.type();
            const isRange = type === 'range';
            const plaintext = this.plaintext();
            const sizing = this.sizing();
            const valid = this.valid();
            return {
                'form-control': !isRange && !plaintext,
                'form-control-plaintext': !isRange && plaintext,
                'form-control-color': type === 'color',
                'form-range': isRange,
                [`form-control-${sizing}`]: !!sizing && !isRange,
                'is-valid': valid === true,
                'is-invalid': valid === false
            };
        });
    }
    #hostElement;
    get hostTag() {
        return this.#hostElement.nativeElement.tagName;
    }
    ngOnInit() {
        const hostTag = this.hostTag.toLowerCase();
        if (hostTag !== 'input' && hostTag !== 'textarea') {
            console.warn(`CoreUI [cFormControl] works with '<input>' and '<textarea>' - not with '<${hostTag}>'`);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FormControlDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: FormControlDirective, isStandalone: true, selector: "input[cFormControl], textarea[cFormControl]", inputs: { sizing: { classPropertyName: "sizing", publicName: "sizing", isSignal: true, isRequired: false, transformFunction: null }, valid: { classPropertyName: "valid", publicName: "valid", isSignal: true, isRequired: false, transformFunction: null }, type: { classPropertyName: "type", publicName: "type", isSignal: true, isRequired: false, transformFunction: null }, plaintext: { classPropertyName: "plaintext", publicName: "plaintext", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.type": "type()" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FormControlDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'input[cFormControl], textarea[cFormControl]',
                    host: {
                        '[class]': 'hostClasses()',
                        '[attr.type]': 'type()'
                    }
                }]
        }] });

class FormTextDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FormTextDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.2", type: FormTextDirective, isStandalone: true, selector: "[cFormText]", host: { classAttribute: "form-text" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FormTextDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cFormText]',
                    host: { class: 'form-text' }
                }]
        }] });

class FormFloatingDirective {
    constructor() {
        /**
         * Enable floating labels
         * @type boolean
         */
        this.floating = input(true, { transform: booleanAttribute, alias: 'cFormFloating' });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FormFloatingDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: FormFloatingDirective, isStandalone: true, selector: "[cFormFloating]", inputs: { floating: { classPropertyName: "floating", publicName: "cFormFloating", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class.form-floating": "floating()" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FormFloatingDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cFormFloating]',
                    host: { '[class.form-floating]': 'floating()' }
                }]
        }] });

class InputGroupTextDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: InputGroupTextDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.2", type: InputGroupTextDirective, isStandalone: true, selector: "[cInputGroupText]", host: { classAttribute: "input-group-text" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: InputGroupTextDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cInputGroupText]',
                    host: { class: 'input-group-text' }
                }]
        }] });

class FormModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FormModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: FormModule, imports: [FormDirective,
            FormCheckComponent,
            FormCheckLabelDirective,
            FormCheckInputDirective,
            FormControlDirective,
            FormFeedbackComponent,
            FormFloatingDirective,
            FormLabelDirective,
            FormSelectDirective,
            FormTextDirective,
            InputGroupComponent,
            InputGroupTextDirective], exports: [FormDirective,
            FormCheckComponent,
            FormCheckLabelDirective,
            FormCheckInputDirective,
            FormControlDirective,
            FormFeedbackComponent,
            FormFloatingDirective,
            FormLabelDirective,
            FormSelectDirective,
            FormTextDirective,
            InputGroupComponent,
            InputGroupTextDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FormModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: FormModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        FormDirective,
                        FormCheckComponent,
                        FormCheckLabelDirective,
                        FormCheckInputDirective,
                        FormControlDirective,
                        FormFeedbackComponent,
                        FormFloatingDirective,
                        FormLabelDirective,
                        FormSelectDirective,
                        FormTextDirective,
                        InputGroupComponent,
                        InputGroupTextDirective
                    ],
                    exports: [
                        FormDirective,
                        FormCheckComponent,
                        FormCheckLabelDirective,
                        FormCheckInputDirective,
                        FormControlDirective,
                        FormFeedbackComponent,
                        FormFloatingDirective,
                        FormLabelDirective,
                        FormSelectDirective,
                        FormTextDirective,
                        InputGroupComponent,
                        InputGroupTextDirective
                    ]
                }]
        }] });

class ContainerComponent {
    constructor() {
        /**
         * Set container 100% wide until a breakpoint.
         */
        this.breakpoint = input('');
        /**
         * Set container 100% wide, spanning the entire width of the viewport.
         * @return boolean
         */
        this.fluid = input(false, { transform: booleanAttribute });
        this.hostClasses = computed(() => {
            const breakpoint = this.breakpoint();
            const fluid = this.fluid();
            return {
                container: !fluid && !breakpoint,
                'container-fluid': !!fluid,
                [`container-${breakpoint}`]: !!breakpoint
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ContainerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: ContainerComponent, isStandalone: true, selector: "c-container, [cContainer]", inputs: { breakpoint: { classPropertyName: "breakpoint", publicName: "breakpoint", isSignal: true, isRequired: false, transformFunction: null }, fluid: { classPropertyName: "fluid", publicName: "fluid", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ContainerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-container, [cContainer]', template: '<ng-content />', host: { '[class]': 'hostClasses()' }, styles: [":host{display:block}\n"] }]
        }] });

class ColDirective {
    constructor() {
        /**
         * The number of columns/offset/order on extra small devices (<576px).
         * @return { 'auto' | number |  boolean }
         */
        this.cCol = input(false, { transform: this.coerceInput });
        this.xs = input(false, { transform: this.coerceInput });
        /**
         * The number of columns/offset/order on small devices (<768px).
         * @return { 'auto' | number |  boolean }
         */
        this.sm = input(false, { transform: this.coerceInput });
        /**
         * The number of columns/offset/order on medium devices (<992px).
         * @return { 'auto' | number |  boolean }
         */
        this.md = input(false, { transform: this.coerceInput });
        /**
         * The number of columns/offset/order on large devices (<1200px).
         * @return { 'auto' | number |  boolean }
         */
        this.lg = input(false, { transform: this.coerceInput });
        /**
         * The number of columns/offset/order on X-Large devices (<1400px).
         * @return { 'auto' | number |  boolean }
         */
        this.xl = input(false, { transform: this.coerceInput });
        /**
         * The number of columns/offset/order on XX-Large devices (≥1400px).
         * @return { 'auto' | number |  boolean }
         */
        this.xxl = input(false, { transform: this.coerceInput });
        this.breakpoints = computed(() => {
            return {
                xs: this.xs() || this.cCol(),
                sm: this.sm(),
                md: this.md(),
                lg: this.lg(),
                xl: this.xl(),
                xxl: this.xxl()
            };
        });
        this.offset = input();
        this.order = input();
        this.hostClasses = computed(() => {
            const classes = {
                col: true
            };
            const breakpoints = this.breakpoints();
            const offsetInput = this.offset();
            const orderInput = this.order();
            Object.keys(BreakpointInfix).forEach((breakpoint) => {
                const value = breakpoints[breakpoint];
                const infix = breakpoint === 'xs' ? '' : `-${breakpoint}`;
                classes[`col${infix}`] = value === true;
                classes[`col${infix}-${value}`] = typeof value === 'number' || typeof value === 'string';
            });
            if (typeof offsetInput === 'object') {
                const offset = { ...offsetInput };
                Object.entries(offset).forEach((entry) => {
                    const [breakpoint, value] = [...entry];
                    const infix = breakpoint === 'xs' ? '' : `-${breakpoint}`;
                    classes[`offset${infix}-${value}`] = value >= 0 && value <= 11;
                });
            }
            else {
                const offset = numberAttribute(offsetInput);
                classes[`offset-${offset}`] = typeof offset === 'number' && offset > 0 && offset <= 11;
            }
            if (typeof orderInput === 'object') {
                const order = { ...orderInput };
                Object.entries(order).forEach((entry) => {
                    const [breakpoint, value] = [...entry];
                    const infix = breakpoint === 'xs' ? '' : `-${breakpoint}`;
                    classes[`order${infix}-${value}`] = !!value;
                });
            }
            else {
                const order = orderInput;
                classes[`order-${order}`] = !!order;
            }
            // if there is no 'col' class, add one
            classes['col'] =
                !Object.entries(classes).filter((i) => i[0].startsWith('col-') && i[1]).length || breakpoints['xs'] === true;
            return classes;
        });
    }
    coerceInput(value) {
        if (value === 'auto') {
            return value;
        }
        if (value === '' || value === undefined || value === null) {
            return booleanAttribute(value);
        }
        if (typeof value === 'boolean') {
            return value;
        }
        return numberAttribute(value);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ColDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: ColDirective, isStandalone: true, selector: "[cCol]", inputs: { cCol: { classPropertyName: "cCol", publicName: "cCol", isSignal: true, isRequired: false, transformFunction: null }, xs: { classPropertyName: "xs", publicName: "xs", isSignal: true, isRequired: false, transformFunction: null }, sm: { classPropertyName: "sm", publicName: "sm", isSignal: true, isRequired: false, transformFunction: null }, md: { classPropertyName: "md", publicName: "md", isSignal: true, isRequired: false, transformFunction: null }, lg: { classPropertyName: "lg", publicName: "lg", isSignal: true, isRequired: false, transformFunction: null }, xl: { classPropertyName: "xl", publicName: "xl", isSignal: true, isRequired: false, transformFunction: null }, xxl: { classPropertyName: "xxl", publicName: "xxl", isSignal: true, isRequired: false, transformFunction: null }, offset: { classPropertyName: "offset", publicName: "offset", isSignal: true, isRequired: false, transformFunction: null }, order: { classPropertyName: "order", publicName: "order", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ColDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cCol]',
                    host: {
                        '[class]': 'hostClasses()'
                    }
                }]
        }] });

class ColComponent extends ColDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ColComponent, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: ColComponent, isStandalone: true, selector: "c-col", usesInheritance: true, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ColComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-col', template: '<ng-content />', styles: [":host{display:block}\n"] }]
        }] });

class RowDirective {
    constructor() {
        /**
         * The number of columns/offset/order on extra small devices (<576px).
         * @return { cols: 'auto' | number }
         */
        this.xs = input();
        /**
         * The number of columns/offset/order on small devices (<768px).
         * @return { cols: 'auto' | number }
         */
        this.sm = input();
        /**
         * The number of columns/offset/order on medium devices (<992px).
         * @return { cols: 'auto' | number }
         */
        this.md = input();
        /**
         * The number of columns/offset/order on large devices (<1200px).
         * @return { cols: 'auto' | number }
         */
        this.lg = input();
        /**
         * The number of columns/offset/order on X-Large devices (<1400px).
         * @return { cols: 'auto' | number }
         */
        this.xl = input();
        /**
         * The number of columns/offset/order on XX-Large devices (≥1400px).
         * @return { cols: 'auto' | number }
         */
        this.xxl = input();
        this.hostClasses = computed(() => {
            const cols = this.xs();
            const classes = {
                row: true,
                [`row-cols-${cols}`]: !!cols
            };
            Object.keys(BreakpointInfix).forEach((breakpoint) => {
                // @ts-ignore
                const value = this[breakpoint]();
                if (typeof value === 'number' || typeof value === 'string') {
                    const infix = breakpoint === 'xs' ? '' : `-${breakpoint}`;
                    classes[`row-cols${infix}-${value}`] = !!value;
                }
            });
            return classes;
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: RowDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: RowDirective, isStandalone: true, selector: "[cRow]", inputs: { xs: { classPropertyName: "xs", publicName: "xs", isSignal: true, isRequired: false, transformFunction: null }, sm: { classPropertyName: "sm", publicName: "sm", isSignal: true, isRequired: false, transformFunction: null }, md: { classPropertyName: "md", publicName: "md", isSignal: true, isRequired: false, transformFunction: null }, lg: { classPropertyName: "lg", publicName: "lg", isSignal: true, isRequired: false, transformFunction: null }, xl: { classPropertyName: "xl", publicName: "xl", isSignal: true, isRequired: false, transformFunction: null }, xxl: { classPropertyName: "xxl", publicName: "xxl", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "row" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: RowDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cRow]',
                    host: {
                        class: 'row',
                        '[class]': 'hostClasses()'
                    }
                }]
        }] });

class RowComponent extends RowDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: RowComponent, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: RowComponent, isStandalone: true, selector: "c-row", usesInheritance: true, ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: RowComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-row',
                    template: '<ng-content />'
                }]
        }] });

class GutterDirective {
    constructor() {
        /**
         * Define padding between columns to space and align content responsively in the Bootstrap grid system.
         */
        this.gutter = input({});
        this.hostClasses = computed(() => {
            let gutterClass;
            const gutterInput = this.gutter();
            if (typeof gutterInput === 'number') {
                gutterClass = GutterDirective.getGutterClasses({ g: gutterInput });
                return gutterClass;
            }
            {
                const { g, gx, gy } = { ...gutterInput };
                gutterClass = GutterDirective.getGutterClasses({ g, gx, gy });
            }
            Object.keys(BreakpointInfix).forEach((key) => {
                // @ts-ignore
                const gutter = gutterInput[key] ? { ...gutterInput[key] } : undefined;
                if (gutter) {
                    const classes = GutterDirective.getGutterClasses(gutter, key);
                    gutterClass = { ...gutterClass, ...classes };
                }
            });
            return gutterClass;
        });
    }
    static getGutterClasses(gutter, breakpoint) {
        const { g, gx, gy } = { ...gutter };
        const infix = breakpoint ? `-${breakpoint}` : '';
        return {
            [`g${infix}-${g}`]: typeof g === 'number',
            [`gx${infix}-${gx}`]: typeof gx === 'number',
            [`gy${infix}-${gy}`]: typeof gy === 'number'
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: GutterDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: GutterDirective, isStandalone: true, selector: "[gutter]", inputs: { gutter: { classPropertyName: "gutter", publicName: "gutter", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, exportAs: ["gutter"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: GutterDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: '[gutter]',
                    exportAs: 'gutter',
                    host: {
                        '[class]': 'hostClasses()'
                    }
                }]
        }] });

class GridModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: GridModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: GridModule, imports: [ColComponent,
            ColDirective,
            ContainerComponent,
            GutterDirective,
            RowComponent,
            RowDirective], exports: [ColComponent,
            ColDirective,
            ContainerComponent,
            GutterDirective,
            RowComponent,
            RowDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: GridModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: GridModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        ColComponent,
                        ColDirective,
                        ContainerComponent,
                        GutterDirective,
                        RowComponent,
                        RowDirective
                    ],
                    exports: [
                        ColComponent,
                        ColDirective,
                        ContainerComponent,
                        GutterDirective,
                        RowComponent,
                        RowDirective
                    ]
                }]
        }] });

class HeaderComponent {
    constructor() {
        /**
         * Defines optional container wrapping children elements.
         */
        this.container = input();
        /**
         * Place header in non-static positions.
         */
        this.position = input();
        /**
         * Default role for header. [docs]
         * @type string
         * @default 'banner'
         */
        this.role = input('banner');
        this.hostClasses = computed(() => {
            return !!this.container() ? this.containerClasses() : this.headerClasses();
        });
        this.headerClasses = computed(() => {
            const position = this.position();
            return {
                header: true,
                [`header-${position}`]: !!position
            };
        });
        this.containerClasses = computed(() => {
            const container = this.container();
            return {
                container: container === true,
                [`container-${container}`]: typeof container === 'string'
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: HeaderComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.2", type: HeaderComponent, isStandalone: true, selector: "c-header, [c-header]", inputs: { container: { classPropertyName: "container", publicName: "container", isSignal: true, isRequired: false, transformFunction: null }, position: { classPropertyName: "position", publicName: "position", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.role": "role()", "class": "hostClasses()" } }, exportAs: ["cHeader"], ngImport: i0, template: "@if (!!container()) {\n  <div [ngClass]=\"headerClasses()\">\n    <ng-content />\n  </div>\n} @else {\n  <ng-content />\n}\n", dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: HeaderComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-header, [c-header]', imports: [NgClass], exportAs: 'cHeader', host: { '[attr.role]': 'role()', '[class]': 'hostClasses()' }, template: "@if (!!container()) {\n  <div [ngClass]=\"headerClasses()\">\n    <ng-content />\n  </div>\n} @else {\n  <ng-content />\n}\n" }]
        }] });

class HeaderBrandComponent {
    constructor() {
        /**
         * Default role for header-brand. [docs]
         * @return string
         * @default 'button'
         */
        this.role = input('button');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: HeaderBrandComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: HeaderBrandComponent, isStandalone: true, selector: "c-header-brand", inputs: { role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.role": "role()" }, classAttribute: "header-brand" }, exportAs: ["cHeaderBrand"], ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: HeaderBrandComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-header-brand',
                    template: '<ng-content />',
                    exportAs: 'cHeaderBrand',
                    host: {
                        '[attr.role]': 'role()',
                        class: 'header-brand'
                    }
                }]
        }] });

class HeaderDividerComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: HeaderDividerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: HeaderDividerComponent, isStandalone: true, selector: "c-header-divider, [cHeaderDivider]", host: { classAttribute: "header-divider" }, ngImport: i0, template: ``, isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: HeaderDividerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-header-divider, [cHeaderDivider]',
                    template: ``,
                    host: {
                        class: 'header-divider'
                    }
                }]
        }] });

class HeaderNavComponent {
    constructor() {
        /**
         * Default role for header-nav. [docs]
         * @return string
         * @default 'navigation'
         */
        this.role = input('navigation');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: HeaderNavComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: HeaderNavComponent, isStandalone: true, selector: "c-header-nav", inputs: { role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.role": "role()" }, classAttribute: "header-nav" }, exportAs: ["cHeaderNav"], ngImport: i0, template: '<ng-content />', isInline: true, styles: [""] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: HeaderNavComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-header-nav', template: '<ng-content />', exportAs: 'cHeaderNav', host: {
                        '[attr.role]': 'role()',
                        class: 'header-nav'
                    } }]
        }] });

class HeaderTextComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: HeaderTextComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: HeaderTextComponent, isStandalone: true, selector: "c-header-text, [cHeaderText]", host: { classAttribute: "header-text" }, ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: HeaderTextComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-header-text, [cHeaderText]',
                    template: '<ng-content />',
                    host: {
                        class: 'header-text'
                    }
                }]
        }] });

class HeaderTogglerDirective {
    constructor() {
        this.#renderer = inject(Renderer2);
        this.#hostElement = inject(ElementRef);
        /**
         * Default type for header-toggler button. [docs]
         * @return string
         * @default 'button'
         */
        this.type = input('button');
        /**
         * Default aria-label attr for header-toggler. [docs]
         * @type string
         * @default 'Toggle navigation'
         */
        this.ariaLabel = input('Toggle navigation');
    }
    #renderer;
    #hostElement;
    addDefaultIcon() {
        const span = this.#renderer.createElement('span');
        this.#renderer.addClass(span, 'header-toggler-icon');
        this.#renderer.appendChild(this.#hostElement.nativeElement, span);
    }
    ngAfterContentInit() {
        const hasContent = this.#hostElement.nativeElement.childNodes.length > 0;
        if (!hasContent) {
            this.addDefaultIcon();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: HeaderTogglerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: HeaderTogglerDirective, isStandalone: true, selector: "[cHeaderToggler]", inputs: { type: { classPropertyName: "type", publicName: "type", isSignal: true, isRequired: false, transformFunction: null }, ariaLabel: { classPropertyName: "ariaLabel", publicName: "ariaLabel", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.type": "type()", "attr.aria-label": "ariaLabel()" }, classAttribute: "header-toggler" }, exportAs: ["cHeaderToggler"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: HeaderTogglerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cHeaderToggler]',
                    exportAs: 'cHeaderToggler',
                    host: {
                        '[attr.type]': 'type()',
                        '[attr.aria-label]': 'ariaLabel()',
                        class: 'header-toggler'
                    }
                }]
        }] });

class HeaderModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: HeaderModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: HeaderModule, imports: [HeaderComponent,
            HeaderBrandComponent,
            HeaderDividerComponent,
            HeaderNavComponent,
            HeaderTextComponent,
            HeaderTogglerDirective], exports: [HeaderComponent,
            HeaderBrandComponent,
            HeaderDividerComponent,
            HeaderNavComponent,
            HeaderTextComponent,
            HeaderTogglerDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: HeaderModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: HeaderModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        HeaderComponent,
                        HeaderBrandComponent,
                        HeaderDividerComponent,
                        HeaderNavComponent,
                        HeaderTextComponent,
                        HeaderTogglerDirective
                    ],
                    exports: [
                        HeaderComponent,
                        HeaderBrandComponent,
                        HeaderDividerComponent,
                        HeaderNavComponent,
                        HeaderTextComponent,
                        HeaderTogglerDirective
                    ]
                }]
        }] });

class ImgDirective {
    constructor() {
        /**
         * Set the horizontal aligment.
         * @type {'' | 'start' | 'end' | 'center'}
         */
        this.align = input('');
        /**
         * Make image responsive.
         * @type boolean
         */
        this.fluid = input(false, { transform: booleanAttribute });
        /**
         * Make image rounded.
         * @type boolean
         */
        this.rounded = input(false, { transform: booleanAttribute });
        /**
         * Give an image a rounded 1px border appearance.
         * @type boolean
         */
        this.thumbnail = input(false, { transform: booleanAttribute });
        /**
         * Color for image placeholder.
         */
        this.placeholderColor = input('transparent');
        this.hostStyles = computed(() => {
            return { backgroundColor: this.placeholderColor() };
        });
        this.hostClasses = computed(() => {
            const align = this.align();
            return {
                [`float-${align}`]: align === 'start' || align === 'end',
                'd-block': align === 'center',
                'mx-auto': align === 'center',
                'img-fluid': this.fluid(),
                rounded: this.rounded(),
                'img-thumbnail': this.thumbnail()
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ImgDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: ImgDirective, isStandalone: true, selector: "[cImg]", inputs: { align: { classPropertyName: "align", publicName: "align", isSignal: true, isRequired: false, transformFunction: null }, fluid: { classPropertyName: "fluid", publicName: "fluid", isSignal: true, isRequired: false, transformFunction: null }, rounded: { classPropertyName: "rounded", publicName: "rounded", isSignal: true, isRequired: false, transformFunction: null }, thumbnail: { classPropertyName: "thumbnail", publicName: "thumbnail", isSignal: true, isRequired: false, transformFunction: null }, placeholderColor: { classPropertyName: "placeholderColor", publicName: "placeholderColor", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "style": "hostStyles()" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ImgDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cImg]',
                    host: {
                        '[class]': 'hostClasses()',
                        '[style]': 'hostStyles()'
                    }
                }]
        }] });

class ImgModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ImgModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: ImgModule, imports: [ImgDirective], exports: [ImgDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ImgModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ImgModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [ImgDirective],
                    exports: [ImgDirective]
                }]
        }] });

class ListGroupDirective {
    constructor() {
        /**
         * Remove some borders and rounded corners to render list group items edge-to-edge in a parent component (e.g., `<CCard>`).
         * @type boolean
         */
        this.flush = input(false, { transform: booleanAttribute });
        /**
         * Specify horizontal layout type.
         */
        this.horizontal = input();
        this.hostClasses = computed(() => {
            const horizontal = this.horizontal();
            return {
                'list-group': true,
                'list-group-horizontal': horizontal === true || horizontal === '',
                [`list-group-horizontal-${horizontal}`]: !!horizontal && typeof horizontal !== 'boolean',
                'list-group-flush': this.flush()
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ListGroupDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: ListGroupDirective, isStandalone: true, selector: "[cListGroup]", inputs: { flush: { classPropertyName: "flush", publicName: "flush", isSignal: true, isRequired: false, transformFunction: null }, horizontal: { classPropertyName: "horizontal", publicName: "horizontal", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "list-group" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ListGroupDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cListGroup]',
                    host: {
                        class: 'list-group',
                        '[class]': 'hostClasses()'
                    }
                }]
        }] });

class ListGroupItemDirective {
    constructor() {
        this.hostElement = inject(ElementRef);
        /**
         * Toggle the active state for the component.
         * @type InputSignal<boolean | undefined>
         */
        this.active = input();
        /**
         * Sets the color context of the component to one of CoreUI’s themed colors.
         * @type InputSignal<boolean | undefined>
         */
        this.color = input();
        /**
         * Set disabled attr for the host element. [docs]
         * @type boolean
         */
        this.disabled = input(false, { transform: booleanAttribute });
        this.hostClasses = computed(() => {
            const host = this.hostElement.nativeElement;
            return {
                'list-group-item': true,
                'list-group-item-action': host.nodeName === 'A' || host.nodeName === 'BUTTON',
                active: !!this.active(),
                disabled: this._disabled(),
                [`list-group-item-${this.color()}`]: !!this.color()
            };
        });
        this._disabled = computed(() => this.disabled());
        this.ariaDisabled = computed(() => {
            return this._disabled() ? true : null;
        });
        this.attrDisabled = computed(() => {
            return this._disabled() ? '' : null;
        });
        this.tabIndex = computed(() => {
            return this._disabled() ? '-1' : null;
        });
        this.ariaCurrent = computed(() => {
            return this.active() || null;
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ListGroupItemDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: ListGroupItemDirective, isStandalone: true, selector: "[cListGroupItem], c-list-group-item", inputs: { active: { classPropertyName: "active", publicName: "active", isSignal: true, isRequired: false, transformFunction: null }, color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.aria-disabled": "ariaDisabled()", "attr.aria-current": "ariaCurrent()", "attr.disabled": "attrDisabled()", "attr.tabindex": "tabIndex()" } }, exportAs: ["cListGroupItem"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ListGroupItemDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cListGroupItem], c-list-group-item',
                    exportAs: 'cListGroupItem',
                    host: {
                        '[class]': 'hostClasses()',
                        '[attr.aria-disabled]': 'ariaDisabled()',
                        '[attr.aria-current]': 'ariaCurrent()',
                        '[attr.disabled]': 'attrDisabled()',
                        '[attr.tabindex]': 'tabIndex()'
                    }
                }]
        }] });

class ListGroupModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ListGroupModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: ListGroupModule, imports: [ListGroupDirective, ListGroupItemDirective], exports: [ListGroupDirective, ListGroupItemDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ListGroupModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ListGroupModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [ListGroupDirective, ListGroupItemDirective],
                    imports: [ListGroupDirective, ListGroupItemDirective]
                }]
        }] });

class NavLinkDirective {
    constructor() {
        /**
         * Sets .nav-link class to the host. [docs]
         * @default true
         */
        this.cNavLink = input(true, { transform: booleanAttribute });
        /**
         * Toggle the active state for the component. [docs]
         * @default undefined
         */
        this.active = input();
        /**
         * Set disabled attr for the host element. [docs]
         * @default false
         */
        this.disabled = input(false, { transform: booleanAttribute });
        this.ariaCurrent = computed(() => {
            return this.active() ? 'page' : null;
        });
        this.ariaDisabled = null;
        this.attrDisabled = null;
        this.attrTabindex = null;
        this.styleCursor = null;
        this.#disabledEffect = effect(() => {
            const disabled = this.disabled();
            this.ariaDisabled = disabled || null;
            this.attrDisabled = disabled ? '' : null;
            this.attrTabindex = disabled ? '-1' : null;
            this.styleCursor = disabled ? null : 'pointer';
        });
        this.hostClasses = computed(() => {
            return {
                'nav-link': this.cNavLink(),
                disabled: this.disabled(),
                active: this.active()
            };
        });
    }
    #disabledEffect;
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: NavLinkDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: NavLinkDirective, isStandalone: true, selector: "[cNavLink]", inputs: { cNavLink: { classPropertyName: "cNavLink", publicName: "cNavLink", isSignal: true, isRequired: false, transformFunction: null }, active: { classPropertyName: "active", publicName: "active", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.aria-current": "ariaCurrent()", "attr.aria-disabled": "ariaDisabled", "attr.disabled": "attrDisabled", "attr.tabindex": "attrTabindex", "style.cursor": "styleCursor" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: NavLinkDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cNavLink]',
                    host: {
                        '[class]': 'hostClasses()',
                        '[attr.aria-current]': 'ariaCurrent()',
                        '[attr.aria-disabled]': 'ariaDisabled',
                        '[attr.disabled]': 'attrDisabled',
                        '[attr.tabindex]': 'attrTabindex',
                        '[style.cursor]': 'styleCursor'
                    }
                }]
        }] });

class NavItemComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: NavItemComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: NavItemComponent, isStandalone: true, selector: "c-nav-item", host: { classAttribute: "nav-item" }, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:list-item;text-align:match-parent;text-align:-webkit-match-parent}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: NavItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-nav-item', template: '<ng-content />', host: { class: 'nav-item' }, styles: [":host{display:list-item;text-align:match-parent;text-align:-webkit-match-parent}\n"] }]
        }] });

class NavComponent {
    constructor() {
        /**
         * Specify a layout type for component.
         * @default undefined
         */
        this.layout = input();
        /**
         * Set the nav variant to tabs or pills.
         * @default undefined
         */
        this.variant = input();
        this.hostClasses = computed(() => {
            const layout = this.layout();
            const variant = this.variant();
            return {
                nav: true,
                [`nav-${layout}`]: !!layout,
                [`nav-${variant}`]: !!variant
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: NavComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: NavComponent, isStandalone: true, selector: "c-nav", inputs: { layout: { classPropertyName: "layout", publicName: "layout", isSignal: true, isRequired: false, transformFunction: null }, variant: { classPropertyName: "variant", publicName: "variant", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "nav" }, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host .nav-link:focus{outline:0}:host.nav-underline-border{column-gap:0}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: NavComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-nav', template: '<ng-content />', host: { class: 'nav', '[class]': 'hostClasses()' }, styles: [":host .nav-link:focus{outline:0}:host.nav-underline-border{column-gap:0}\n"] }]
        }] });

class NavModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: NavModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: NavModule, imports: [NavComponent,
            NavItemComponent,
            NavLinkDirective], exports: [NavComponent,
            NavItemComponent,
            NavLinkDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: NavModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: NavModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        NavComponent,
                        NavItemComponent,
                        NavLinkDirective
                    ],
                    exports: [
                        NavComponent,
                        NavItemComponent,
                        NavLinkDirective
                    ]
                }]
        }] });

// todo: fix container prop issue not rendering children
// todo: workaround -  use <c-container> component directly in template
class NavbarComponent {
    constructor() {
        this.#breakpointObserver = inject(BreakpointObserver);
        this.#document = inject(DOCUMENT);
        this.#hostElement = inject(ElementRef);
        /**
         * Sets the color context of the component to one of CoreUI’s themed colors.
         * @type Colors
         */
        this.color = input();
        /**
         * Defines optional container wrapping children elements.
         */
        this.container = input();
        /**
         * Defines the responsive breakpoint to determine when content collapses.
         */
        this.expand = input();
        /**
         * Place component in non-static positions.
         */
        this.placement = input();
        this.role = input('navigation');
        this.collapse = contentChild(CollapseDirective);
        this.hostClasses = computed(() => {
            const color = this.color();
            const expand = this.expand();
            const expandClassSuffix = expand === true ? '' : `-${expand}`;
            const placement = this.placement();
            return {
                navbar: true,
                [`navbar-expand${expandClassSuffix}`]: !!expand,
                [`bg-${color}`]: !!color,
                [`${placement}`]: !!placement
            };
        });
        this.containerClass = computed(() => {
            const container = this.container();
            return `container${container !== true ? '-' + container : ''}`;
        });
        this.computedStyle = signal('');
        this.afterNextRenderFn = afterRender({
            read: () => {
                const expand = this.expand();
                if (typeof expand === 'string') {
                    const computedStyle = this.#document.defaultView
                        ?.getComputedStyle(this.#hostElement.nativeElement)
                        ?.getPropertyValue(`--cui-breakpoint-${expand}`) ?? false;
                    computedStyle && this.computedStyle.set(computedStyle);
                }
            }
        });
        this.breakpoint = computed(() => {
            const expand = this.expand();
            if (typeof expand === 'string') {
                return this.computedStyle();
            }
            return false;
        });
    }
    #breakpointObserver;
    #document;
    #hostElement;
    #observer;
    ngAfterContentInit() {
        const breakpoint = this.breakpoint();
        if (breakpoint) {
            const onBreakpoint = `(min-width: ${breakpoint})`;
            this.#observer = this.#breakpointObserver
                .observe([onBreakpoint])
                .pipe()
                .subscribe((result) => {
                const collapse = this.collapse();
                if (collapse) {
                    const animate = collapse.animate();
                    collapse.animate.set(false);
                    collapse.toggle(false);
                    setTimeout(() => {
                        collapse.toggle(result.matches);
                        setTimeout(() => {
                            collapse.animate.set(animate);
                        });
                    });
                }
            });
        }
    }
    ngOnDestroy() {
        this.#observer?.unsubscribe();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: NavbarComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "19.2.2", type: NavbarComponent, isStandalone: true, selector: "c-navbar", inputs: { color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null }, container: { classPropertyName: "container", publicName: "container", isSignal: true, isRequired: false, transformFunction: null }, expand: { classPropertyName: "expand", publicName: "expand", isSignal: true, isRequired: false, transformFunction: null }, placement: { classPropertyName: "placement", publicName: "placement", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.role": "role()" } }, queries: [{ propertyName: "collapse", first: true, predicate: CollapseDirective, descendants: true, isSignal: true }], hostDirectives: [{ directive: ThemeDirective, inputs: ["colorScheme", "colorScheme"] }], ngImport: i0, template: "<ng-container *ngTemplateOutlet=\"container() ? withContainerTemplate : noContainerTemplate\" />\n\n<ng-template #withContainerTemplate>\n  <div [ngClass]=\"containerClass()\">\n    <ng-content />\n  </div>\n</ng-template>\n\n<ng-template #noContainerTemplate>\n  <ng-content />\n</ng-template>\n", dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: NavbarComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-navbar', imports: [NgClass, NgTemplateOutlet], hostDirectives: [{ directive: ThemeDirective, inputs: ['colorScheme'] }], host: { '[class]': 'hostClasses()', '[attr.role]': 'role()' }, template: "<ng-container *ngTemplateOutlet=\"container() ? withContainerTemplate : noContainerTemplate\" />\n\n<ng-template #withContainerTemplate>\n  <div [ngClass]=\"containerClass()\">\n    <ng-content />\n  </div>\n</ng-template>\n\n<ng-template #noContainerTemplate>\n  <ng-content />\n</ng-template>\n" }]
        }] });

class NavbarBrandDirective {
    constructor() {
        this.role = input('button');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: NavbarBrandDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: NavbarBrandDirective, isStandalone: true, selector: "[cNavbarBrand]", inputs: { role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.role": "role()" }, classAttribute: "navbar-brand" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: NavbarBrandDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cNavbarBrand]',
                    host: { class: 'navbar-brand', '[attr.role]': 'role()' }
                }]
        }] });

class NavbarNavComponent {
    constructor() {
        /**
         * Enable vertical scrolling of a collapsed navbar toggleable contents.
         * @type boolean
         */
        this.scroll = input(false, { transform: booleanAttribute });
        this.hostClasses = computed(() => {
            return {
                'navbar-nav': true,
                'navbar-nav-scroll': this.scroll()
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: NavbarNavComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: NavbarNavComponent, isStandalone: true, selector: "c-navbar-nav", inputs: { scroll: { classPropertyName: "scroll", publicName: "scroll", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: NavbarNavComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-navbar-nav',
                    template: '<ng-content />',
                    host: { '[class]': 'hostClasses()' }
                }]
        }] });

class NavbarTextComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: NavbarTextComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: NavbarTextComponent, isStandalone: true, selector: "c-navbar-text", host: { classAttribute: "navbar-text" }, ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: NavbarTextComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-navbar-text',
                    template: '<ng-content />',
                    host: { class: 'navbar-text' }
                }]
        }] });

class NavbarTogglerDirective {
    #renderer;
    #hostElement;
    constructor() {
        this.#renderer = inject(Renderer2);
        this.#hostElement = inject(ElementRef);
        /**
         * Reference to navbar collapse element (via # template variable) . [docs]
         * @type string
         * @default 'button'
         */
        this.collapseRef = input(undefined, { alias: 'cNavbarToggler' });
        /**
         * Default type for navbar-toggler. [docs]
         * @type string
         * @default 'button'
         */
        this.type = input('button');
        /**
         * Default aria-label attr for navbar-toggler. [docs]
         * @type string
         * @default 'Toggle navigation'
         */
        this.ariaLabel = input('Toggle navigation');
        afterNextRender({
            read: () => {
                const hasContent = this.#hostElement.nativeElement.childNodes.length;
                if (!hasContent) {
                    this.addDefaultIcon();
                }
            }
        });
    }
    handleClick($event) {
        const collapseRef = this.collapseRef();
        collapseRef?.toggle(!collapseRef?.visible());
    }
    addDefaultIcon() {
        const span = this.#renderer.createElement('span');
        this.#renderer.addClass(span, 'navbar-toggler-icon');
        this.#renderer.appendChild(this.#hostElement.nativeElement, span);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: NavbarTogglerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: NavbarTogglerDirective, isStandalone: true, selector: "[cNavbarToggler]", inputs: { collapseRef: { classPropertyName: "collapseRef", publicName: "cNavbarToggler", isSignal: true, isRequired: false, transformFunction: null }, type: { classPropertyName: "type", publicName: "type", isSignal: true, isRequired: false, transformFunction: null }, ariaLabel: { classPropertyName: "ariaLabel", publicName: "ariaLabel", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "handleClick($event)" }, properties: { "attr.aria-label": "ariaLabel()", "attr.type": "type()" }, classAttribute: "navbar-toggler" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: NavbarTogglerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cNavbarToggler]',
                    host: {
                        '[attr.aria-label]': 'ariaLabel()',
                        '[attr.type]': 'type()',
                        class: 'navbar-toggler',
                        '(click)': 'handleClick($event)'
                    }
                }]
        }], ctorParameters: () => [] });

class NavbarModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: NavbarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: NavbarModule, imports: [NavbarBrandDirective,
            NavbarComponent,
            NavbarNavComponent,
            NavbarTextComponent,
            NavbarTogglerDirective], exports: [NavbarBrandDirective,
            NavbarComponent,
            NavbarNavComponent,
            NavbarTextComponent,
            NavbarTogglerDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: NavbarModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: NavbarModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [
                        NavbarBrandDirective,
                        NavbarComponent,
                        NavbarNavComponent,
                        NavbarTextComponent,
                        NavbarTogglerDirective
                    ],
                    imports: [
                        NavbarBrandDirective,
                        NavbarComponent,
                        NavbarNavComponent,
                        NavbarTextComponent,
                        NavbarTogglerDirective
                    ]
                }]
        }] });

class ModalBodyComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ModalBodyComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: ModalBodyComponent, isStandalone: true, selector: "c-modal-body", host: { classAttribute: "modal-body" }, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ModalBodyComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-modal-body', template: '<ng-content />', host: { class: 'modal-body' }, styles: [":host{display:block}\n"] }]
        }] });

class ModalContentComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ModalContentComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: ModalContentComponent, isStandalone: true, selector: "c-modal-content", host: { classAttribute: "modal-content" }, ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ModalContentComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-modal-content',
                    template: '<ng-content />',
                    host: { class: 'modal-content' }
                }]
        }] });

class ModalDialogComponent {
    constructor() {
        /**
         * Align the modal in the center or top of the screen.
         * @default undefined
         */
        this.alignment = input();
        /**
         * Set modal to covers the entire user viewport.
         * @return {boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl'}
         */
        this.fullscreen = input();
        /**
         * Does the modal dialog itself scroll, or does the whole dialog scroll within the window.
         * @default false
         * @return {boolean}
         */
        this.scrollable = input(false, { transform: booleanAttribute });
        /**
         * Size the component small, large, or extra large.
         * @default undefined
         * @return {'sm' | 'lg' | 'xl'}
         */
        this.size = input();
        this.hostClasses = computed(() => {
            const fullscreen = this.fullscreen();
            const size = this.size();
            return {
                'modal-dialog': true,
                'modal-dialog-centered': this.alignment() === 'center',
                'modal-fullscreen': fullscreen === true,
                [`modal-fullscreen-${fullscreen}-down`]: typeof fullscreen === 'string',
                'modal-dialog-scrollable': this.scrollable(),
                [`modal-${size}`]: !!size
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ModalDialogComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: ModalDialogComponent, isStandalone: true, selector: "c-modal-dialog", inputs: { alignment: { classPropertyName: "alignment", publicName: "alignment", isSignal: true, isRequired: false, transformFunction: null }, fullscreen: { classPropertyName: "fullscreen", publicName: "fullscreen", isSignal: true, isRequired: false, transformFunction: null }, scrollable: { classPropertyName: "scrollable", publicName: "scrollable", isSignal: true, isRequired: false, transformFunction: null }, size: { classPropertyName: "size", publicName: "size", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "modal-dialog" }, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}:host.modal-dialog-centered{display:flex}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ModalDialogComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-modal-dialog', template: '<ng-content />', host: { class: 'modal-dialog', '[class]': 'hostClasses()' }, styles: [":host{display:block}:host.modal-dialog-centered{display:flex}\n"] }]
        }] });

class ModalService {
    constructor() {
        this.#modalState = new Subject();
        this.modalState$ = this.#modalState.asObservable();
    }
    #modalState;
    toggle(action) {
        this.#modalState.next(action);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ModalService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ModalService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ModalService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class ModalToggleDirective {
    constructor() {
        this.#modalService = inject(ModalService);
        /**
         * Html id attr of modal to dismiss.
         * @default undefined
         */
        this.toggle = input(undefined, { alias: 'cModalToggle' });
    }
    #modalService;
    dismiss($event) {
        $event.preventDefault();
        this.#modalService.toggle({ show: 'toggle', id: this.toggle() });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ModalToggleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: ModalToggleDirective, isStandalone: true, selector: "[cModalToggle]", inputs: { toggle: { classPropertyName: "toggle", publicName: "cModalToggle", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "dismiss($event)" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ModalToggleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cModalToggle]',
                    host: {
                        '(click)': 'dismiss($event)'
                    }
                }]
        }] });

class ModalFooterComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ModalFooterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: ModalFooterComponent, isStandalone: true, selector: "c-modal-footer", host: { classAttribute: "modal-footer" }, ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ModalFooterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-modal-footer',
                    template: '<ng-content />',
                    host: { class: 'modal-footer' }
                }]
        }] });

class ModalHeaderComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ModalHeaderComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: ModalHeaderComponent, isStandalone: true, selector: "c-modal-header", host: { classAttribute: "modal-header" }, ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ModalHeaderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-modal-header',
                    template: '<ng-content />',
                    host: { class: 'modal-header' }
                }]
        }] });

class ModalTitleDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ModalTitleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.2", type: ModalTitleDirective, isStandalone: true, selector: "[cModalTitle]", host: { classAttribute: "modal-title" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ModalTitleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cModalTitle]',
                    host: { class: 'modal-title' }
                }]
        }] });

class ModalComponent {
    constructor() {
        this.#document = inject(DOCUMENT);
        this.#renderer = inject(Renderer2);
        this.#hostElement = inject(ElementRef);
        this.#modalService = inject(ModalService);
        this.#backdropService = inject(BackdropService);
        this.#destroyRef = inject(DestroyRef);
        this.#focusMonitor = inject(FocusMonitor);
        /**
         * Align the modal in the center or top of the screen.
         * @return {'top' | 'center'}
         * @default 'top'
         */
        this.alignment = input('top');
        /**
         * Apply a backdrop on body while modal is open.
         * @return boolean | 'static'
         * @default true
         */
        this.backdrop = input(true);
        /**
         * Set modal to cover the entire user viewport.
         * @return {boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl'}
         * @default undefined
         */
        this.fullscreen = input();
        /**
         * Closes the modal when escape key is pressed.
         * @return boolean
         * @default true
         */
        this.keyboard = input(true, { transform: booleanAttribute });
        this.attrId = input(undefined, { alias: 'id' });
        /**
         * Size the component small, large, or extra large.
         * @return {'sm' | 'lg' | 'xl'}
         * @default undefined
         */
        this.size = input();
        /**
         * Remove animation to create modal that simply appear rather than fade in to view.
         */
        this.transition = input(true, { transform: booleanAttribute });
        /**
         * Default role for modal
         * @return string
         * @default 'dialog'
         */
        this.role = input('dialog');
        /**
         * Set aria-modal html attr for modal
         * @type boolean
         * @default null
         */
        this.ariaModalInput = input(false, { transform: booleanAttribute, alias: 'ariaModal' });
        this.ariaModal = computed(() => {
            return this.visible || this.ariaModalInput() ? true : null;
        });
        /**
         * Create a scrollable modal that allows scrolling the modal body.
         * @return boolean
         * @default false
         */
        this.scrollable = input(false, { transform: booleanAttribute });
        /**
         * Toggle the visibility of modal component.
         * @return boolean
         * @default false
         */
        this.visibleInput = input(false, { transform: booleanAttribute, alias: 'visible' });
        this.#visibleInputEffect = effect(() => {
            const visible = this.visibleInput();
            untracked(() => {
                this.visible = visible;
            });
        });
        this.#visible = signal(false);
        this.#activeElement = signal(null);
        this.#visibleEffect = effect(() => {
            const visible = this.#visible();
            const afterViewInit = this.#afterViewInit();
            untracked(() => {
                if (visible && afterViewInit) {
                    this.#activeElement.set(this.#document.activeElement);
                    // this.#activeElement()?.blur();
                    setTimeout(() => {
                        const focusable = this.modalContentRef()?.nativeElement.querySelectorAll('[tabindex]:not([tabindex="-1"]), button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled])');
                        if (focusable?.length) {
                            this.#focusMonitor.focusVia(focusable[0], 'keyboard');
                        }
                    });
                }
                else {
                    const activeElement = this.#activeElement();
                    if (activeElement && this.#document.contains(activeElement)) {
                        this.#focusMonitor.focusVia(activeElement, 'keyboard');
                        setTimeout(() => {
                            // this.#activeElement()?.focus();
                            this.#activeElement.set(null);
                        });
                    }
                }
            });
        });
        /**
         * Event triggered on modal dismiss.
         * @return boolean
         */
        this.visibleChange = output();
        // @ViewChild(ModalContentComponent, { read: ElementRef }) modalContent!: ElementRef;
        // @ViewChild('modalContentRef', { read: ElementRef }) modalContentRef!: ElementRef;
        // readonly modalContentRef = viewChild(ModalContentComponent, { read: ElementRef });
        this.modalContentRef = viewChild('modalContentRef', { read: ElementRef });
        // private inBoundingClientRect!: boolean;
        this.hostClasses = computed(() => {
            return {
                modal: true,
                fade: this.transition(),
                show: this.show
            };
        });
        this.animateTrigger = computed(() => {
            return this.visible ? 'visible' : 'hidden';
        });
        this.#show = signal(true);
        this.mouseDownTarget = null;
        this.#afterViewInit = signal(false);
    }
    #document;
    #renderer;
    #hostElement;
    #modalService;
    #backdropService;
    #destroyRef;
    #focusMonitor;
    get id() {
        return this.attrId();
    }
    #visibleInputEffect;
    set visible(value) {
        if (this.#visible() !== value) {
            this.#visible.set(value);
            this.setBodyStyles(value);
            this.setBackdrop(this.backdrop() !== false && value);
            this.visibleChange.emit(value);
        }
    }
    get visible() {
        return this.#visible();
    }
    #visible;
    #activeElement;
    #visibleEffect;
    #activeBackdrop;
    get ariaHidden() {
        return this.visible ? null : true;
    }
    get show() {
        return this.visible && this.#show();
    }
    set show(value) {
        this.#show.set(value);
    }
    #show;
    animateStart(event) {
        if (event.toState === 'visible') {
            this.#backdropService.hideScrollbar();
            this.#renderer.setStyle(this.#hostElement.nativeElement, 'display', 'block');
        }
        else {
            if (!this.transition()) {
                this.#renderer.setStyle(this.#hostElement.nativeElement, 'display', 'none');
            }
        }
    }
    animateDone(event) {
        setTimeout(() => {
            if (event.toState === 'hidden') {
                this.#renderer.setStyle(this.#hostElement.nativeElement, 'display', 'none');
            }
        });
        this.show = this.visible;
    }
    onKeyUpHandler(event) {
        if (event.key === 'Escape' && this.keyboard() && this.visible) {
            if (this.backdrop() === 'static') {
                this.setStaticBackdrop();
            }
            else {
                this.#modalService.toggle({ show: false, modal: this });
            }
        }
    }
    onMouseDownHandler($event) {
        this.mouseDownTarget = $event.target;
    }
    onClickHandler($event) {
        if (this.mouseDownTarget !== $event.target) {
            this.mouseDownTarget = null;
            return;
        }
        const targetElement = $event.target;
        if (targetElement === this.#hostElement.nativeElement) {
            if (this.backdrop() === 'static') {
                this.setStaticBackdrop();
                return;
            }
            this.#modalService.toggle({ show: false, modal: this });
        }
    }
    ngOnInit() {
        this.stateToggleSubscribe();
    }
    #afterViewInit;
    ngAfterViewInit() {
        this.#afterViewInit.set(true);
    }
    ngOnDestroy() {
        this.#modalService.toggle({ show: false, modal: this });
        this.#afterViewInit.set(false);
    }
    stateToggleSubscribe() {
        this.#modalService.modalState$.pipe(takeUntilDestroyed(this.#destroyRef)).subscribe((action) => {
            if (this === action.modal || this.id === action.id) {
                if ('show' in action) {
                    this.visible = action?.show === 'toggle' ? !this.visible : action.show;
                }
            }
            else {
                if (this.visible) {
                    this.visible = false;
                }
            }
        });
    }
    setBackdrop(setBackdrop) {
        this.#activeBackdrop = setBackdrop
            ? this.#backdropService.setBackdrop('modal')
            : this.#backdropService.clearBackdrop(this.#activeBackdrop);
    }
    setBodyStyles(open) {
        if (open) {
            if (this.backdrop() === true) {
                this.#renderer.addClass(this.#document.body, 'modal-open');
            }
        }
        else {
            this.#renderer.removeClass(this.#document.body, 'modal-open');
        }
    }
    setStaticBackdrop() {
        if (this.transition()) {
            this.#renderer.addClass(this.#hostElement.nativeElement, 'modal-static');
            this.#renderer.setStyle(this.#hostElement.nativeElement, 'overflow-y', 'hidden');
            setTimeout(() => {
                this.#renderer.removeClass(this.#hostElement.nativeElement, 'modal-static');
                this.#renderer.removeStyle(this.#hostElement.nativeElement, 'overflow-y');
            }, 300);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ModalComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "19.2.2", type: ModalComponent, isStandalone: true, selector: "c-modal", inputs: { alignment: { classPropertyName: "alignment", publicName: "alignment", isSignal: true, isRequired: false, transformFunction: null }, backdrop: { classPropertyName: "backdrop", publicName: "backdrop", isSignal: true, isRequired: false, transformFunction: null }, fullscreen: { classPropertyName: "fullscreen", publicName: "fullscreen", isSignal: true, isRequired: false, transformFunction: null }, keyboard: { classPropertyName: "keyboard", publicName: "keyboard", isSignal: true, isRequired: false, transformFunction: null }, attrId: { classPropertyName: "attrId", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, size: { classPropertyName: "size", publicName: "size", isSignal: true, isRequired: false, transformFunction: null }, transition: { classPropertyName: "transition", publicName: "transition", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null }, ariaModalInput: { classPropertyName: "ariaModalInput", publicName: "ariaModal", isSignal: true, isRequired: false, transformFunction: null }, scrollable: { classPropertyName: "scrollable", publicName: "scrollable", isSignal: true, isRequired: false, transformFunction: null }, visibleInput: { classPropertyName: "visibleInput", publicName: "visible", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { visibleChange: "visibleChange" }, host: { listeners: { "@showHide.start": "animateStart($event)", "@showHide.done": "animateDone($event)", "mousedown": "onMouseDownHandler($event)", "click": "onClickHandler($event)", "document:keyup": "onKeyUpHandler($event)" }, properties: { "class": "hostClasses()", "attr.role": "role()", "attr.inert": "ariaHidden", "attr.id": "id", "attr.aria-modal": "ariaModal()", "attr.tabindex": "-1", "@showHide": "animateTrigger()" }, classAttribute: "modal" }, viewQueries: [{ propertyName: "modalContentRef", first: true, predicate: ["modalContentRef"], descendants: true, read: ElementRef, isSignal: true }], exportAs: ["cModal"], ngImport: i0, template: "<c-modal-dialog\n  [alignment]=\"alignment()\"\n  [fullscreen]=\"fullscreen()\"\n  [scrollable]=\"scrollable()\"\n  [size]=\"size()\">\n  <c-modal-content>\n    <div [cdkTrapFocus]=\"visible\" [cdkTrapFocusAutoCapture]=\"visible\" style=\"display: contents;\" #modalContentRef>\n      <ng-content />\n    </div>\n  </c-modal-content>\n</c-modal-dialog>\n", dependencies: [{ kind: "component", type: ModalDialogComponent, selector: "c-modal-dialog", inputs: ["alignment", "fullscreen", "scrollable", "size"] }, { kind: "component", type: ModalContentComponent, selector: "c-modal-content" }, { kind: "ngmodule", type: A11yModule }, { kind: "directive", type: i1$1.CdkTrapFocus, selector: "[cdkTrapFocus]", inputs: ["cdkTrapFocus", "cdkTrapFocusAutoCapture"], exportAs: ["cdkTrapFocus"] }], animations: [
            trigger('showHide', [
                state('visible', style({
                // display: 'block'
                })),
                state('hidden', style({
                // display: 'none'
                })),
                transition('visible <=> *', [animate('150ms')])
            ])
        ] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ModalComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-modal', animations: [
                        trigger('showHide', [
                            state('visible', style({
                            // display: 'block'
                            })),
                            state('hidden', style({
                            // display: 'none'
                            })),
                            transition('visible <=> *', [animate('150ms')])
                        ])
                    ], exportAs: 'cModal', imports: [ModalDialogComponent, ModalContentComponent, A11yModule], host: {
                        class: 'modal',
                        '[class]': 'hostClasses()',
                        '[attr.role]': 'role()',
                        '[attr.inert]': 'ariaHidden',
                        '[attr.id]': 'id',
                        '[attr.aria-modal]': 'ariaModal()',
                        '[attr.tabindex]': '-1',
                        '[@showHide]': 'animateTrigger()',
                        '(@showHide.start)': 'animateStart($event)',
                        '(@showHide.done)': 'animateDone($event)',
                        '(mousedown)': 'onMouseDownHandler($event)',
                        '(click)': 'onClickHandler($event)',
                        '(document:keyup)': 'onKeyUpHandler($event)'
                    }, template: "<c-modal-dialog\n  [alignment]=\"alignment()\"\n  [fullscreen]=\"fullscreen()\"\n  [scrollable]=\"scrollable()\"\n  [size]=\"size()\">\n  <c-modal-content>\n    <div [cdkTrapFocus]=\"visible\" [cdkTrapFocusAutoCapture]=\"visible\" style=\"display: contents;\" #modalContentRef>\n      <ng-content />\n    </div>\n  </c-modal-content>\n</c-modal-dialog>\n" }]
        }] });

class ModalModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ModalModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: ModalModule, imports: [ModalBodyComponent,
            ModalComponent,
            ModalContentComponent,
            ModalDialogComponent,
            ModalFooterComponent,
            ModalHeaderComponent,
            ModalTitleDirective,
            ModalToggleDirective], exports: [ModalBodyComponent,
            ModalComponent,
            ModalContentComponent,
            ModalDialogComponent,
            ModalFooterComponent,
            ModalHeaderComponent,
            ModalTitleDirective,
            ModalToggleDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ModalModule, providers: [ModalService], imports: [ModalComponent] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ModalModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [
                        ModalBodyComponent,
                        ModalComponent,
                        ModalContentComponent,
                        ModalDialogComponent,
                        ModalFooterComponent,
                        ModalHeaderComponent,
                        ModalTitleDirective,
                        ModalToggleDirective
                    ],
                    imports: [
                        ModalBodyComponent,
                        ModalComponent,
                        ModalContentComponent,
                        ModalDialogComponent,
                        ModalFooterComponent,
                        ModalHeaderComponent,
                        ModalTitleDirective,
                        ModalToggleDirective
                    ],
                    providers: [ModalService]
                }]
        }] });

class OffcanvasService {
    constructor() {
        this.offcanvasState = new Subject();
        this.offcanvasState$ = this.offcanvasState.asObservable();
    }
    toggle(action) {
        this.offcanvasState.next(action);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: OffcanvasService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: OffcanvasService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: OffcanvasService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

let nextId$1 = 0;
class OffcanvasComponent {
    constructor() {
        this.#document = inject(DOCUMENT);
        this.#platformId = inject(PLATFORM_ID);
        this.#renderer = inject(Renderer2);
        this.#hostElement = inject(ElementRef);
        this.#offcanvasService = inject(OffcanvasService);
        this.#backdropService = inject(BackdropService);
        this.#breakpointObserver = inject(BreakpointObserver);
        this.#destroyRef = inject(DestroyRef);
        /**
         * Apply a backdrop on body while offcanvas is open.
         * @return boolean | 'static'
         * @default true
         */
        this.backdrop = input(true);
        /**
         * Closes the offcanvas when escape key is pressed [docs]
         * @return boolean
         * @default true
         */
        this.keyboard = input(true, { transform: booleanAttribute });
        /**
         * Components placement, there’s no default placement.
         * @return {'start' | 'end' | 'top' | 'bottom'}
         * @default 'start'
         */
        this.placement = input('start');
        /**
         * Responsive offcanvas property hides content outside the viewport from a specified breakpoint and down.
         * @return boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl';
         * @default true
         * @since 4.3.10
         */
        this.responsive = input(true);
        this.id = input(`offcanvas-${this.placement()}-${nextId$1++}`);
        /**
         * Default role for offcanvas. [docs]
         * @return string
         * @default 'dialog'
         */
        this.role = input('dialog');
        /**
         * Set aria-modal html attr for offcanvas. [docs]
         * @return boolean
         * @default true
         */
        this.ariaModal = input(true, { transform: booleanAttribute });
        /**
         * Allow body scrolling while offcanvas is visible.
         * @return boolean
         * @default false
         */
        this.scroll = input(false, { transform: booleanAttribute });
        /**
         * Toggle the visibility of offcanvas component.
         * @return boolean
         * @default false
         */
        this.visibleInput = input(false, { transform: booleanAttribute, alias: 'visible' });
        this.visible = linkedSignal({
            source: this.visibleInput,
            computation: (value) => value
        });
        this.visibleEffect = effect(() => {
            const visible = this.visible();
            if (visible) {
                this.setBackdrop(this.backdrop());
                this.setFocus();
            }
            else {
                this.setBackdrop(false);
            }
            this.layoutChangeSubscribe(visible);
            this.visibleChange.emit(visible);
        });
        /**
         * Event triggered on visible change.
         * @return <boolean>
         */
        this.visibleChange = output();
        this.hostClasses = computed(() => {
            const responsive = this.responsive();
            const placement = this.placement();
            const visible = this.visible();
            return {
                offcanvas: typeof responsive === 'boolean',
                [`offcanvas-${responsive}`]: typeof responsive !== 'boolean',
                [`offcanvas-${placement}`]: !!placement,
                show: visible
            };
        });
        this.ariaHidden = computed(() => {
            return this.visible() ? null : true;
        });
    }
    #document;
    #platformId;
    #renderer;
    #hostElement;
    #offcanvasService;
    #backdropService;
    #breakpointObserver;
    #destroyRef;
    #activeBackdrop;
    #backdropClickSubscription;
    #layoutChangeSubscription;
    get tabIndex() {
        return '-1';
    }
    get show() {
        return this.visible();
    }
    set show(value) {
        this.visible.set(value);
    }
    get responsiveBreakpoint() {
        const responsive = this.responsive();
        if (typeof responsive !== 'string') {
            return false;
        }
        const element = this.#document.documentElement;
        const breakpointValue = this.#document.defaultView
            ?.getComputedStyle(element)
            ?.getPropertyValue(`--cui-breakpoint-${responsive.trim()}`) ?? false;
        return breakpointValue ? `${parseFloat(breakpointValue.trim()) - 0.02}px` : false;
    }
    animateStart(event) {
        if (event.toState === 'visible') {
            if (!this.scroll()) {
                this.#backdropService.hideScrollbar();
            }
            this.#renderer.addClass(this.#hostElement.nativeElement, 'showing');
        }
        else {
            this.#renderer.addClass(this.#hostElement.nativeElement, 'hiding');
        }
    }
    animateDone(event) {
        setTimeout(() => {
            if (event.toState === 'visible') {
                this.#renderer.removeClass(this.#hostElement.nativeElement, 'showing');
            }
            if (event.toState === 'hidden') {
                this.#renderer.removeClass(this.#hostElement.nativeElement, 'hiding');
                this.#renderer.removeStyle(this.#document.body, 'overflow');
                this.#renderer.removeStyle(this.#document.body, 'paddingRight');
            }
        });
        this.show = this.visible();
    }
    onKeyDownHandler(event) {
        if (event.key === 'Escape' && this.keyboard() && this.visible() && this.backdrop() !== 'static') {
            this.#offcanvasService.toggle({ show: false, id: this.id() });
        }
    }
    ngOnInit() {
        this.stateToggleSubscribe();
        setTimeout(() => {
            // hotfix to avoid offcanvas flicker on the first render
            this.#renderer.setStyle(this.#hostElement.nativeElement, 'display', 'flex');
        });
    }
    ngOnDestroy() {
        this.#offcanvasService.toggle({ show: false, id: this.id() });
    }
    setFocus() {
        if (isPlatformBrowser(this.#platformId)) {
            setTimeout(() => this.#hostElement.nativeElement.focus());
        }
    }
    stateToggleSubscribe() {
        this.#offcanvasService.offcanvasState$.pipe(takeUntilDestroyed(this.#destroyRef)).subscribe((action) => {
            if (this === action.offcanvas || this.id() === action.id) {
                if ('show' in action) {
                    this.visible.update((value) => (action?.show === 'toggle' ? !value : action.show));
                }
            }
        });
    }
    backdropClickSubscribe(subscribe = true) {
        if (subscribe) {
            this.#backdropClickSubscription = this.#backdropService.backdropClick$
                .pipe(takeUntilDestroyed(this.#destroyRef))
                .subscribe((clicked) => {
                this.#offcanvasService.toggle({ show: !clicked, id: this.id() });
            });
        }
        else {
            this.#backdropClickSubscription?.unsubscribe();
        }
    }
    setBackdrop(setBackdrop) {
        this.#activeBackdrop = !!setBackdrop
            ? this.#backdropService.setBackdrop('offcanvas')
            : this.#backdropService.clearBackdrop(this.#activeBackdrop);
        setBackdrop === true ? this.backdropClickSubscribe() : this.backdropClickSubscribe(false);
    }
    layoutChangeSubscribe(subscribe = true) {
        if (subscribe) {
            if (!this.responsiveBreakpoint) {
                return;
            }
            const responsiveBreakpoint = `(max-width: ${this.responsiveBreakpoint})`;
            const layoutChanges = this.#breakpointObserver.observe([responsiveBreakpoint]);
            this.#layoutChangeSubscription = layoutChanges
                .pipe(filter((breakpointState) => !breakpointState.matches), takeUntilDestroyed(this.#destroyRef))
                .subscribe((breakpointState) => {
                this.visible.set(breakpointState.matches);
            });
        }
        else {
            this.#layoutChangeSubscription?.unsubscribe();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: OffcanvasComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: OffcanvasComponent, isStandalone: true, selector: "c-offcanvas", inputs: { backdrop: { classPropertyName: "backdrop", publicName: "backdrop", isSignal: true, isRequired: false, transformFunction: null }, keyboard: { classPropertyName: "keyboard", publicName: "keyboard", isSignal: true, isRequired: false, transformFunction: null }, placement: { classPropertyName: "placement", publicName: "placement", isSignal: true, isRequired: false, transformFunction: null }, responsive: { classPropertyName: "responsive", publicName: "responsive", isSignal: true, isRequired: false, transformFunction: null }, id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null }, ariaModal: { classPropertyName: "ariaModal", publicName: "ariaModal", isSignal: true, isRequired: false, transformFunction: null }, scroll: { classPropertyName: "scroll", publicName: "scroll", isSignal: true, isRequired: false, transformFunction: null }, visibleInput: { classPropertyName: "visibleInput", publicName: "visible", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { visibleChange: "visibleChange" }, host: { attributes: { "ngSkipHydration": "true" }, listeners: { "@showHide.start": "animateStart($event)", "@showHide.done": "animateDone($event)", "document:keydown": "onKeyDownHandler($event)" }, properties: { "@showHide": "this.visible() ? \"visible\" : \"hidden\"", "attr.id": "id()", "attr.inert": "ariaHidden() || null", "attr.role": "role()", "attr.aria-modal": "ariaModal()", "attr.tabindex": "tabIndex", "class": "hostClasses()" } }, exportAs: ["cOffcanvas"], hostDirectives: [{ directive: ThemeDirective, inputs: ["dark", "dark"] }], ngImport: i0, template: "<div cdkTrapFocus cdkTrapFocusAutoCapture>\n  <ng-content />\n</div>\n\n", styles: [":host{display:none}\n"], dependencies: [{ kind: "ngmodule", type: A11yModule }, { kind: "directive", type: i1$1.CdkTrapFocus, selector: "[cdkTrapFocus]", inputs: ["cdkTrapFocus", "cdkTrapFocusAutoCapture"], exportAs: ["cdkTrapFocus"] }], animations: [
            trigger('showHide', [
                state('visible', style({
                // visibility: 'visible'
                })),
                state('hidden', style({
                // visibility: 'hidden'
                })),
                transition('visible <=> *', [animate('300ms')])
            ])
        ] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: OffcanvasComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-offcanvas', animations: [
                        trigger('showHide', [
                            state('visible', style({
                            // visibility: 'visible'
                            })),
                            state('hidden', style({
                            // visibility: 'hidden'
                            })),
                            transition('visible <=> *', [animate('300ms')])
                        ])
                    ], exportAs: 'cOffcanvas', imports: [A11yModule], hostDirectives: [{ directive: ThemeDirective, inputs: ['dark'] }], host: {
                        ngSkipHydration: 'true',
                        '[@showHide]': 'this.visible() ? "visible" : "hidden"',
                        '[attr.id]': 'id()',
                        '[attr.inert]': 'ariaHidden() || null',
                        '[attr.role]': 'role()',
                        '[attr.aria-modal]': 'ariaModal()',
                        '[attr.tabindex]': 'tabIndex',
                        '[class]': 'hostClasses()',
                        '(@showHide.start)': 'animateStart($event)',
                        '(@showHide.done)': 'animateDone($event)',
                        '(document:keydown)': 'onKeyDownHandler($event)'
                    }, template: "<div cdkTrapFocus cdkTrapFocusAutoCapture>\n  <ng-content />\n</div>\n\n", styles: [":host{display:none}\n"] }]
        }] });

class OffcanvasBodyComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: OffcanvasBodyComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: OffcanvasBodyComponent, isStandalone: true, selector: "c-offcanvas-body", host: { classAttribute: "offcanvas-body" }, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: OffcanvasBodyComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-offcanvas-body', template: '<ng-content />', host: { class: 'offcanvas-body' }, styles: [":host{display:block}\n"] }]
        }] });

class OffcanvasHeaderComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: OffcanvasHeaderComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: OffcanvasHeaderComponent, isStandalone: true, selector: "c-offcanvas-header", host: { classAttribute: "offcanvas-header" }, ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: OffcanvasHeaderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-offcanvas-header',
                    template: '<ng-content />',
                    host: { class: 'offcanvas-header' }
                }]
        }] });

class OffcanvasTitleDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: OffcanvasTitleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.2", type: OffcanvasTitleDirective, isStandalone: true, selector: "[cOffcanvasTitle]", host: { classAttribute: "offcanvas-title" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: OffcanvasTitleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cOffcanvasTitle]',
                    host: { class: 'offcanvas-title' }
                }]
        }] });

class OffcanvasToggleDirective {
    constructor() {
        this.#offcanvasService = inject(OffcanvasService);
        /**
         * Html id attr of offcanvas to toggle.
         * @return string
         */
        this.id = input(undefined, { alias: 'cOffcanvasToggle' });
    }
    #offcanvasService;
    toggleOpen($event) {
        $event.preventDefault();
        this.#offcanvasService.toggle({ show: 'toggle', id: this.id() });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: OffcanvasToggleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: OffcanvasToggleDirective, isStandalone: true, selector: "[cOffcanvasToggle]", inputs: { id: { classPropertyName: "id", publicName: "cOffcanvasToggle", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "toggleOpen($event)" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: OffcanvasToggleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cOffcanvasToggle]',
                    host: {
                        '(click)': 'toggleOpen($event)'
                    }
                }]
        }] });

class OffcanvasModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: OffcanvasModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: OffcanvasModule, imports: [OffcanvasBodyComponent,
            OffcanvasComponent,
            OffcanvasHeaderComponent,
            OffcanvasTitleDirective,
            OffcanvasToggleDirective], exports: [OffcanvasBodyComponent,
            OffcanvasComponent,
            OffcanvasHeaderComponent,
            OffcanvasTitleDirective,
            OffcanvasToggleDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: OffcanvasModule, providers: [
            OffcanvasService,
            BackdropService
        ], imports: [OffcanvasComponent] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: OffcanvasModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [
                        OffcanvasBodyComponent,
                        OffcanvasComponent,
                        OffcanvasHeaderComponent,
                        OffcanvasTitleDirective,
                        OffcanvasToggleDirective
                    ],
                    imports: [
                        OffcanvasBodyComponent,
                        OffcanvasComponent,
                        OffcanvasHeaderComponent,
                        OffcanvasTitleDirective,
                        OffcanvasToggleDirective
                    ],
                    providers: [
                        OffcanvasService,
                        BackdropService
                    ]
                }]
        }] });

class PageLinkDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PageLinkDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.2", type: PageLinkDirective, isStandalone: true, selector: "[cPageLink]", host: { classAttribute: "page-link" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PageLinkDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cPageLink]',
                    host: { class: 'page-link' }
                }]
        }] });

class PageItemDirective {
    constructor() {
        this.#renderer = inject(Renderer2);
        /**
         * Toggle the active state for the component.
         * @return boolean
         */
        this.active = input();
        /**
         * Toggle the disabled state for the component.
         * @return boolean
         */
        this.disabled = input();
        this.ariaCurrent = computed(() => {
            return this.active() ? 'page' : null;
        });
        this.hostClasses = computed(() => {
            return {
                'page-item': true,
                disabled: this.disabled(),
                active: this.active()
            };
        });
        this.pageLinkElementRef = contentChild(PageLinkDirective, { read: ElementRef });
        this.pageLinkElementRefEffect = effect(() => {
            const pageLinkElementRef = this.pageLinkElementRef();
            const disabled = this.disabled();
            if (!pageLinkElementRef) {
                return;
            }
            const pageLinkElement = pageLinkElementRef.nativeElement;
            if (disabled) {
                this.#renderer.setAttribute(pageLinkElement, 'aria-disabled', 'true');
                this.#renderer.setAttribute(pageLinkElement, 'tabindex', '-1');
            }
            else {
                this.#renderer.removeAttribute(pageLinkElement, 'aria-disabled');
                this.#renderer.removeAttribute(pageLinkElement, 'tabindex');
            }
        });
    }
    #renderer;
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PageItemDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.2.0", version: "19.2.2", type: PageItemDirective, isStandalone: true, selector: "[cPageItem]", inputs: { active: { classPropertyName: "active", publicName: "active", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.aria-current": "ariaCurrent()" }, classAttribute: "page-item" }, queries: [{ propertyName: "pageLinkElementRef", first: true, predicate: PageLinkDirective, descendants: true, read: ElementRef, isSignal: true }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PageItemDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cPageItem]',
                    host: {
                        class: 'page-item',
                        '[class]': 'hostClasses()',
                        '[attr.aria-current]': 'ariaCurrent()'
                    }
                }]
        }] });

class PageItemComponent extends PageItemDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PageItemComponent, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: PageItemComponent, isStandalone: true, selector: "c-page-item", usesInheritance: true, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:list-item;text-align:-webkit-match-parent;text-align:match-parent}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PageItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-page-item', template: '<ng-content />', styles: [":host{display:list-item;text-align:-webkit-match-parent;text-align:match-parent}\n"] }]
        }] });

class PaginationComponent {
    constructor() {
        /**
         * Set the alignment of pagination components.
         * @values 'start', 'center', 'end'
         */
        this.align = input('');
        /**
         * Size the component small or large.
         * @values 'sm', 'lg'
         */
        this.size = input();
        /**
         * Default role for pagination. [docs]
         * @return string
         * @default 'navigation'
         */
        this.role = input('navigation');
        this.paginationClass = computed(() => {
            const size = this.size();
            const align = this.align();
            return {
                pagination: true,
                [`pagination-${size}`]: !!size,
                [`justify-content-${align}`]: !!align
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PaginationComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: PaginationComponent, isStandalone: true, selector: "c-pagination", inputs: { align: { classPropertyName: "align", publicName: "align", isSignal: true, isRequired: false, transformFunction: null }, size: { classPropertyName: "size", publicName: "size", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.role": "role()" } }, ngImport: i0, template: "<ul [ngClass]=\"paginationClass()\">\n  <ng-content />\n</ul>\n", dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PaginationComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-pagination', imports: [NgClass], host: {
                        '[attr.role]': 'role()'
                    }, template: "<ul [ngClass]=\"paginationClass()\">\n  <ng-content />\n</ul>\n" }]
        }] });

class PaginationModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PaginationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: PaginationModule, imports: [PageItemComponent,
            PageItemDirective,
            PageLinkDirective,
            PaginationComponent], exports: [PageItemComponent,
            PageItemDirective,
            PageLinkDirective,
            PaginationComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PaginationModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PaginationModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [
                        PageItemComponent,
                        PageItemDirective,
                        PageLinkDirective,
                        PaginationComponent
                    ],
                    imports: [
                        PageItemComponent,
                        PageItemDirective,
                        PageLinkDirective,
                        PaginationComponent
                    ]
                }]
        }] });

class PlaceholderDirective {
    constructor() {
        /**
         * placeholder toggler
         * @type boolean
         * @default false
         */
        this.visible = input(false, {
            transform: booleanAttribute,
            alias: 'cPlaceholder'
        });
        /**
         * Size the placeholder xs, small, large.
         */
        this.size = input(undefined, { alias: 'cPlaceholderSize' });
        this.ariaHidden = computed(() => {
            return this.visible() ? null : true;
        });
        this.hostClasses = computed(() => {
            return {
                placeholder: this.visible(),
                [`placeholder-${this.size()}`]: !!this.size()
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PlaceholderDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: PlaceholderDirective, isStandalone: true, selector: "[cPlaceholder]", inputs: { visible: { classPropertyName: "visible", publicName: "cPlaceholder", isSignal: true, isRequired: false, transformFunction: null }, size: { classPropertyName: "size", publicName: "cPlaceholderSize", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.aria-hidden": "ariaHidden()" } }, exportAs: ["cPlaceholder"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PlaceholderDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cPlaceholder]',
                    exportAs: 'cPlaceholder',
                    host: {
                        '[class]': 'hostClasses()',
                        '[attr.aria-hidden]': 'ariaHidden()'
                    }
                }]
        }] });

class PlaceholderAnimationDirective {
    constructor() {
        /**
         * Animation type for placeholder
         * @type 'glow' | 'wave'
         * @default undefined
         */
        this.animation = input(undefined, {
            alias: 'cPlaceholderAnimation'
        });
        this.placeholder = contentChild(PlaceholderDirective);
        this.hostClasses = computed(() => {
            return {
                [`placeholder-${this.animation()}`]: this.placeholder()?.visible() && !!this.animation()
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PlaceholderAnimationDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.2.0", version: "19.2.2", type: PlaceholderAnimationDirective, isStandalone: true, selector: "[cPlaceholderAnimation]", inputs: { animation: { classPropertyName: "animation", publicName: "cPlaceholderAnimation", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, queries: [{ propertyName: "placeholder", first: true, predicate: PlaceholderDirective, descendants: true, isSignal: true }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PlaceholderAnimationDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cPlaceholderAnimation]',
                    host: {
                        '[class]': 'hostClasses()'
                    }
                }]
        }] });

class PlaceholderModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PlaceholderModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: PlaceholderModule, imports: [PlaceholderDirective,
            PlaceholderAnimationDirective], exports: [PlaceholderDirective,
            PlaceholderAnimationDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PlaceholderModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PlaceholderModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        PlaceholderDirective,
                        PlaceholderAnimationDirective
                    ],
                    exports: [
                        PlaceholderDirective,
                        PlaceholderAnimationDirective
                    ]
                }]
        }] });

class PopoverComponent {
    constructor() {
        this.renderer = inject(Renderer2);
        /**
         * Content of popover
         * @return {string | TemplateRef}
         */
        this.content = input('');
        this.#contentEffect = effect(() => {
            this.updateView(this.content());
        });
        /**
         * Toggle the visibility of popover component.
         * @return boolean
         */
        this.visible = input(false, { transform: booleanAttribute });
        this.id = input();
        this.role = input('tooltip');
        this.viewContainerRef = viewChild('popoverTemplate', { read: ViewContainerRef });
        this.hostClasses = computed(() => {
            return {
                popover: true,
                fade: true,
                show: this.visible(),
                'bs-popover-auto': true
            };
        });
    }
    #contentEffect;
    ngOnDestroy() {
        this.clear();
    }
    clear() {
        this.viewContainerRef()?.clear();
        if (!!this.textNode) {
            this.renderer.removeChild(this.textNode.parentNode, this.textNode);
        }
    }
    updateView(content) {
        this.clear();
        if (!content) {
            return;
        }
        if (content instanceof TemplateRef) {
            this.viewContainerRef()?.createEmbeddedView(content);
        }
        else {
            const textNodeContent = this.renderer.createText(content);
            this.textNode = this.renderer.createElement('div');
            this.renderer.addClass(this.textNode, 'popover-body');
            this.renderer.appendChild(this.textNode, textNodeContent);
            const element = this.viewContainerRef()?.element.nativeElement;
            this.renderer.appendChild(element.parentNode, this.textNode);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PopoverComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "19.2.2", type: PopoverComponent, isStandalone: true, selector: "c-popover", inputs: { content: { classPropertyName: "content", publicName: "content", isSignal: true, isRequired: false, transformFunction: null }, visible: { classPropertyName: "visible", publicName: "visible", isSignal: true, isRequired: false, transformFunction: null }, id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.role": "role()", "attr.id": "id()" }, classAttribute: "popover fade bs-popover-auto" }, viewQueries: [{ propertyName: "viewContainerRef", first: true, predicate: ["popoverTemplate"], descendants: true, read: ViewContainerRef, isSignal: true }], ngImport: i0, template: "<ng-container>\n  <div [ngClass]=\"{'popover-arrow': !!content()}\" data-popper-arrow></div>\n  <ng-container #popoverTemplate />\n</ng-container>\n", dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PopoverComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-popover', imports: [NgClass], host: {
                        class: 'popover fade bs-popover-auto',
                        '[class]': 'hostClasses()',
                        '[attr.role]': 'role()',
                        '[attr.id]': 'id()'
                    }, template: "<ng-container>\n  <div [ngClass]=\"{'popover-arrow': !!content()}\" data-popper-arrow></div>\n  <ng-container #popoverTemplate />\n</ng-container>\n" }]
        }] });

class PopoverDirective {
    constructor() {
        this.#renderer = inject(Renderer2);
        this.#hostElement = inject(ElementRef);
        this.#viewContainerRef = inject(ViewContainerRef);
        this.#listenersService = inject(ListenersService);
        this.#changeDetectorRef = inject(ChangeDetectorRef);
        this.#intersectionService = inject(IntersectionService);
        this.#destroyRef = inject(DestroyRef);
        this.#document = inject(DOCUMENT);
        /**
         * Content of popover
         * @return {string | TemplateRef}
         */
        this.content = input(undefined, { alias: 'cPopover' });
        this.#contentEffect = effect(() => {
            if (this.content()) {
                this.destroyTooltipElement();
            }
        });
        /**
         * Optional popper Options object, takes precedence over cPopoverPlacement prop
         * @return Partial<Options>
         */
        this.popperOptions = input({}, { alias: 'cPopoverOptions' });
        this.#popperOptionsEffect = effect(() => {
            this._popperOptions = {
                ...this._popperOptions,
                placement: this.placement(),
                ...this.popperOptions()
            };
        });
        this.popperOptionsComputed = computed(() => {
            return { placement: this.placement(), ...this._popperOptions };
        });
        /**
         * Describes the placement of your component after Popper.js has applied all the modifiers that may have flipped or altered the originally provided placement property.
         * @return: 'top' | 'bottom' | 'left' | 'right'
         * @default: 'top'
         */
        this.placement = input('top', { alias: 'cPopoverPlacement' });
        /**
         * ElementRefDirective for positioning the tooltip on reference element
         * @return: ElementRefDirective
         * @default: undefined
         */
        this.reference = input(undefined, { alias: 'cTooltipRef' });
        this.referenceRef = computed(() => this.reference()?.elementRef ?? this.#hostElement);
        /**
         * Sets which event handlers you’d like provided to your toggle prop. You can specify one trigger or an array of them.
         * @return: Triggers | Triggers[]
         */
        this.trigger = input('hover', { alias: 'cPopoverTrigger' });
        /**
         * Toggle the visibility of popover component.
         * @return boolean
         */
        this.visible = model(false, { alias: 'cPopoverVisible' });
        this.#visibleEffect = effect(() => {
            this.visible() ? this.addTooltipElement() : this.removeTooltipElement();
        });
        this._popperOptions = {
            modifiers: [
                {
                    name: 'offset',
                    options: {
                        offset: [0, 9]
                    }
                }
            ]
        };
    }
    #renderer;
    #hostElement;
    #viewContainerRef;
    #listenersService;
    #changeDetectorRef;
    #intersectionService;
    #destroyRef;
    #document;
    #contentEffect;
    #popperOptionsEffect;
    #visibleEffect;
    get ariaDescribedBy() {
        return this.tooltipId ? this.tooltipId : null;
    }
    ngAfterViewInit() {
        this.intersectionServiceSubscribe();
    }
    ngOnDestroy() {
        this.clearListeners();
        this.destroyTooltipElement();
    }
    ngOnInit() {
        this.setListeners();
    }
    setListeners() {
        const config = {
            hostElement: this.#hostElement,
            trigger: this.trigger(),
            callbackToggle: () => {
                this.visible.update((visible) => !visible);
            },
            callbackOff: () => {
                this.visible.set(false);
            },
            callbackOn: () => {
                this.visible.set(true);
            }
        };
        this.#listenersService.setListeners(config);
    }
    clearListeners() {
        this.#listenersService.clearListeners();
    }
    intersectionServiceSubscribe() {
        this.#intersectionService.createIntersectionObserver(this.referenceRef());
        this.#intersectionService.intersecting$
            .pipe(filter((next) => next.hostElement === this.referenceRef()), debounceTime(100), finalize(() => {
            this.#intersectionService.unobserve(this.referenceRef());
        }), takeUntilDestroyed(this.#destroyRef))
            .subscribe((next) => {
            this.visible.set(next.isIntersecting ? this.visible() : false);
        });
    }
    getUID(prefix) {
        let uid = prefix ?? 'random-id';
        do {
            uid = `${prefix}-${Math.floor(Math.random() * 1000000).toString(10)}`;
        } while (this.#document.getElementById(uid));
        return uid;
    }
    createTooltipElement() {
        if (!this.tooltipRef) {
            this.tooltipRef = this.#viewContainerRef.createComponent(PopoverComponent);
            // this.viewContainerRef.detach();
        }
    }
    destroyTooltipElement() {
        this.tooltip?.remove();
        this.tooltipRef?.destroy();
        // @ts-ignore
        this.tooltipRef = undefined;
        this.popperInstance?.destroy();
        this.#viewContainerRef?.detach();
        this.#viewContainerRef?.clear();
    }
    addTooltipElement() {
        if (!this.content()) {
            this.destroyTooltipElement();
            return;
        }
        if (!this.tooltipRef) {
            this.createTooltipElement();
        }
        this.tooltipRef?.setInput('content', this.content() ?? '');
        this.tooltip = this.tooltipRef?.location.nativeElement;
        this.#renderer.addClass(this.tooltip, 'd-none');
        this.#renderer.addClass(this.tooltip, 'fade');
        this.popperInstance?.destroy();
        this.#viewContainerRef.insert(this.tooltipRef.hostView);
        this.#renderer.appendChild(this.#document.body, this.tooltip);
        this.popperInstance = createPopper(this.referenceRef().nativeElement, this.tooltip, {
            ...this.popperOptionsComputed()
        });
        if (!this.visible()) {
            this.removeTooltipElement();
            return;
        }
        setTimeout(() => {
            this.tooltipId = this.getUID('popover');
            this.tooltipRef?.setInput('id', this.tooltipId);
            this.#renderer.removeClass(this.tooltip, 'd-none');
            this.tooltipRef?.setInput('visible', this.visible());
            this.popperInstance?.forceUpdate();
            this.#changeDetectorRef?.markForCheck();
        }, 100);
    }
    removeTooltipElement() {
        this.tooltipId = '';
        if (!this.tooltipRef) {
            return;
        }
        this.tooltipRef.setInput('visible', false);
        this.tooltipRef.setInput('id', undefined);
        this.#changeDetectorRef.markForCheck();
        setTimeout(() => {
            this.#viewContainerRef?.detach();
        }, 300);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PopoverDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: PopoverDirective, isStandalone: true, selector: "[cPopover]", inputs: { content: { classPropertyName: "content", publicName: "cPopover", isSignal: true, isRequired: false, transformFunction: null }, popperOptions: { classPropertyName: "popperOptions", publicName: "cPopoverOptions", isSignal: true, isRequired: false, transformFunction: null }, placement: { classPropertyName: "placement", publicName: "cPopoverPlacement", isSignal: true, isRequired: false, transformFunction: null }, reference: { classPropertyName: "reference", publicName: "cTooltipRef", isSignal: true, isRequired: false, transformFunction: null }, trigger: { classPropertyName: "trigger", publicName: "cPopoverTrigger", isSignal: true, isRequired: false, transformFunction: null }, visible: { classPropertyName: "visible", publicName: "cPopoverVisible", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { visible: "cPopoverVisibleChange" }, host: { properties: { "attr.aria-describedby": "ariaDescribedBy" } }, providers: [ListenersService, IntersectionService], exportAs: ["cPopover"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PopoverDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cPopover]',
                    exportAs: 'cPopover',
                    providers: [ListenersService, IntersectionService],
                    host: { '[attr.aria-describedby]': 'ariaDescribedBy' }
                }]
        }] });

class PopoverModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PopoverModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: PopoverModule, imports: [PopoverDirective,
            PopoverComponent], exports: [PopoverDirective,
            PopoverComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PopoverModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: PopoverModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [
                        PopoverDirective,
                        PopoverComponent
                    ],
                    imports: [
                        PopoverDirective,
                        PopoverComponent
                    ]
                }]
        }] });

class ProgressService {
    constructor() {
        this.stacked = signal(false);
        this.value = signal(undefined);
        this.precision = signal(0);
        this.min = signal(0);
        this.max = signal(100);
        this.percent = computed(() => {
            return +((((this.value() ?? 0) - this.min()) / (this.max() - this.min())) * 100).toFixed(this.precision());
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ProgressService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ProgressService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ProgressService, decorators: [{
            type: Injectable
        }] });

class ProgressBarDirective {
    constructor() {
        this.#renderer = inject(Renderer2);
        this.#hostElement = inject(ElementRef);
        this.#progressService = inject(ProgressService);
        this.#valuesEffect = effect(() => {
            const host = this.#hostElement.nativeElement;
            const value = this.#progressService.value();
            const percent = this.#progressService.percent();
            const stacked = this.#progressService.stacked();
            if (value === undefined) {
                for (const name of ['aria-valuenow', 'aria-valuemax', 'aria-valuemin', 'role']) {
                    this.#renderer.removeAttribute(host, name);
                }
            }
            else {
                const { min, max } = this.#progressService;
                this.#renderer.setAttribute(host, 'aria-valuenow', String(value));
                this.#renderer.setAttribute(host, 'aria-valuemin', String(min()));
                this.#renderer.setAttribute(host, 'aria-valuemax', String(max()));
                this.#renderer.setAttribute(host, 'role', this.role());
            }
            const tagName = host.tagName;
            if (percent >= 0 && ((stacked && tagName === 'C-PROGRESS') || (!stacked && tagName !== 'C-PROGRESS'))) {
                this.#renderer.setStyle(host, 'width', `${percent}%`);
            }
            else {
                this.#renderer.removeStyle(host, 'width');
            }
        });
        /**
         * Use to animate the stripes right to left via CSS3 animations.
         * @return boolean
         */
        this.animated = input(undefined, { transform: booleanAttribute });
        /**
         * Sets the color context of the component to one of CoreUI’s themed colors.
         * @values 'primary', 'secondary', 'success', 'danger', 'warning', 'info', 'dark', 'light'
         */
        this.color = input();
        this.precision = input(0, { transform: numberAttribute });
        /**
         * The percent value the ProgressBar.
         * @return number
         * @default 0
         */
        this.value = input(0, { transform: numberAttribute });
        /**
         * Set the progress bar variant to optional striped.
         * @values 'striped'
         * @default undefined
         */
        this.variant = input();
        /**
         * The max value of the ProgressBar.
         * @return number
         * @default 100
         */
        this.max = input(100, { transform: numberAttribute });
        /**
         * Set default html role attribute.
         * @return string
         */
        this.role = input('progressbar');
        this.#serviceEffect = effect(() => {
            this.#progressService.precision.set(this.precision());
            const max = this.max();
            this.#progressService.max.set(isNaN(max) || max <= 0 ? 100 : max);
            const value = this.value();
            this.#progressService.value.set(value && !isNaN(value) ? value : undefined);
        });
    }
    #renderer;
    #hostElement;
    #progressService;
    #valuesEffect;
    #serviceEffect;
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ProgressBarDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: ProgressBarDirective, isStandalone: true, selector: "[cProgressBar]", inputs: { animated: { classPropertyName: "animated", publicName: "animated", isSignal: true, isRequired: false, transformFunction: null }, color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null }, precision: { classPropertyName: "precision", publicName: "precision", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "value", isSignal: true, isRequired: false, transformFunction: null }, variant: { classPropertyName: "variant", publicName: "variant", isSignal: true, isRequired: false, transformFunction: null }, max: { classPropertyName: "max", publicName: "max", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, exportAs: ["cProgressBar"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ProgressBarDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cProgressBar]',
                    exportAs: 'cProgressBar'
                }]
        }] });

class ProgressBarComponent {
    constructor() {
        this.#progressBarDirective = inject(ProgressBarDirective, { optional: true });
        this.hostClasses = computed(() => {
            const animated = this.#progressBarDirective?.animated();
            const color = this.#progressBarDirective?.color();
            const variant = this.#progressBarDirective?.variant();
            return {
                'progress-bar': true,
                'progress-bar-animated': !!animated,
                [`progress-bar-${variant}`]: !!variant,
                [`bg-${color}`]: !!color
            };
        });
    }
    #progressBarDirective;
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ProgressBarComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: ProgressBarComponent, isStandalone: true, selector: "c-progress-bar", host: { properties: { "class": "hostClasses()" }, classAttribute: "progress-bar" }, hostDirectives: [{ directive: ProgressBarDirective, inputs: ["animated", "animated", "color", "color", "max", "max", "role", "role", "value", "value", "variant", "variant"] }], ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ProgressBarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-progress-bar',
                    template: '<ng-content />',
                    hostDirectives: [
                        {
                            directive: ProgressBarDirective,
                            inputs: ['animated', 'color', 'max', 'role', 'value', 'variant']
                        }
                    ],
                    host: { class: 'progress-bar', '[class]': 'hostClasses()' }
                }]
        }] });

class ProgressStackedComponent {
    constructor() {
        this.stacked = input(true);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ProgressStackedComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: ProgressStackedComponent, isStandalone: true, selector: "c-progress-stacked", inputs: { stacked: { classPropertyName: "stacked", publicName: "stacked", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class.progress-stacked": "stacked()" } }, exportAs: ["cProgressStacked"], ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:flex}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ProgressStackedComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-progress-stacked', exportAs: 'cProgressStacked', template: '<ng-content />', host: { '[class.progress-stacked]': 'stacked()' }, styles: [":host{display:flex}\n"] }]
        }] });

class ProgressComponent {
    #hostElement;
    #stacked;
    #progressService;
    constructor() {
        this.#hostElement = inject(ElementRef);
        this.progressBarDirective = inject(ProgressBarDirective, {
            optional: true
        });
        this.#stacked = inject(ProgressStackedComponent, { optional: true })?.stacked() ?? false;
        this.#progressService = inject(ProgressService);
        this.stacked = this.#progressService.stacked;
        this.percent = this.#progressService.percent;
        this.value = this.#progressService.value;
        this.contentProgressBars = contentChildren(ProgressBarComponent);
        /**
         * Sets the height of the component. If you set that value the inner `<CProgressBar>` will automatically resize accordingly.
         * @return number
         */
        this.height = input(0, { transform: numberAttribute });
        /**
         * Displays thin progress.
         * @return boolean
         */
        this.thin = input(false, { transform: booleanAttribute });
        /**
         * Change the default color to white.
         * @return boolean
         */
        this.white = input(false, { transform: booleanAttribute });
        this.hostClasses = computed(() => {
            return {
                progress: true,
                'progress-thin': this.thin(),
                'progress-white': this.white()
            };
        });
        this.hostStyle = computed(() => {
            const height = this.height();
            return !!height ? `${height}px` : (this.#hostElement?.nativeElement?.style?.height ?? undefined);
        });
        this.#progressService.stacked.set(this.#stacked);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ProgressComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.2", type: ProgressComponent, isStandalone: true, selector: "c-progress", inputs: { height: { classPropertyName: "height", publicName: "height", isSignal: true, isRequired: false, transformFunction: null }, thin: { classPropertyName: "thin", publicName: "thin", isSignal: true, isRequired: false, transformFunction: null }, white: { classPropertyName: "white", publicName: "white", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "style.height": "hostStyle()" }, classAttribute: "progress" }, providers: [ProgressService], queries: [{ propertyName: "contentProgressBars", predicate: ProgressBarComponent, isSignal: true }], exportAs: ["cProgress"], hostDirectives: [{ directive: ProgressBarDirective, inputs: ["animated", "animated", "color", "color", "max", "max", "role", "role", "value", "value", "variant", "variant"] }], ngImport: i0, template: "@if (contentProgressBars()?.length) {\n  <ng-container *ngTemplateOutlet=\"defaultContent\" />\n} @else {\n  @let pbd = progressBarDirective;\n  <c-progress-bar [animated]=\"pbd?.animated()\" [variant]=\"pbd?.variant()\" [color]=\"pbd?.color()\" [value]=\"value()\">\n    <ng-container *ngTemplateOutlet=\"defaultContent\" />\n  </c-progress-bar>\n}\n\n<ng-template #defaultContent>\n  <ng-content />\n</ng-template>\n\n", styles: [":host-context(.progress-stacked).progress{transition:var(--cui-progress-bar-transition)}\n"], dependencies: [{ kind: "component", type: ProgressBarComponent, selector: "c-progress-bar" }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ProgressComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-progress', exportAs: 'cProgress', imports: [ProgressBarComponent, NgTemplateOutlet], hostDirectives: [
                        {
                            directive: ProgressBarDirective,
                            inputs: ['animated', 'color', 'max', 'role', 'value', 'variant']
                        }
                    ], host: {
                        class: 'progress',
                        '[class]': 'hostClasses()',
                        '[style.height]': 'hostStyle()'
                    }, providers: [ProgressService], template: "@if (contentProgressBars()?.length) {\n  <ng-container *ngTemplateOutlet=\"defaultContent\" />\n} @else {\n  @let pbd = progressBarDirective;\n  <c-progress-bar [animated]=\"pbd?.animated()\" [variant]=\"pbd?.variant()\" [color]=\"pbd?.color()\" [value]=\"value()\">\n    <ng-container *ngTemplateOutlet=\"defaultContent\" />\n  </c-progress-bar>\n}\n\n<ng-template #defaultContent>\n  <ng-content />\n</ng-template>\n\n", styles: [":host-context(.progress-stacked).progress{transition:var(--cui-progress-bar-transition)}\n"] }]
        }], ctorParameters: () => [] });

class ProgressModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ProgressModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: ProgressModule, imports: [ProgressComponent,
            ProgressBarComponent,
            ProgressBarDirective,
            ProgressStackedComponent], exports: [ProgressComponent,
            ProgressBarComponent,
            ProgressBarDirective,
            ProgressStackedComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ProgressModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ProgressModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [
                        ProgressComponent,
                        ProgressBarComponent,
                        ProgressBarDirective,
                        ProgressStackedComponent
                    ],
                    imports: [
                        ProgressComponent,
                        ProgressBarComponent,
                        ProgressBarDirective,
                        ProgressStackedComponent
                    ]
                }]
        }] });

class SidebarService {
    constructor() {
        this.sidebarState = new BehaviorSubject({});
        this.sidebarState$ = this.sidebarState.asObservable();
    }
    toggle(action) {
        this.sidebarState.next(action);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class SidebarBackdropService {
    #document = inject(DOCUMENT);
    #sidebarService = inject(SidebarService);
    #backdrop;
    #clickListener = () => {
        /* empty */
    };
    setBackdrop(sidebar) {
        const backdrop = this.#document.getElementsByClassName('sidebar-backdrop');
        // console.log(`sidebar-${this.id}`, ' setBackdrop', backdrop);
        if (backdrop.length === 0) {
            this.#backdrop = this.renderer.createElement('div');
            this.renderer.addClass(this.#backdrop, 'sidebar-backdrop');
            this.renderer.appendChild(this.#document.body, this.#backdrop);
            this.#clickListener = this.renderer.listen(this.#backdrop, 'click', (e) => {
                // console.log(`sidebar-${this.id}`, ' backdrop click', e);
                this.#sidebarService.toggle({ toggle: 'visible', sidebar });
            });
        }
        // console.log(this.backdrop, sidebar.sidebarState.mobile, sidebar.sidebarState.show);
        if (this.#backdrop && sidebar.sidebarState.mobile && sidebar.sidebarState.visible) {
            this.renderer.addClass(this.#backdrop, 'fade');
            this.renderer.addClass(this.#backdrop, 'show');
            // this.renderer.removeClass(this.backdrop, 'd-none');
        }
        else {
            this.renderer.removeClass(this.#backdrop, 'show');
            this.renderer.removeClass(this.#backdrop, 'fade');
            // this.renderer.addClass(this.backdrop, 'd-none');
        }
    }
    clearBackdrop() {
        if (this.#backdrop) {
            // clear backdrop click Listener
            this.#clickListener();
            // this.renderer.listen(this.backdrop, 'click', (e): void => {} );
            this.renderer.removeChild(this.#document.body, this.#backdrop);
            // @ts-ignore
            this.#backdrop = undefined;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarBackdropService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarBackdropService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarBackdropService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class SidebarComponent {
    #document;
    #renderer;
    #breakpointObserver;
    #sidebarService;
    #backdropService;
    #onMobile;
    #layoutChangeSubscription;
    #stateToggleSubscription;
    #stateInitial;
    #narrow;
    set narrow(value) {
        this.#narrow.set(value);
    }
    get narrow() {
        return this.#narrow();
    }
    #visible;
    #visibleEffect;
    set visible(value) {
        this.#visible.set(value);
    }
    get visible() {
        return this.#visible();
    }
    set sidebarState(value) {
        const newState = value;
        if ('toggle' in newState) {
            if (newState.toggle === 'visible') {
                newState.visible = !this.state().visible;
                this.#visible.set(newState.visible);
            }
            else if (newState.toggle === 'unfoldable') {
                newState.unfoldable = !this.state().unfoldable;
                this.unfoldable.set(newState.unfoldable);
            }
        }
        else {
            this.#visible.update((visible) => (newState.visible ?? visible) && !this.overlaid());
        }
        this.state.update((state) => ({ ...state, ...newState }));
        this.state().mobile && this.state().visible
            ? this.#backdropService.setBackdrop(this)
            : this.#backdropService.clearBackdrop();
    }
    get sidebarState() {
        return { ...this.state() };
    }
    get getMobileBreakpoint() {
        const element = this.#document.documentElement;
        const mobileBreakpoint = this.#document.defaultView?.getComputedStyle(element)?.getPropertyValue('--cui-mobile-breakpoint') ?? 'md';
        const breakpointValue = this.#document.defaultView
            ?.getComputedStyle(element)
            ?.getPropertyValue(`--cui-breakpoint-${mobileBreakpoint.trim()}`) ?? '768px';
        return `${parseFloat(breakpointValue.trim()) - 0.02}px`;
    }
    constructor() {
        this.#document = inject(DOCUMENT);
        this.#renderer = inject(Renderer2);
        this.#breakpointObserver = inject(BreakpointObserver);
        this.#sidebarService = inject(SidebarService);
        this.#backdropService = inject(SidebarBackdropService);
        this.#onMobile = false;
        this.state = signal({
            sidebar: this
        });
        this.#stateInitial = {
            narrow: false,
            visible: false,
            unfoldable: false
        };
        /**
         * Sets if the color of text should be colored for a light or dark background.
         * @return 'dark' | 'light'
         */
        this.colorScheme = input();
        /**
         * Sets html attribute id.
         * @return string
         */
        this.id = input();
        /**
         * Make sidebar narrow.
         * @return boolean
         * @default false
         */
        this.narrowInput = input(false, { transform: booleanAttribute, alias: 'narrow' });
        this.#narrow = linkedSignal(this.narrowInput);
        /**
         * Set sidebar to overlaid variant.
         * @return boolean
         * @default false
         */
        this.overlaid = input(false, { transform: booleanAttribute });
        /**
         * Components placement, there’s no default placement.
         * @return 'start' | 'end'
         */
        this.placement = input();
        /**
         * Place sidebar in non-static positions.
         * @return 'fixed' | 'sticky'
         * @default 'fixed'
         */
        this.position = input('fixed');
        /**
         * Size the component small, large, or extra large.
         * @return 'sm' | 'lg' | 'xl'
         */
        this.size = input();
        /**
         * Expand narrowed sidebar on hover.
         * @type boolean
         * @default false
         */
        this.unfoldableInput = input(false, { transform: booleanAttribute, alias: 'unfoldable' });
        this.unfoldable = linkedSignal({
            source: this.unfoldableInput,
            computation: (value) => value
        });
        /**
         * Toggle the visibility of sidebar component.
         * @type boolean
         * @default false
         */
        this.visibleInput = input(false, { transform: booleanAttribute, alias: 'visible' });
        this.#visible = linkedSignal(this.visibleInput);
        this.#visibleEffect = effect(() => {
            this.visibleChange.emit(this.#visible());
        });
        /**
         * Event emitted on visibility change.
         * @return boolean
         */
        this.visibleChange = output();
        this.hostClasses = computed(() => {
            const { mobile, visible } = { ...this.sidebarState };
            const unfoldable = this.unfoldable();
            const placement = this.placement();
            const colorScheme = this.colorScheme();
            const size = this.size();
            return {
                sidebar: true,
                'sidebar-fixed': this.position() === 'fixed' && !mobile,
                'sidebar-narrow': this.#narrow() && !unfoldable,
                'sidebar-narrow-unfoldable': unfoldable,
                'sidebar-overlaid': this.overlaid(),
                [`sidebar-${placement}`]: !!placement,
                [`sidebar-${colorScheme}`]: !!colorScheme,
                [`sidebar-${size}`]: !!size,
                show: visible,
                // show: visible && this.#onMobile, //todo: check
                hide: !visible
            };
        });
        this.#backdropService.renderer = this.#renderer;
    }
    ngOnInit() {
        this.setInitialState();
        this.layoutChangeSubscribe();
        this.stateToggleSubscribe();
    }
    ngOnDestroy() {
        this.stateToggleSubscribe(false);
        this.layoutChangeSubscribe(false);
    }
    ngOnChanges(changes) {
        const oldStateMap = new Map(Object.entries(this.state()));
        const newStateMap = new Map();
        newStateMap.set('sidebar', this);
        const propList = ['visible', 'unfoldable', 'narrow'];
        for (const propName in changes) {
            if (propList.includes(propName)) {
                if (changes[propName] && !changes[propName].firstChange) {
                    const value = booleanAttribute(changes[propName].currentValue);
                    if (oldStateMap.get(propName) !== value) {
                        newStateMap.set(propName, value);
                    }
                }
            }
        }
        if (newStateMap.size > 1) {
            const state = Object.fromEntries(newStateMap.entries());
            this.#sidebarService.toggle(state);
        }
    }
    setInitialState() {
        this.#stateInitial = {
            narrow: this.#narrow(),
            visible: this.#visible(),
            unfoldable: this.unfoldable()
        };
        this.#sidebarService.toggle({
            ...this.#stateInitial,
            sidebar: this
        });
    }
    stateToggleSubscribe(subscribe = true) {
        if (subscribe) {
            this.#stateToggleSubscription = this.#sidebarService.sidebarState$.subscribe((state) => {
                if (this === state.sidebar || this.id() === state.id) {
                    this.sidebarState = { ...state };
                }
            });
        }
        else {
            this.#stateToggleSubscription?.unsubscribe();
        }
    }
    layoutChangeSubscribe(subscribe = true) {
        const onMobile = `(max-width: ${this.getMobileBreakpoint})`;
        if (subscribe) {
            const layoutChanges = this.#breakpointObserver.observe([onMobile]);
            this.#layoutChangeSubscription = layoutChanges.subscribe((result) => {
                const isOnMobile = result.breakpoints[onMobile];
                const isUnfoldable = isOnMobile ? false : this.unfoldable();
                if (this.#onMobile !== isOnMobile) {
                    this.#onMobile = isOnMobile;
                    this.#sidebarService.toggle({
                        mobile: isOnMobile,
                        unfoldable: isUnfoldable,
                        visible: isOnMobile ? !isOnMobile : this.#stateInitial.visible,
                        sidebar: this
                    });
                }
            });
        }
        else {
            this.#layoutChangeSubscription?.unsubscribe();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: SidebarComponent, isStandalone: true, selector: "c-sidebar", inputs: { colorScheme: { classPropertyName: "colorScheme", publicName: "colorScheme", isSignal: true, isRequired: false, transformFunction: null }, id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, narrowInput: { classPropertyName: "narrowInput", publicName: "narrow", isSignal: true, isRequired: false, transformFunction: null }, overlaid: { classPropertyName: "overlaid", publicName: "overlaid", isSignal: true, isRequired: false, transformFunction: null }, placement: { classPropertyName: "placement", publicName: "placement", isSignal: true, isRequired: false, transformFunction: null }, position: { classPropertyName: "position", publicName: "position", isSignal: true, isRequired: false, transformFunction: null }, size: { classPropertyName: "size", publicName: "size", isSignal: true, isRequired: false, transformFunction: null }, unfoldableInput: { classPropertyName: "unfoldableInput", publicName: "unfoldable", isSignal: true, isRequired: false, transformFunction: null }, visibleInput: { classPropertyName: "visibleInput", publicName: "visible", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { visibleChange: "visibleChange" }, host: { properties: { "class": "hostClasses()", "attr.inert": "!this.sidebarState.visible || null" }, classAttribute: "sidebar" }, exportAs: ["cSidebar"], usesOnChanges: true, ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-sidebar',
                    exportAs: 'cSidebar',
                    template: '<ng-content />',
                    host: {
                        class: 'sidebar',
                        '[class]': 'hostClasses()',
                        '[attr.inert]': '!this.sidebarState.visible || null'
                    }
                }]
        }], ctorParameters: () => [] });

class SidebarBrandComponent {
    constructor() {
        this.brandFull = input();
        this.brandNarrow = input();
        this.routerLink = input();
        this.brandImg = computed(() => Boolean(this.brandFull() || this.brandNarrow()));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarBrandComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.2", type: SidebarBrandComponent, isStandalone: true, selector: "c-sidebar-brand", inputs: { brandFull: { classPropertyName: "brandFull", publicName: "brandFull", isSignal: true, isRequired: false, transformFunction: null }, brandNarrow: { classPropertyName: "brandNarrow", publicName: "brandNarrow", isSignal: true, isRequired: false, transformFunction: null }, routerLink: { classPropertyName: "routerLink", publicName: "routerLink", isSignal: true, isRequired: false, transformFunction: null } }, host: { classAttribute: "sidebar-brand" }, ngImport: i0, template: "@if (brandImg()) {\n  <a [routerLink]=\"routerLink()\">\n    @if (brandFull()) {\n      <img [cHtmlAttr]=\"brandFull()\" [ngClass]=\"'sidebar-brand-full'\">\n    }\n    @if (brandNarrow()) {\n      <img [cHtmlAttr]=\"brandNarrow()\" [ngClass]=\"'sidebar-brand-narrow'\">\n    }\n  </a>\n} @else {\n  <ng-content />\n}\n", dependencies: [{ kind: "directive", type: RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "info", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "directive", type: HtmlAttributesDirective, selector: "[cHtmlAttr]", inputs: ["cHtmlAttr"], exportAs: ["cHtmlAttr"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarBrandComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-sidebar-brand', imports: [RouterLink, HtmlAttributesDirective, NgClass], host: { class: 'sidebar-brand' }, template: "@if (brandImg()) {\n  <a [routerLink]=\"routerLink()\">\n    @if (brandFull()) {\n      <img [cHtmlAttr]=\"brandFull()\" [ngClass]=\"'sidebar-brand-full'\">\n    }\n    @if (brandNarrow()) {\n      <img [cHtmlAttr]=\"brandNarrow()\" [ngClass]=\"'sidebar-brand-narrow'\">\n    }\n  </a>\n} @else {\n  <ng-content />\n}\n" }]
        }] });

/**
 * Allows the sidebar to be toggled/folded via click on host element.
 */
class SidebarToggleDirective {
    constructor() {
        this.#sidebarService = inject(SidebarService);
        /**
         * Id of sidebar for toggle action.
         * @return string
         */
        this.id = input(undefined, { alias: 'cSidebarToggle' });
        /**
         * Sidebar property name for toggle action.
         *
         * @return 'visible' | 'unfoldable'
         * @default 'visible'
         */
        this.toggle = input('visible');
    }
    #sidebarService;
    toggleOpen($event) {
        $event.preventDefault();
        this.#sidebarService.toggle({ toggle: this.toggle(), id: this.id() });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarToggleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: SidebarToggleDirective, isStandalone: true, selector: "[cSidebarToggle]", inputs: { id: { classPropertyName: "id", publicName: "cSidebarToggle", isSignal: true, isRequired: false, transformFunction: null }, toggle: { classPropertyName: "toggle", publicName: "toggle", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "toggleOpen($event)" } }, exportAs: ["cSidebarToggle"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarToggleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cSidebarToggle]',
                    exportAs: 'cSidebarToggle',
                    host: {
                        '(click)': 'toggleOpen($event)'
                    }
                }]
        }] });

class SidebarTogglerDirective {
    constructor() {
        this.role = input('button');
    }
    get getStyles() {
        return {
            appearance: 'button',
            'align-items': 'flex-start',
            cursor: 'pointer'
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarTogglerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: SidebarTogglerDirective, isStandalone: true, selector: "[cSidebarToggler]", inputs: { role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.role": "role()", "style": "getStyles" }, classAttribute: "sidebar-toggler" }, hostDirectives: [{ directive: SidebarToggleDirective, inputs: ["cSidebarToggle", "cSidebarToggler", "toggle", "toggle"] }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarTogglerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cSidebarToggler]',
                    hostDirectives: [{ directive: SidebarToggleDirective, inputs: ['cSidebarToggle: cSidebarToggler', 'toggle'] }],
                    host: {
                        '[attr.role]': 'role()',
                        class: 'sidebar-toggler',
                        '[style]': 'getStyles'
                    }
                }]
        }] });

class SidebarHeaderComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarHeaderComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: SidebarHeaderComponent, isStandalone: true, selector: "c-sidebar-header", host: { classAttribute: "sidebar-header" }, ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarHeaderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-sidebar-header',
                    template: '<ng-content />',
                    host: { class: 'sidebar-header' }
                }]
        }] });

class SidebarFooterComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarFooterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: SidebarFooterComponent, isStandalone: true, selector: "c-sidebar-footer", host: { classAttribute: "sidebar-footer" }, ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarFooterComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-sidebar-footer',
                    template: '<ng-content />',
                    host: { class: 'sidebar-footer' }
                }]
        }] });

class SidebarNavService {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavService, decorators: [{
            type: Injectable
        }] });
class SidebarNavHelper {
    constructor() {
        this.hasBadge = (item) => Boolean(item.badge);
        this.hasIcon = (item) => Boolean(item.icon) || item.icon === '';
        this.hasIconComponent = (item) => Boolean(item.iconComponent);
    }
    itemType(item) {
        if (item.divider) {
            return 'divider';
        }
        else if (item.title) {
            return 'title';
        }
        else if (item.children && item.children.length > 0) {
            return 'group';
        }
        else if (item.label) {
            return 'label';
        }
        else if (!Object.keys(item).length) {
            return 'empty';
        }
        else {
            return 'link';
        }
    }
    isActive(router, item) {
        return router.isActive(item.url, false);
    }
    getIconClass(item) {
        const classes = {
            'nav-icon': true
        };
        const icon = item.icon;
        // @ts-ignore
        classes[icon] = this.hasIcon(item);
        return classes;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavHelper, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavHelper }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavHelper, decorators: [{
            type: Injectable
        }] });

class SidebarNavGroupService {
    constructor() {
        this.sidebarNavGroupState = new BehaviorSubject({});
        this.sidebarNavGroupState$ = this.sidebarNavGroupState.asObservable();
    }
    toggle(action) {
        this.sidebarNavGroupState.next(action);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavGroupService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavGroupService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavGroupService, decorators: [{
            type: Injectable
        }] });

class SidebarNavIconPipe {
    transform(item, args) {
        const icon = item.icon;
        return {
            'nav-icon': true,
            [`${icon}`]: !!icon
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavIconPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavIconPipe, isStandalone: true, name: "cSidebarNavIcon" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavIconPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'cSidebarNavIcon'
                }]
        }] });

class SidebarNavBadgePipe {
    transform(item, args) {
        const badge = item.badge;
        return {
            badge: true,
            'ms-auto': true,
            'badge-sm': !badge.size,
            [`badge-${badge.size}`]: !!badge.size,
            [`bg-${badge.color}`]: !!badge.color,
            [`${badge.class}`]: !!badge.class
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavBadgePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavBadgePipe, isStandalone: true, name: "cSidebarNavBadge" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavBadgePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'cSidebarNavBadge'
                }]
        }] });

class SidebarNavLinkPipe {
    transform(item) {
        const disabled = item?.attributes?.disabled;
        return {
            'nav-link': true,
            disabled,
            'btn-link': disabled,
            [`nav-link-${item.variant}`]: !!item.variant
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavLinkPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavLinkPipe, isStandalone: true, name: "cSidebarNavLink" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavLinkPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'cSidebarNavLink'
                }]
        }] });

class SidebarNavLinkContentComponent {
    constructor() {
        this.helper = inject(SidebarNavHelper);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavLinkContentComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.2", type: SidebarNavLinkContentComponent, isStandalone: true, selector: "c-sidebar-nav-link-content", inputs: { item: "item" }, providers: [SidebarNavHelper], ngImport: i0, template: `
    @if (true) {
      <ng-container>{{ item?.name ?? '' }}</ng-container>
    }
  `, isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavLinkContentComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-sidebar-nav-link-content',
                    template: `
    @if (true) {
      <ng-container>{{ item?.name ?? '' }}</ng-container>
    }
  `,
                    providers: [SidebarNavHelper]
                }]
        }], propDecorators: { item: [{
                type: Input
            }] } });
class SidebarNavLinkComponent {
    set item(item) {
        this._item = JSON.parse(JSON.stringify(item));
    }
    get item() {
        return this._item;
    }
    constructor() {
        this.router = inject(Router);
        this._item = {};
        this.linkClick = output();
        const router = this.router;
        this.navigationEndObservable = router.events.pipe(filter((event) => {
            return event instanceof NavigationEnd;
        }));
    }
    ngOnInit() {
        this.url =
            typeof this.item.url === 'string'
                ? this.item.url
                : this.router.serializeUrl(this.router.createUrlTree(this.item.url ?? ['']));
        this.linkType = this.getLinkType();
        this.href = this.isDisabled() ? '' : this.item.href || this.url;
        this.linkActive = this.router.url.split(/[?#(;]/)[0] === this.href.split(/[?#(;]/)[0];
        this.navSubscription = this.navigationEndObservable.subscribe((event) => {
            const itemUrlArray = this.href.split(/[?#(;]/)[0].split('/');
            const urlArray = event.urlAfterRedirects.split(/[?#(;]/)[0].split('/');
            this.linkActive = itemUrlArray.every((value, index) => value === urlArray[index]);
        });
    }
    ngOnDestroy() {
        this.navSubscription?.unsubscribe();
    }
    getLinkType() {
        return this.isDisabled() ? 'disabled' : this.isExternalLink() ? 'external' : 'link';
    }
    isDisabled() {
        return this.item?.attributes?.['disabled'];
    }
    isExternalLink() {
        const linkPath = Array.isArray(this.item.url) ? this.item.url[0] : this.item.url;
        return !!this.item.href || linkPath?.substring(0, 4) === 'http';
    }
    linkClicked() {
        this.linkClick.emit();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavLinkComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.2", type: SidebarNavLinkComponent, isStandalone: true, selector: "c-sidebar-nav-link", inputs: { item: "item" }, outputs: { linkClick: "linkClick" }, providers: [SidebarNavHelper], ngImport: i0, template: "@switch (linkType) {\n  @case ('disabled') {\n    <a [cHtmlAttr]=\"item.attributes ?? {}\" [ngClass]=\"item | cSidebarNavLink\">\n      <ng-container *ngTemplateOutlet=\"iconTemplate; context: {$implicit: item}\" />\n      <c-sidebar-nav-link-content [item]=\"item\" />\n      @if (item.badge) {\n        <span [ngClass]=\"item | cSidebarNavBadge\">{{ item.badge?.text }}</span>\n      }\n    </a>\n  }\n  @case ('external') {\n    <a (click)=\"linkClicked()\" [cHtmlAttr]=\"item.attributes ?? {}\" [href]=\"href\" [ngClass]=\"item | cSidebarNavLink\">\n      <ng-container *ngTemplateOutlet=\"iconTemplate; context: {$implicit: item}\" />\n      <c-sidebar-nav-link-content [item]=\"item\" />\n      @if (item.badge) {\n        <span [ngClass]=\"item | cSidebarNavBadge\">{{ item.badge?.text }}</span>\n      }\n    </a>\n  }\n  @default {\n    <a (click)=\"linkClicked()\"\n       [cHtmlAttr]=\"item.attributes ?? {}\"\n       [fragment]=\"item.linkProps?.fragment\"\n       [ngClass]=\"item | cSidebarNavLink\"\n       [preserveFragment]=\"item.linkProps?.preserveFragment ?? false\"\n       [queryParamsHandling]=\"item.linkProps?.queryParamsHandling\"\n       [queryParams]=\"item.linkProps?.queryParams ?? null\"\n       [replaceUrl]=\"item.linkProps?.replaceUrl ?? false\"\n       [routerLinkActiveOptions]=\"item.linkProps?.routerLinkActiveOptions ?? { exact: false }\"\n       [routerLink]=\"item.url\"\n       [skipLocationChange]=\"item.linkProps?.skipLocationChange ?? false\"\n       [state]=\"item.linkProps?.state ?? {}\"\n       [target]=\"item.attributes?.['target']\"\n       routerLinkActive=\"active\"\n    >\n      <!--    [class.active]=\"linkActive\"-->\n      <ng-container *ngTemplateOutlet=\"iconTemplate ; context: {$implicit: item}\" />\n      <c-sidebar-nav-link-content [item]=\"item\" />\n      @if (item.badge) {\n        <span [ngClass]=\"item | cSidebarNavBadge\">{{ item.badge?.text }}</span>\n      }\n    </a>\n  }\n}\n<ng-template #iconTemplate let-item>\n  <!--  <i *ngIf=\"item?.icon\" [ngClass]=\"item | cSidebarNavIcon\"></i>-->\n  @if (item?.icon) {\n    <span class=\"nav-icon\">\n      <span [ngClass]=\"item.icon ?? ''\"></span>\n    </span>\n  }\n  @if (item?.iconComponent) {\n    <svg\n      [cIcon]=\"item.iconComponent?.content\"\n      [customClasses]=\"item | cSidebarNavIcon\"\n      [name]=\"item.iconComponent?.name\"\n    ></svg>\n  }\n  @if (!item?.icon && !item?.iconComponent) {\n    <span [ngClass]=\"item | cSidebarNavIcon\"></span>\n  }\n</ng-template>\n", dependencies: [{ kind: "ngmodule", type: RouterModule }, { kind: "directive", type: i1.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "info", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "directive", type: i1.RouterLinkActive, selector: "[routerLinkActive]", inputs: ["routerLinkActiveOptions", "ariaCurrentWhenActive", "routerLinkActive"], outputs: ["isActiveChange"], exportAs: ["routerLinkActive"] }, { kind: "directive", type: HtmlAttributesDirective, selector: "[cHtmlAttr]", inputs: ["cHtmlAttr"], exportAs: ["cHtmlAttr"] }, { kind: "directive", type: IconDirective, selector: "svg[cIcon]", inputs: ["cIcon", "customClasses", "size", "title", "height", "width", "name", "viewBox", "xmlns", "pointer-events", "role"], exportAs: ["cIcon"] }, { kind: "component", type: SidebarNavLinkContentComponent, selector: "c-sidebar-nav-link-content", inputs: ["item"] }, { kind: "pipe", type: SidebarNavLinkPipe, name: "cSidebarNavLink" }, { kind: "pipe", type: SidebarNavBadgePipe, name: "cSidebarNavBadge" }, { kind: "pipe", type: SidebarNavIconPipe, name: "cSidebarNavIcon" }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavLinkComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-sidebar-nav-link', providers: [SidebarNavHelper], imports: [
                        RouterModule,
                        HtmlAttributesDirective,
                        IconDirective,
                        SidebarNavLinkContentComponent,
                        SidebarNavLinkPipe,
                        SidebarNavBadgePipe,
                        SidebarNavIconPipe,
                        NgTemplateOutlet,
                        NgClass
                    ], template: "@switch (linkType) {\n  @case ('disabled') {\n    <a [cHtmlAttr]=\"item.attributes ?? {}\" [ngClass]=\"item | cSidebarNavLink\">\n      <ng-container *ngTemplateOutlet=\"iconTemplate; context: {$implicit: item}\" />\n      <c-sidebar-nav-link-content [item]=\"item\" />\n      @if (item.badge) {\n        <span [ngClass]=\"item | cSidebarNavBadge\">{{ item.badge?.text }}</span>\n      }\n    </a>\n  }\n  @case ('external') {\n    <a (click)=\"linkClicked()\" [cHtmlAttr]=\"item.attributes ?? {}\" [href]=\"href\" [ngClass]=\"item | cSidebarNavLink\">\n      <ng-container *ngTemplateOutlet=\"iconTemplate; context: {$implicit: item}\" />\n      <c-sidebar-nav-link-content [item]=\"item\" />\n      @if (item.badge) {\n        <span [ngClass]=\"item | cSidebarNavBadge\">{{ item.badge?.text }}</span>\n      }\n    </a>\n  }\n  @default {\n    <a (click)=\"linkClicked()\"\n       [cHtmlAttr]=\"item.attributes ?? {}\"\n       [fragment]=\"item.linkProps?.fragment\"\n       [ngClass]=\"item | cSidebarNavLink\"\n       [preserveFragment]=\"item.linkProps?.preserveFragment ?? false\"\n       [queryParamsHandling]=\"item.linkProps?.queryParamsHandling\"\n       [queryParams]=\"item.linkProps?.queryParams ?? null\"\n       [replaceUrl]=\"item.linkProps?.replaceUrl ?? false\"\n       [routerLinkActiveOptions]=\"item.linkProps?.routerLinkActiveOptions ?? { exact: false }\"\n       [routerLink]=\"item.url\"\n       [skipLocationChange]=\"item.linkProps?.skipLocationChange ?? false\"\n       [state]=\"item.linkProps?.state ?? {}\"\n       [target]=\"item.attributes?.['target']\"\n       routerLinkActive=\"active\"\n    >\n      <!--    [class.active]=\"linkActive\"-->\n      <ng-container *ngTemplateOutlet=\"iconTemplate ; context: {$implicit: item}\" />\n      <c-sidebar-nav-link-content [item]=\"item\" />\n      @if (item.badge) {\n        <span [ngClass]=\"item | cSidebarNavBadge\">{{ item.badge?.text }}</span>\n      }\n    </a>\n  }\n}\n<ng-template #iconTemplate let-item>\n  <!--  <i *ngIf=\"item?.icon\" [ngClass]=\"item | cSidebarNavIcon\"></i>-->\n  @if (item?.icon) {\n    <span class=\"nav-icon\">\n      <span [ngClass]=\"item.icon ?? ''\"></span>\n    </span>\n  }\n  @if (item?.iconComponent) {\n    <svg\n      [cIcon]=\"item.iconComponent?.content\"\n      [customClasses]=\"item | cSidebarNavIcon\"\n      [name]=\"item.iconComponent?.name\"\n    ></svg>\n  }\n  @if (!item?.icon && !item?.iconComponent) {\n    <span [ngClass]=\"item | cSidebarNavIcon\"></span>\n  }\n</ng-template>\n" }]
        }], ctorParameters: () => [], propDecorators: { item: [{
                type: Input
            }] } });

class SidebarNavLabelComponent {
    constructor() {
        this.helper = inject(SidebarNavHelper);
        this.classes = {
            'c-nav-label': true,
            'c-active': true
        };
        this.iconClasses = {};
    }
    ngOnInit() {
        this.iconClasses = this.helper.getIconClass(this.item);
    }
    getItemClass() {
        const itemClass = this.item.class;
        // @ts-ignore
        this.classes[itemClass] = !!itemClass;
        return this.classes;
    }
    getLabelIconClass() {
        const variant = `text-${this.item.label.variant}`;
        // @ts-ignore
        this.iconClasses[variant] = !!this.item.label.variant;
        const labelClass = this.item.label.class;
        // @ts-ignore
        this.iconClasses[labelClass] = !!labelClass;
        return this.iconClasses;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavLabelComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.2", type: SidebarNavLabelComponent, isStandalone: true, selector: "c-sidebar-nav-label", inputs: { item: "item" }, ngImport: i0, template: "<a [cHtmlAttr]=\"item.attributes\"\n   [ngClass]=\"getItemClass()\"\n   href=\"{{item.url}}\">\n  @if (helper.hasIcon(item)) {\n    <i [ngClass]=\"getLabelIconClass()\"></i>\n  }\n  <ng-container>{{ item.name }}</ng-container>\n  @if (helper.hasBadge(item)) {\n    <span [ngClass]=\"item | cSidebarNavBadge\">{{ item.badge.text }}</span>\n  }\n</a>\n", dependencies: [{ kind: "directive", type: HtmlAttributesDirective, selector: "[cHtmlAttr]", inputs: ["cHtmlAttr"], exportAs: ["cHtmlAttr"] }, { kind: "pipe", type: SidebarNavBadgePipe, name: "cSidebarNavBadge" }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavLabelComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-sidebar-nav-label', imports: [HtmlAttributesDirective, SidebarNavBadgePipe, NgClass], template: "<a [cHtmlAttr]=\"item.attributes\"\n   [ngClass]=\"getItemClass()\"\n   href=\"{{item.url}}\">\n  @if (helper.hasIcon(item)) {\n    <i [ngClass]=\"getLabelIconClass()\"></i>\n  }\n  <ng-container>{{ item.name }}</ng-container>\n  @if (helper.hasBadge(item)) {\n    <span [ngClass]=\"item | cSidebarNavBadge\">{{ item.badge.text }}</span>\n  }\n</a>\n" }]
        }], propDecorators: { item: [{
                type: Input
            }] } });

class SidebarNavTitleComponent {
    #elementRef = inject(ElementRef);
    #renderer = inject(Renderer2);
    ngOnInit() {
        const nativeElement = this.#elementRef.nativeElement;
        const name = this.#renderer.createText(this.item.name);
        if (this.item.class) {
            const classes = this.item.class;
            this.#renderer.addClass(nativeElement, classes);
        }
        if (this.item.wrapper) {
            const wrapper = this.#renderer.createElement(this.item.wrapper.element);
            this.addAttribs(this.item.wrapper.attributes, wrapper);
            this.#renderer.appendChild(wrapper, name);
            this.#renderer.appendChild(nativeElement, wrapper);
        }
        else {
            this.#renderer.appendChild(nativeElement, name);
        }
    }
    addAttribs(attribs, element) {
        if (attribs) {
            for (const attr in attribs) {
                if (attr === 'style' && typeof attribs[attr] === 'object') {
                    this.setStyle(attribs[attr], element);
                }
                else if (attr === 'class') {
                    this.addClass(attribs[attr], element);
                }
                else {
                    this.setAttrib(attr, attribs[attr], element);
                }
            }
        }
    }
    setStyle(styles, el) {
        for (const style in styles) {
            if (style) {
                this.#renderer.setStyle(el, style, styles[style]);
            }
        }
    }
    addClass(classes, el) {
        const classArray = Array.isArray(classes) ? classes : classes.split(' ');
        classArray
            .filter((element) => element.length > 0)
            .forEach((element) => {
            this.#renderer.addClass(el, element);
        });
    }
    setAttrib(key, value, el) {
        this.#renderer.setAttribute(el, key, value);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavTitleComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: SidebarNavTitleComponent, isStandalone: true, selector: "c-sidebar-nav-title", inputs: { item: "item" }, ngImport: i0, template: '', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavTitleComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-sidebar-nav-title',
                    template: ''
                }]
        }], propDecorators: { item: [{
                type: Input
            }] } });

class SidebarNavDividerComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavDividerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: SidebarNavDividerComponent, isStandalone: true, selector: "c-sidebar-nav-divider", inputs: { item: "item" }, ngImport: i0, template: ``, isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavDividerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'c-sidebar-nav-divider',
                    template: ``
                }]
        }], propDecorators: { item: [{
                type: Input
            }] } });

class SidebarNavItemClassPipe {
    constructor() {
        this.helper = inject(SidebarNavHelper);
    }
    // transform(item: any, ...args: any[]): any {
    transform(item, args) {
        const itemType = this.helper.itemType(item);
        let itemClass;
        if (['divider', 'title'].includes(itemType)) {
            itemClass = `nav-${itemType}`;
        }
        else if (itemType === 'group') {
            // itemClass = 'c-sidebar-nav-group' ;
            itemClass = '';
        }
        else {
            itemClass = 'nav-item';
        }
        return item.class ? `${itemClass} ${item.class}` : itemClass;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavItemClassPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavItemClassPipe, isStandalone: true, name: "cSidebarNavItemClass" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavItemClassPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'cSidebarNavItemClass'
                }]
        }] });

class SidebarNavGroupComponent {
    #router;
    #renderer;
    #hostElement;
    #sidebarNavGroupService;
    constructor() {
        this.#router = inject(Router);
        this.#renderer = inject(Renderer2);
        this.#hostElement = inject(ElementRef);
        this.#sidebarNavGroupService = inject(SidebarNavGroupService);
        this.helper = inject(SidebarNavHelper);
        this.dropdownMode = 'path';
        this.navItems = [];
        this.display = { display: 'block' };
        const router = this.#router;
        this.navigationEndObservable = router.events.pipe(filter((event) => event instanceof NavigationEnd));
    }
    get hostClasses() {
        return {
            'nav-group': true,
            show: this.open
        };
    }
    ngOnInit() {
        this.navItems = [...this.item.children];
        this.navSubscription = this.navigationEndObservable.subscribe((event) => {
            if (this.dropdownMode !== 'none') {
                const samePath = this.samePath(event.url);
                this.openGroup(samePath);
            }
        });
        if (this.samePath(this.#router.routerState.snapshot.url)) {
            this.openGroup(true);
        }
        this.navGroupSubscription = this.#sidebarNavGroupService.sidebarNavGroupState$.subscribe((next) => {
            if (this.dropdownMode === 'close' && next.sidebarNavGroup && next.sidebarNavGroup !== this) {
                if (next.sidebarNavGroup.item.url.startsWith(this.item.url)) {
                    return;
                }
                if (this.samePath(this.#router.routerState.snapshot.url)) {
                    this.openGroup(true);
                    return;
                }
                this.openGroup(false);
            }
        });
    }
    samePath(url) {
        // console.log('item:', this.item.name, this.item.url, 'url:', url);
        const itemArray = this.item.url?.split('/');
        const urlArray = url.split('/');
        return itemArray?.every((value, index) => {
            // console.log(value === urlArray[index], 'value:', value, 'index:', index, urlArray[index], url);
            return value === urlArray[index];
        });
    }
    openGroup(open) {
        this.open = open;
    }
    toggleGroup($event) {
        $event.preventDefault();
        this.openGroup(!this.open);
        if (this.open) {
            this.#sidebarNavGroupService.toggle({ open: this.open, sidebarNavGroup: this });
        }
    }
    ngOnDestroy() {
        this.navSubscription?.unsubscribe();
    }
    onAnimationStart($event) {
        this.display = { display: 'block' };
        setTimeout(() => {
            const host = this.sidebarNav?.nativeElement;
            if ($event.toState === 'open' && host) {
                this.#renderer.setStyle(host, 'height', `${host['scrollHeight']}px`);
            }
        });
    }
    onAnimationDone($event) {
        setTimeout(() => {
            const host = this.sidebarNav?.nativeElement;
            if ($event.toState === 'open' && host) {
                this.#renderer.setStyle(host, 'height', 'auto');
            }
            if ($event.toState === 'closed') {
                setTimeout(() => {
                    this.display = null;
                });
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavGroupComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.2", type: SidebarNavGroupComponent, isStandalone: true, selector: "c-sidebar-nav-group", inputs: { item: "item", dropdownMode: "dropdownMode", show: "show", compact: ["compact", "compact", booleanAttribute] }, host: { properties: { "class": "this.hostClasses" } }, providers: [SidebarNavHelper, SidebarNavGroupService], viewQueries: [{ propertyName: "sidebarNav", first: true, predicate: i0.forwardRef(() => SidebarNavComponent), descendants: true, read: ElementRef }], ngImport: i0, template: "<a (click)=\"toggleGroup($event)\"\n   [cHtmlAttr]=\"item.attributes\"\n   class=\"nav-link nav-group-toggle\"\n   href>\n  <ng-container *ngTemplateOutlet=\"iconTemplate ; context: {$implicit: item}\" />\n  <ng-container>{{ item.name }}</ng-container>\n  @if (helper.hasBadge(item)) {\n    <span [ngClass]=\"item | cSidebarNavBadge\">{{ item.badge.text }}</span>\n  }\n</a>\n<c-sidebar-nav\n  (@openClose.done)=\"onAnimationDone($event)\"\n  (@openClose.start)=\"onAnimationStart($event)\"\n  [@openClose]=\"open ? 'open' : 'closed'\"\n  [compact]=\"compact\"\n  [dropdownMode]=\"dropdownMode\"\n  [groupItems]=\"true\"\n  [navItems]=\"navItems\"\n  [ngStyle]=\"display\"\n/>\n\n<ng-template #iconTemplate let-item>\n  <!--  <i *ngIf=\"item?.icon\" [ngClass]=\"item | cSidebarNavIcon\"></i>-->\n  @if (item?.icon) {\n    <span class=\"nav-icon\">\n    <span [ngClass]=\"item.icon ?? ''\"></span>\n  </span>\n  }\n  @if (item?.iconComponent) {\n    <svg\n      [cIcon]=\"item.iconComponent?.content\"\n      [customClasses]=\"item | cSidebarNavIcon\"\n      [name]=\"item.iconComponent?.name\"\n    />\n  }\n  @if (!item?.icon && !item?.iconComponent) {\n    <span [ngClass]=\"item | cSidebarNavIcon\"></span>\n  }\n</ng-template>\n", styles: [".nav-group-toggle{cursor:pointer}.nav-group-items{display:block}\n"], dependencies: [{ kind: "directive", type: i0.forwardRef(() => HtmlAttributesDirective), selector: "[cHtmlAttr]", inputs: ["cHtmlAttr"], exportAs: ["cHtmlAttr"] }, { kind: "directive", type: i0.forwardRef(() => IconDirective), selector: "svg[cIcon]", inputs: ["cIcon", "customClasses", "size", "title", "height", "width", "name", "viewBox", "xmlns", "pointer-events", "role"], exportAs: ["cIcon"] }, { kind: "directive", type: i0.forwardRef(() => NgTemplateOutlet), selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i0.forwardRef(() => NgClass), selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "pipe", type: i0.forwardRef(() => SidebarNavIconPipe), name: "cSidebarNavIcon" }, { kind: "pipe", type: i0.forwardRef(() => SidebarNavBadgePipe), name: "cSidebarNavBadge" }, { kind: "component", type: i0.forwardRef(() => SidebarNavComponent), selector: "c-sidebar-nav", inputs: ["navItems", "dropdownMode", "groupItems", "compact", "role"] }, { kind: "directive", type: i0.forwardRef(() => NgStyle), selector: "[ngStyle]", inputs: ["ngStyle"] }], animations: [
            trigger('openClose', [
                state('open', style({
                    height: '*'
                })),
                state('closed', style({
                    height: '0px'
                })),
                transition('open <=> closed', [animate('.15s ease')])
            ])
        ] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavGroupComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-sidebar-nav-group', providers: [SidebarNavHelper, SidebarNavGroupService], imports: [
                        HtmlAttributesDirective,
                        IconDirective,
                        NgTemplateOutlet,
                        NgClass,
                        SidebarNavIconPipe,
                        SidebarNavBadgePipe,
                        forwardRef(() => SidebarNavComponent),
                        NgStyle
                    ], animations: [
                        trigger('openClose', [
                            state('open', style({
                                height: '*'
                            })),
                            state('closed', style({
                                height: '0px'
                            })),
                            transition('open <=> closed', [animate('.15s ease')])
                        ])
                    ], template: "<a (click)=\"toggleGroup($event)\"\n   [cHtmlAttr]=\"item.attributes\"\n   class=\"nav-link nav-group-toggle\"\n   href>\n  <ng-container *ngTemplateOutlet=\"iconTemplate ; context: {$implicit: item}\" />\n  <ng-container>{{ item.name }}</ng-container>\n  @if (helper.hasBadge(item)) {\n    <span [ngClass]=\"item | cSidebarNavBadge\">{{ item.badge.text }}</span>\n  }\n</a>\n<c-sidebar-nav\n  (@openClose.done)=\"onAnimationDone($event)\"\n  (@openClose.start)=\"onAnimationStart($event)\"\n  [@openClose]=\"open ? 'open' : 'closed'\"\n  [compact]=\"compact\"\n  [dropdownMode]=\"dropdownMode\"\n  [groupItems]=\"true\"\n  [navItems]=\"navItems\"\n  [ngStyle]=\"display\"\n/>\n\n<ng-template #iconTemplate let-item>\n  <!--  <i *ngIf=\"item?.icon\" [ngClass]=\"item | cSidebarNavIcon\"></i>-->\n  @if (item?.icon) {\n    <span class=\"nav-icon\">\n    <span [ngClass]=\"item.icon ?? ''\"></span>\n  </span>\n  }\n  @if (item?.iconComponent) {\n    <svg\n      [cIcon]=\"item.iconComponent?.content\"\n      [customClasses]=\"item | cSidebarNavIcon\"\n      [name]=\"item.iconComponent?.name\"\n    />\n  }\n  @if (!item?.icon && !item?.iconComponent) {\n    <span [ngClass]=\"item | cSidebarNavIcon\"></span>\n  }\n</ng-template>\n", styles: [".nav-group-toggle{cursor:pointer}.nav-group-items{display:block}\n"] }]
        }], ctorParameters: () => [], propDecorators: { item: [{
                type: Input
            }], dropdownMode: [{
                type: Input
            }], show: [{
                type: Input
            }], compact: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], hostClasses: [{
                type: HostBinding,
                args: ['class']
            }], sidebarNav: [{
                type: ViewChild,
                args: [forwardRef(() => SidebarNavComponent), { read: ElementRef }]
            }] } });
class SidebarNavComponent {
    constructor() {
        this.sidebar = inject(SidebarComponent, { optional: true });
        this.helper = inject(SidebarNavHelper);
        this.router = inject(Router);
        this.#renderer = inject(Renderer2);
        this.#hostElement = inject(ElementRef);
        this.#sidebarService = inject(SidebarService);
        this.navItems = [];
        this.dropdownMode = 'path';
        // @HostBinding('class.nav-group-items')
        // get sidebarNavGroupItemsClass(): boolean {
        //   return !!this.groupItems;
        // }
        this.role = 'navigation';
        this.navItemsArray = [];
    }
    #renderer;
    #hostElement;
    #sidebarService;
    get hostClasses() {
        return {
            'sidebar-nav': !this.groupItems,
            'nav-group-items': this.groupItems,
            compact: this.groupItems && this.compact
        };
    }
    ngOnChanges(changes) {
        this.navItemsArray = Array.isArray(this.navItems) ? this.navItems.slice() : [];
    }
    hideMobile() {
        // todo: proper scrollIntoView() after NavigationEnd
        if (this.sidebar && this.sidebar.sidebarState.mobile) {
            this.#sidebarService.toggle({ toggle: 'visible', sidebar: this.sidebar });
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.2", type: SidebarNavComponent, isStandalone: true, selector: "c-sidebar-nav", inputs: { navItems: "navItems", dropdownMode: "dropdownMode", groupItems: ["groupItems", "groupItems", booleanAttribute], compact: ["compact", "compact", booleanAttribute], role: "role" }, host: { properties: { "class": "this.hostClasses", "attr.role": "this.role" } }, usesOnChanges: true, ngImport: i0, template: "@for (item of navItemsArray; track item) {\n  @switch (helper.itemType(item)) {\n    @case ('group') {\n      <c-sidebar-nav-group\n        #rla=\"routerLinkActive\"\n        [dropdownMode]=\"dropdownMode\"\n        [item]=\"item\"\n        [ngClass]=\"item | cSidebarNavItemClass\"\n        [routerLinkActiveOptions]=\"{exact: true}\"\n        routerLinkActive=\"show\"\n        [compact]=\"compact\"\n      />\n    }\n    @case ('divider') {\n      <c-sidebar-nav-divider\n        [cHtmlAttr]=\"item.attributes ?? {}\"\n        [item]=\"item\"\n        [ngClass]=\"item | cSidebarNavItemClass\"\n      />\n    }\n    @case ('title') {\n      <c-sidebar-nav-title\n        [cHtmlAttr]=\"item.attributes ?? {}\"\n        [item]=\"item\"\n        [ngClass]=\"item | cSidebarNavItemClass\"\n      />\n    }\n    @case ('label') {\n      <c-sidebar-nav-label\n        [item]=\"item\"\n        [ngClass]=\"item | cSidebarNavItemClass\"\n      />\n    }\n    @case ('empty') {\n      <ng-container />\n    }\n    @default {\n      <c-sidebar-nav-link\n        (linkClick)=\"hideMobile()\"\n        [item]=\"item\"\n        [ngClass]=\"item | cSidebarNavItemClass\"\n      />\n    }\n  }\n}\n<ng-content />\n", dependencies: [{ kind: "directive", type: i0.forwardRef(() => NgClass), selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i0.forwardRef(() => HtmlAttributesDirective), selector: "[cHtmlAttr]", inputs: ["cHtmlAttr"], exportAs: ["cHtmlAttr"] }, { kind: "component", type: i0.forwardRef(() => SidebarNavLinkComponent), selector: "c-sidebar-nav-link", inputs: ["item"], outputs: ["linkClick"] }, { kind: "component", type: i0.forwardRef(() => SidebarNavLabelComponent), selector: "c-sidebar-nav-label", inputs: ["item"] }, { kind: "component", type: i0.forwardRef(() => SidebarNavTitleComponent), selector: "c-sidebar-nav-title", inputs: ["item"] }, { kind: "component", type: i0.forwardRef(() => SidebarNavDividerComponent), selector: "c-sidebar-nav-divider", inputs: ["item"] }, { kind: "component", type: i0.forwardRef(() => SidebarNavGroupComponent), selector: "c-sidebar-nav-group", inputs: ["item", "dropdownMode", "show", "compact"] }, { kind: "pipe", type: i0.forwardRef(() => SidebarNavItemClassPipe), name: "cSidebarNavItemClass" }, { kind: "ngmodule", type: i0.forwardRef(() => RouterModule) }, { kind: "directive", type: i0.forwardRef(() => i1.RouterLinkActive), selector: "[routerLinkActive]", inputs: ["routerLinkActiveOptions", "ariaCurrentWhenActive", "routerLinkActive"], outputs: ["isActiveChange"], exportAs: ["routerLinkActive"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarNavComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-sidebar-nav', imports: [
                        NgClass,
                        HtmlAttributesDirective,
                        SidebarNavLinkComponent,
                        SidebarNavLabelComponent,
                        SidebarNavTitleComponent,
                        SidebarNavDividerComponent,
                        forwardRef(() => SidebarNavGroupComponent),
                        SidebarNavItemClassPipe,
                        RouterModule
                    ], template: "@for (item of navItemsArray; track item) {\n  @switch (helper.itemType(item)) {\n    @case ('group') {\n      <c-sidebar-nav-group\n        #rla=\"routerLinkActive\"\n        [dropdownMode]=\"dropdownMode\"\n        [item]=\"item\"\n        [ngClass]=\"item | cSidebarNavItemClass\"\n        [routerLinkActiveOptions]=\"{exact: true}\"\n        routerLinkActive=\"show\"\n        [compact]=\"compact\"\n      />\n    }\n    @case ('divider') {\n      <c-sidebar-nav-divider\n        [cHtmlAttr]=\"item.attributes ?? {}\"\n        [item]=\"item\"\n        [ngClass]=\"item | cSidebarNavItemClass\"\n      />\n    }\n    @case ('title') {\n      <c-sidebar-nav-title\n        [cHtmlAttr]=\"item.attributes ?? {}\"\n        [item]=\"item\"\n        [ngClass]=\"item | cSidebarNavItemClass\"\n      />\n    }\n    @case ('label') {\n      <c-sidebar-nav-label\n        [item]=\"item\"\n        [ngClass]=\"item | cSidebarNavItemClass\"\n      />\n    }\n    @case ('empty') {\n      <ng-container />\n    }\n    @default {\n      <c-sidebar-nav-link\n        (linkClick)=\"hideMobile()\"\n        [item]=\"item\"\n        [ngClass]=\"item | cSidebarNavItemClass\"\n      />\n    }\n  }\n}\n<ng-content />\n" }]
        }], propDecorators: { navItems: [{
                type: Input
            }], dropdownMode: [{
                type: Input
            }], groupItems: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], compact: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], hostClasses: [{
                type: HostBinding,
                args: ['class']
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }, {
                type: Input
            }] } });

class SidebarModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: SidebarModule, imports: [SidebarComponent,
            SidebarBrandComponent,
            SidebarFooterComponent,
            SidebarHeaderComponent,
            SidebarNavComponent,
            SidebarNavBadgePipe,
            SidebarNavDividerComponent,
            SidebarNavGroupComponent,
            SidebarNavIconPipe,
            SidebarNavItemClassPipe,
            SidebarNavLabelComponent,
            SidebarNavLinkComponent,
            SidebarNavLinkContentComponent,
            SidebarNavLinkPipe,
            SidebarNavTitleComponent,
            SidebarToggleDirective,
            SidebarTogglerDirective], exports: [SidebarComponent,
            SidebarToggleDirective,
            SidebarTogglerDirective,
            SidebarBrandComponent,
            SidebarNavComponent,
            SidebarHeaderComponent,
            SidebarFooterComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarModule, providers: [
            SidebarService,
            SidebarNavHelper,
            SidebarNavGroupService
        ], imports: [SidebarNavComponent,
            SidebarNavGroupComponent,
            SidebarNavLinkComponent] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SidebarModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        SidebarComponent,
                        SidebarBrandComponent,
                        SidebarFooterComponent,
                        SidebarHeaderComponent,
                        SidebarNavComponent,
                        SidebarNavBadgePipe,
                        SidebarNavDividerComponent,
                        SidebarNavGroupComponent,
                        SidebarNavIconPipe,
                        SidebarNavItemClassPipe,
                        SidebarNavLabelComponent,
                        SidebarNavLinkComponent,
                        SidebarNavLinkContentComponent,
                        SidebarNavLinkPipe,
                        SidebarNavTitleComponent,
                        SidebarToggleDirective,
                        SidebarTogglerDirective
                    ],
                    exports: [
                        SidebarComponent,
                        SidebarToggleDirective,
                        SidebarTogglerDirective,
                        SidebarBrandComponent,
                        SidebarNavComponent,
                        SidebarHeaderComponent,
                        SidebarFooterComponent
                    ],
                    providers: [
                        SidebarService,
                        SidebarNavHelper,
                        SidebarNavGroupService
                    ]
                }]
        }] });

class SpinnerComponent {
    constructor() {
        /**
         * Sets the color context of the component to one of CoreUI’s themed colors.
         * @type Colors
         */
        this.color = input();
        /**
         * Label for accessibility.
         * @type string
         * @default 'Loading...'
         */
        this.label = input('Loading...');
        /**
         * Size the component small.
         * @type string
         * @values 'sm'
         */
        this.size = input();
        /**
         * Set the button variant to an outlined button or a ghost button.
         * @values 'border' | 'grow'
         * @default 'border'
         */
        this.variant = input('border');
        /**
         * Default role attr for Spinner. [docs]
         * @type string
         * @default 'status'
         */
        this.role = input('status');
        this.hostClasses = computed(() => {
            return {
                [`spinner-${this.variant()}`]: true,
                [`text-${this.color()}`]: !!this.color(),
                [`spinner-${this.variant()}-${this.size()}`]: !!this.size()
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SpinnerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: SpinnerComponent, isStandalone: true, selector: "c-spinner", inputs: { color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null }, label: { classPropertyName: "label", publicName: "label", isSignal: true, isRequired: false, transformFunction: null }, size: { classPropertyName: "size", publicName: "size", isSignal: true, isRequired: false, transformFunction: null }, variant: { classPropertyName: "variant", publicName: "variant", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.role": "role()", "class": "hostClasses()" } }, ngImport: i0, template: "<ng-content>\n  <span class=\"visually-hidden\">{{ label() }}</span>\n</ng-content>\n" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SpinnerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-spinner', host: {
                        '[attr.role]': 'role()',
                        '[class]': 'hostClasses()'
                    }, template: "<ng-content>\n  <span class=\"visually-hidden\">{{ label() }}</span>\n</ng-content>\n" }]
        }] });

class SpinnerModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SpinnerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: SpinnerModule, imports: [SpinnerComponent], exports: [SpinnerComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SpinnerModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: SpinnerModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [
                        SpinnerComponent
                    ],
                    imports: [
                        SpinnerComponent
                    ]
                }]
        }] });

class TableColorDirective {
    constructor() {
        /**
         * Use contextual color for tables, table rows or individual cells.
         * @return Colors
         */
        this.color = input(undefined, { alias: 'cTableColor' });
        this.hostClasses = computed(() => {
            const color = this.color();
            return {
                [`table-${color}`]: !!color
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TableColorDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: TableColorDirective, isStandalone: true, selector: "[cTableColor]", inputs: { color: { classPropertyName: "color", publicName: "cTableColor", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" } }, exportAs: ["cTableColor"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TableColorDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cTableColor]',
                    exportAs: 'cTableColor',
                    host: {
                        '[class]': 'hostClasses()'
                    }
                }]
        }] });

class TableActiveDirective {
    constructor() {
        /**
         * Highlight a table row or cell
         * @return boolean
         */
        this.active = input(false, { alias: "cTableActive", transform: booleanAttribute });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TableActiveDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: TableActiveDirective, isStandalone: true, selector: "[cTableActive]", inputs: { active: { classPropertyName: "active", publicName: "cTableActive", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class.table-active": "active()" } }, exportAs: ["cTableActive"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TableActiveDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cTableActive]',
                    exportAs: 'cTableActive',
                    host: {
                        '[class.table-active]': 'active()'
                    }
                }]
        }] });

class TableDirective {
    constructor() {
        this.#renderer = inject(Renderer2);
        this.#hostElement = inject(ElementRef);
        /**
         * Set the vertical alignment.
         * @return string
         * @values 'bottom' | 'middle' | 'top'
         */
        this.align = input();
        /**
         * Sets the border color of the component to one of CoreUI’s themed colors.
         * @return Colors
         */
        this.borderColor = input();
        /**
         * Add borders on all sides of the table and cells.
         * @return boolean
         */
        this.bordered = input(false, { transform: booleanAttribute });
        /**
         * Remove borders on all sides of the table and cells.
         * @return boolean
         */
        this.borderless = input(false, { transform: booleanAttribute });
        /**
         * Put the `<caption>` on the top of the table.
         * @return 'top'
         * @values 'top'
         */
        this.caption = input();
        /**
         * Sets the color context of the component to one of CoreUI’s themed colors.
         * @return Colors
         */
        this.color = input();
        /**
         * Enable a hover state on table rows within table body.
         * @return boolean
         */
        this.hover = input(false, { transform: booleanAttribute });
        /**
         * Make table responsive across all viewports or pick a maximum breakpoint with which to have a responsive table up to.
         * @values: {boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl'}
         */
        this.responsive = input();
        /**
         * Make table more compact by cutting all cell `padding` in half.
         * @return boolean
         */
        this.small = input(false, { transform: booleanAttribute });
        /**
         * Add zebra-striping to any table row within the table body.
         * @return boolean
         */
        this.striped = input(false, { transform: booleanAttribute });
        /**
         * Add zebra-striping to any table column.
         * @return boolean
         * @since 4.2.4
         */
        this.stripedColumns = input(false, { transform: booleanAttribute });
        this.hostClasses = computed(() => {
            const align = this.align();
            const caption = this.caption();
            const borderColor = this.borderColor();
            const bordered = this.bordered();
            const borderless = this.borderless();
            const color = this.color();
            const hover = this.hover();
            const small = this.small();
            const striped = this.striped();
            const stripedColumns = this.stripedColumns();
            return {
                table: true,
                [`align-${align}`]: !!align,
                [`caption-${caption}`]: !!caption,
                [`border-${borderColor}`]: !!borderColor,
                'table-bordered': bordered,
                'table-borderless': borderless,
                [`table-${color}`]: !!color,
                'table-hover': hover,
                'table-sm': small,
                'table-striped': striped,
                'table-striped-columns': stripedColumns
            };
        });
        this.#responsiveWrapperEffect = effect(() => {
            const responsive = this.responsive();
            if (!!responsive) {
                const nativeElement = this.#hostElement.nativeElement;
                const wrapper = this.#renderer.createElement('div');
                const className = responsive === true ? 'table-responsive' : `table-responsive-${responsive}`;
                this.#renderer.addClass(wrapper, className);
                const parentNode = this.#renderer.parentNode(nativeElement);
                this.#renderer.appendChild(parentNode, wrapper);
                this.#renderer.insertBefore(parentNode, wrapper, nativeElement);
                this.#renderer.appendChild(wrapper, nativeElement);
            }
        });
    }
    #renderer;
    #hostElement;
    #responsiveWrapperEffect;
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TableDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: TableDirective, isStandalone: true, selector: "table[cTable]", inputs: { align: { classPropertyName: "align", publicName: "align", isSignal: true, isRequired: false, transformFunction: null }, borderColor: { classPropertyName: "borderColor", publicName: "borderColor", isSignal: true, isRequired: false, transformFunction: null }, bordered: { classPropertyName: "bordered", publicName: "bordered", isSignal: true, isRequired: false, transformFunction: null }, borderless: { classPropertyName: "borderless", publicName: "borderless", isSignal: true, isRequired: false, transformFunction: null }, caption: { classPropertyName: "caption", publicName: "caption", isSignal: true, isRequired: false, transformFunction: null }, color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null }, hover: { classPropertyName: "hover", publicName: "hover", isSignal: true, isRequired: false, transformFunction: null }, responsive: { classPropertyName: "responsive", publicName: "responsive", isSignal: true, isRequired: false, transformFunction: null }, small: { classPropertyName: "small", publicName: "small", isSignal: true, isRequired: false, transformFunction: null }, striped: { classPropertyName: "striped", publicName: "striped", isSignal: true, isRequired: false, transformFunction: null }, stripedColumns: { classPropertyName: "stripedColumns", publicName: "stripedColumns", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "table" }, exportAs: ["cTable"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'table[cTable]',
                    exportAs: 'cTable',
                    host: {
                        class: 'table',
                        '[class]': 'hostClasses()'
                    }
                }]
        }] });

class TableModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TableModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: TableModule, imports: [TableDirective,
            TableColorDirective,
            TableActiveDirective], exports: [TableDirective,
            TableColorDirective,
            TableActiveDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TableModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TableModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [
                        TableDirective,
                        TableColorDirective,
                        TableActiveDirective
                    ],
                    imports: [
                        TableDirective,
                        TableColorDirective,
                        TableActiveDirective
                    ]
                }]
        }] });

class TabService {
    constructor() {
        this.activeTabPaneIdx = new Subject();
        this.activeTabPaneIdx$ = this.activeTabPaneIdx.asObservable();
    }
    setActiveTabIdx(tabContentState) {
        this.activeTabPaneIdx.next(tabContentState);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class TabPaneComponent {
    #changeDetectorRef;
    #tabService;
    constructor() {
        this.#changeDetectorRef = inject(ChangeDetectorRef);
        this.#tabService = inject(TabService);
        this.#active = false;
        this.role = 'tabpanel';
        this.subscribeTabService();
    }
    #tabServiceSubscription;
    set active(value) {
        const newValue = booleanAttribute(value);
        if (this.#active !== newValue) {
            this.#active = newValue;
            this.#changeDetectorRef.markForCheck();
        }
    }
    get active() {
        return this.#active;
    }
    #active;
    get hostClasses() {
        return {
            'tab-pane': true,
            fade: true,
            show: this.active,
            active: this.active
        };
    }
    ngOnDestroy() {
        this.subscribeTabService(false);
    }
    subscribeTabService(subscribe = true) {
        if (subscribe) {
            this.#tabServiceSubscription = this.#tabService.activeTabPaneIdx$.subscribe((tabContentState) => {
                if (tabContentState.tabContent === this.tabContent) {
                    this.active = tabContentState.activeIdx === this.tabPaneIdx;
                }
            });
        }
        else {
            this.#tabServiceSubscription?.unsubscribe();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabPaneComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: TabPaneComponent, isStandalone: true, selector: "c-tab-pane", inputs: { role: "role" }, host: { properties: { "class": "this.hostClasses", "attr.role": "this.role" }, classAttribute: "tab-pane" }, exportAs: ["cTabPane"], ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabPaneComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-tab-pane', template: '<ng-content />', exportAs: 'cTabPane', host: { class: 'tab-pane' }, styles: [":host{display:block}\n"] }]
        }], ctorParameters: () => [], propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class']
            }], role: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['attr.role']
            }] } });

class TabContentComponent {
    constructor() {
        this.#changeDetectorRef = inject(ChangeDetectorRef);
        this.#tabService = inject(TabService);
        this.#activeTabPaneIdx = -1;
        /**
         * Event emitted on the active tab pane index change.
         */
        this.activeTabPaneIdxChange = new EventEmitter();
    }
    #changeDetectorRef;
    #tabService;
    /**
     * Set active tabPane index
     * @type number
     */
    set activeTabPaneIdx(value) {
        const newValue = value;
        if (this.#activeTabPaneIdx != newValue) {
            this.#activeTabPaneIdx = newValue;
            this.activeTabPaneIdxChange.emit(newValue);
            this.#changeDetectorRef.markForCheck();
            this.#changeDetectorRef.detectChanges();
        }
    }
    get activeTabPaneIdx() {
        return this.#activeTabPaneIdx;
    }
    #activeTabPaneIdx;
    #tabServiceSubscription;
    ngAfterContentInit() {
        this.subscribeTabService();
    }
    ngAfterContentChecked() {
        this.panes?.forEach((tabPane, index) => {
            tabPane.tabContent = this;
            tabPane.tabPaneIdx = index;
        });
        this.refreshTabPaneActive(this.activeTabPaneIdx);
        this.#tabService.setActiveTabIdx({ tabContent: this, activeIdx: this.activeTabPaneIdx });
    }
    ngOnChanges(changes) {
        if (changes['activeTabPaneIdx']?.currentValue) {
            this.#tabService.setActiveTabIdx({ tabContent: this, activeIdx: changes['activeTabPaneIdx'].currentValue });
        }
    }
    ngOnDestroy() {
        this.subscribeTabService(false);
    }
    subscribeTabService(subscribe = true) {
        if (subscribe) {
            this.#tabServiceSubscription = this.#tabService.activeTabPaneIdx$.subscribe((tabContentState) => {
                if (this === tabContentState.tabContent) {
                    this.activeTabPaneIdx = tabContentState.activeIdx;
                }
            });
        }
        else {
            this.#tabServiceSubscription?.unsubscribe();
        }
    }
    refreshTabPaneActive(idx) {
        // hack for active state pane refresh todo?
        this.panes?.forEach((tabPane, index) => {
            tabPane.active = idx === index;
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabContentComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "19.2.2", type: TabContentComponent, isStandalone: true, selector: "c-tab-content", inputs: { activeTabPaneIdx: ["activeTabPaneIdx", "activeTabPaneIdx", numberAttribute] }, outputs: { activeTabPaneIdxChange: "activeTabPaneIdxChange" }, host: { classAttribute: "tab-content" }, queries: [{ propertyName: "panes", predicate: TabPaneComponent }], exportAs: ["cTabContent"], usesOnChanges: true, ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabContentComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-tab-content', template: '<ng-content />', changeDetection: ChangeDetectionStrategy.OnPush, exportAs: 'cTabContent', host: { class: 'tab-content' }, styles: [":host{display:block}\n"] }]
        }], propDecorators: { activeTabPaneIdx: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], activeTabPaneIdxChange: [{
                type: Output
            }], panes: [{
                type: ContentChildren,
                args: [TabPaneComponent]
            }] } });

class TabContentRefDirective {
    #changeDetectorRef;
    #tabService;
    constructor() {
        this.#changeDetectorRef = inject(ChangeDetectorRef);
        this.#tabService = inject(TabService);
        this.#active = false;
        this.#disabled = false;
        /**
         * c-tab-pane index respectively
         * @type number
         */
        this.tabPaneIdx = -1;
        this.role = 'tab';
        this.subscribeTabService();
    }
    #tabServiceSubscription;
    /**
     * Set active state of tab content
     * @type boolean
     * @default false
     */
    set active(value) {
        const newValue = value;
        if (this.#active !== newValue) {
            this.#active = newValue;
            this.#changeDetectorRef.detectChanges();
        }
    }
    get active() {
        return this.#active;
    }
    #active;
    /**
     * Set disabled state of tab content
     * @type boolean
     */
    set disabled(value) {
        this.#disabled = value;
    }
    get disabled() {
        return this.#disabled || this.tabPaneIdx >= this.tabContentRef?.panes?.length;
    }
    #disabled;
    get hostClasses() {
        return {
            active: this.active,
            disabled: this.disabled
        };
    }
    get isDisabled() {
        return this.disabled || null;
    }
    get attrDisabled() {
        return this.disabled ? '' : null;
    }
    get ariaSelected() {
        return this.active;
    }
    get getTabindex() {
        return this.disabled ? '-1' : null;
    }
    ngOnChanges(changes) {
        if (changes['active']?.currentValue) {
            this.setActiveTabPane();
        }
    }
    toggleOpen($event) {
        $event.preventDefault();
        this.setActiveTabPane();
    }
    setActiveTabPane() {
        setTimeout(() => {
            if (this.tabPaneIdx < this.tabContentRef.panes.length) {
                this.active = true;
                this.#tabService.setActiveTabIdx({ tabContent: this.tabContentRef, activeIdx: this.tabPaneIdx });
            }
            else {
                this.active = false;
            }
        });
    }
    ngOnDestroy() {
        this.subscribeTabService(false);
    }
    subscribeTabService(subscribe = true) {
        if (subscribe) {
            this.#tabServiceSubscription = this.#tabService.activeTabPaneIdx$.subscribe((tabContentState) => {
                if (tabContentState.tabContent === this.tabContentRef) {
                    this.active = tabContentState.activeIdx === this.tabPaneIdx;
                }
            });
        }
        else {
            this.#tabServiceSubscription?.unsubscribe();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabContentRefDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "19.2.2", type: TabContentRefDirective, isStandalone: true, selector: "[cTabContent]", inputs: { tabContentRef: ["cTabContent", "tabContentRef"], active: ["active", "active", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute], tabPaneIdx: ["tabPaneIdx", "tabPaneIdx", numberAttribute], role: "role" }, host: { listeners: { "click": "toggleOpen($event)" }, properties: { "class": "this.hostClasses", "attr.aria-disabled": "this.isDisabled", "attr.disabled": "this.attrDisabled", "attr.aria-selected": "this.ariaSelected", "attr.role": "this.role", "attr.tabindex": "this.getTabindex" } }, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabContentRefDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cTabContent]'
                }]
        }], ctorParameters: () => [], propDecorators: { tabContentRef: [{
                type: Input,
                args: ['cTabContent']
            }], active: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], tabPaneIdx: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], hostClasses: [{
                type: HostBinding,
                args: ['class']
            }], isDisabled: [{
                type: HostBinding,
                args: ['attr.aria-disabled']
            }], attrDisabled: [{
                type: HostBinding,
                args: ['attr.disabled']
            }], ariaSelected: [{
                type: HostBinding,
                args: ['attr.aria-selected']
            }], role: [{
                type: Input
            }, {
                type: HostBinding,
                args: ['attr.role']
            }], getTabindex: [{
                type: HostBinding,
                args: ['attr.tabindex']
            }], toggleOpen: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

class TabsModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: TabsModule, imports: [TabContentComponent,
            TabContentRefDirective,
            TabPaneComponent], exports: [TabContentComponent,
            TabPaneComponent,
            TabContentRefDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabsModule, providers: [
            TabService
        ] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        TabContentComponent,
                        TabContentRefDirective,
                        TabPaneComponent
                    ],
                    exports: [
                        TabContentComponent,
                        TabPaneComponent,
                        TabContentRefDirective
                    ],
                    providers: [
                        TabService
                    ]
                }]
        }] });

class TabsService {
    constructor() {
        this.activeItem = signal(undefined);
        this.activeItemKey = signal(undefined);
        this.id = signal(undefined);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabsService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabsService, decorators: [{
            type: Injectable
        }] });

let nextId = 0;
class TabsComponent {
    constructor() {
        this.tabsService = inject(TabsService);
        /**
         * The active item key.
         * @type <string | number | undefined>
         */
        this.activeItemKey = model();
        /**
         * The id attribute
         * @type string
         */
        this.tabsId = `tabs-${nextId++}`;
        this.id = input(this.tabsId);
        this.#activeItemEffect = effect(() => {
            this.tabsService.id.set(this.id());
            this.tabsService.activeItemKey.set(this.activeItemKey());
        });
        this.#tabsServiceEffect = effect(() => {
            this.activeItemKey.set(this.tabsService.activeItemKey());
        });
    }
    #activeItemEffect;
    #tabsServiceEffect;
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: TabsComponent, isStandalone: true, selector: "c-tabs", inputs: { activeItemKey: { classPropertyName: "activeItemKey", publicName: "activeItemKey", isSignal: true, isRequired: false, transformFunction: null }, id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { activeItemKey: "activeItemKeyChange" }, host: { properties: { "id": "id()" }, classAttribute: "tabs" }, providers: [TabsService], exportAs: ["cTabs"], ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabsComponent, decorators: [{
            type: Component,
            args: [{ exportAs: 'cTabs', selector: 'c-tabs', imports: [], template: '<ng-content />', providers: [TabsService], host: {
                        '[id]': 'id()',
                        class: 'tabs'
                    }, styles: [":host{display:block}\n"] }]
        }] });

class TabDirective {
    constructor() {
        this.#injector = inject(Injector);
        this.#destroyRef = inject(DestroyRef);
        this.#elementRef = inject(ElementRef);
        this.#tabsService = inject(TabsService);
        /**
         * Disabled attribute
         * @return boolean
         * @default false
         */
        this.disabledInput = input(false, { transform: booleanAttribute, alias: 'disabled' });
        this.#disabled = signal(false);
        this.attrDisabled = computed(() => this.#disabled() || null);
        this.#disabledEffect = effect(() => {
            const disabled = this.disabledInput();
            untracked(() => {
                this.disabled = disabled;
            });
        });
        /**
         * Item key.
         * @type string | number
         * @required
         */
        this.itemKey = input.required();
        /**
         * Element id attribute
         * @type string
         * @default undefined
         */
        this.id = input();
        /**
         * aria-controls attribute
         * @type string
         * @default undefined
         */
        this.ariaControls = input(undefined, {
            alias: 'aria-controls'
        });
        this.isActive = signal(false);
        this.hostClasses = computed(() => ({
            'nav-link': true,
            active: this.isActive(),
            disabled: this.#disabled()
        }));
        this.propId = computed(() => this.id() ?? `${this.#tabsService.id()}-tab-${this.itemKey()}`);
        this.attrAriaControls = computed(() => this.ariaControls() ?? `${this.#tabsService.id()}-panel-${this.itemKey()}`);
        this.#disabledSignalEffect = effect(() => {
            const disabled = this.#disabled();
            if (!disabled) {
                const click$ = fromEvent(this.#elementRef.nativeElement, 'click');
                const focusIn$ = fromEvent(this.#elementRef.nativeElement, 'focusin');
                merge(focusIn$, click$)
                    .pipe(filter(($event) => !disabled), tap(($event) => {
                    this.#tabsService.activeItemKey.set(untracked(this.itemKey));
                }), takeWhile(() => !disabled), takeUntilDestroyed(this.#destroyRef))
                    .subscribe();
            }
        });
    }
    #injector;
    #destroyRef;
    #elementRef;
    #tabsService;
    #disabled;
    #disabledEffect;
    set disabled(value) {
        this.#disabled.set(value);
    }
    get disabled() {
        return this.#disabled();
    }
    #disabledSignalEffect;
    focus(origin) {
        this.#elementRef.nativeElement.focus();
    }
    ngOnInit() {
        runInInjectionContext(this.#injector, () => {
            effect(() => {
                const isActive = !this.#disabled() && this.#tabsService.activeItemKey() === this.itemKey();
                this.isActive.set(isActive);
            });
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: TabDirective, isStandalone: true, selector: "button[cTab]", inputs: { disabledInput: { classPropertyName: "disabledInput", publicName: "disabled", isSignal: true, isRequired: false, transformFunction: null }, itemKey: { classPropertyName: "itemKey", publicName: "itemKey", isSignal: true, isRequired: true, transformFunction: null }, id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, ariaControls: { classPropertyName: "ariaControls", publicName: "aria-controls", isSignal: true, isRequired: false, transformFunction: null } }, host: { attributes: { "type": "button", "role": "tab" }, properties: { "class": "hostClasses()", "attr.aria-selected": "isActive()", "attr.aria-controls": "attrAriaControls()", "attr.disabled": "attrDisabled() || null", "id": "propId()", "tabindex": "isActive() ? 0 : -1" } }, exportAs: ["cTab"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabDirective, decorators: [{
            type: Directive,
            args: [{
                    exportAs: 'cTab',
                    selector: 'button[cTab]',
                    host: {
                        '[class]': 'hostClasses()',
                        type: 'button',
                        role: 'tab',
                        '[attr.aria-selected]': 'isActive()',
                        '[attr.aria-controls]': 'attrAriaControls()',
                        '[attr.disabled]': 'attrDisabled() || null',
                        '[id]': 'propId()',
                        '[tabindex]': 'isActive() ? 0 : -1'
                    }
                }]
        }] });

class TabsListComponent {
    constructor() {
        this.#destroyRef = inject(DestroyRef);
        this.tabsService = inject(TabsService);
        /**
         * Specify a layout type for component.
         * @type 'fill' | 'justified' | undefined
         * @default undefined
         */
        this.layout = input();
        /**
         * Set the variant to tabs, pills or underline.
         * @type 'pills' | 'tabs' | 'underline' | 'underline-border' | undefined
         * @default undefined
         */
        this.variant = input();
        /**
         * Set the role to tab list.
         * @default 'tablist'
         */
        this.role = input('tablist');
        this.hostClasses = computed(() => ({
            nav: true,
            [`nav-${this.layout()}`]: this.layout(),
            [`nav-${this.variant()}`]: this.variant()
        }));
        this.tabs = contentChildren(TabDirective);
        this.#tabsEffect = effect(() => {
            const tabs = this.tabs();
            if (tabs.length === 0) {
                return;
            }
            this.#focusKeyManager = new FocusKeyManager(tabs)
                .skipPredicate((tab) => tab.disabled === true)
                .withHorizontalOrientation('ltr')
                .withHomeAndEnd()
                .withWrap();
            this.#focusKeyManager.change
                .pipe(tap((value) => {
                this.tabsService.activeItemKey.set(this.#focusKeyManager.activeItem?.itemKey());
                this.tabsService.activeItem.set(this.#focusKeyManager.activeItem);
            }), takeUntilDestroyed(this.#destroyRef))
                .subscribe();
            untracked(() => {
                setTimeout(() => {
                    const activeItem = tabs.find((tab) => tab.isActive()) ?? tabs.find((tab) => !tab.disabled);
                    const activeItemIndex = tabs.findIndex((tab) => tab === activeItem);
                    this.#focusKeyManager?.updateActiveItem(activeItemIndex < 0 ? 0 : activeItemIndex);
                    this.tabsService.activeItemKey.set(this.#focusKeyManager.activeItem?.itemKey());
                    this.tabsService.activeItem.set(this.#focusKeyManager.activeItem);
                });
            });
        });
        this.#tabsServiceEffect = effect(() => {
            const activeItemIndex = this.tabs().findIndex((tab) => untracked(tab.isActive) && untracked(tab.itemKey) === this.tabsService.activeItemKey());
            this.#focusKeyManager?.updateActiveItem(activeItemIndex < 0 ? 0 : activeItemIndex);
        });
    }
    #destroyRef;
    #focusKeyManager;
    #tabsEffect;
    #tabsServiceEffect;
    onKeydown($event) {
        if (['ArrowLeft', 'ArrowRight'].includes($event.key)) {
            this.#focusKeyManager.onKeydown($event);
            return;
        }
        if (['Tab'].includes($event.key)) {
            this.#focusKeyManager?.tabOut.next();
        }
        return;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabsListComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "19.2.2", type: TabsListComponent, isStandalone: true, selector: "c-tabs-list", inputs: { layout: { classPropertyName: "layout", publicName: "layout", isSignal: true, isRequired: false, transformFunction: null }, variant: { classPropertyName: "variant", publicName: "variant", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "keydown": "onKeydown($event)" }, properties: { "attr.role": "role()", "class": "hostClasses()" } }, queries: [{ propertyName: "tabs", predicate: TabDirective, isSignal: true }], exportAs: ["cTabsList"], ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabsListComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'cTabsList',
                    selector: 'c-tabs-list',
                    imports: [],
                    template: '<ng-content />',
                    host: {
                        '[attr.role]': 'role()',
                        '[class]': 'hostClasses()'
                    }
                }]
        }], propDecorators: { onKeydown: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }] } });

class TabsContentComponent {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabsContentComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: TabsContentComponent, isStandalone: true, selector: "c-tabs-content", host: { classAttribute: "tab-content" }, exportAs: ["cTabsContent"], ngImport: i0, template: '<ng-content />', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabsContentComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'cTabsContent',
                    selector: 'c-tabs-content',
                    template: '<ng-content />',
                    host: {
                        class: 'tab-content'
                    }
                }]
        }] });

class TabPanelComponent {
    constructor() {
        this.tabsService = inject(TabsService);
        /**
         * aria-labelledby attribute
         * @type string
         * @default undefined
         */
        this.ariaLabelledBy = input(undefined, {
            alias: 'aria-labelledby'
        });
        /**
         * Element id attribute
         * @type string
         * @default undefined
         */
        this.id = input();
        /**
         * Item key.
         * @type string | number
         * @required
         */
        this.itemKey = input.required();
        /**
         * tabindex attribute.
         * @type number
         * @default 0
         */
        this.tabindex = input(0, { transform: numberAttribute });
        /**
         * Enable fade in transition.
         * @type boolean
         * @default true
         */
        this.transition = input(true);
        /**
         * visible change output
         * @type OutputEmitterRef<VisibleChangeEvent>
         */
        this.visibleChange = output();
        this.show = signal(false);
        this.visible = computed(() => {
            const visible = this.tabsService.activeItemKey() === this.itemKey() && !this.tabsService.activeItem()?.disabled;
            this.visibleChange.emit({ itemKey: this.itemKey(), visible });
            return visible;
        });
        this.propId = computed(() => this.id() ?? `${this.tabsService.id()}-panel-${this.itemKey()}`);
        this.attrAriaLabelledBy = computed(() => this.ariaLabelledBy() ?? `${this.tabsService.id()}-tab-${this.itemKey()}`);
        this.hostClasses = computed(() => ({
            'tab-pane': true,
            active: this.show(),
            fade: this.transition(),
            show: this.show(),
            invisible: this.tabsService.activeItem()?.disabled
        }));
    }
    get animationDisabled() {
        return !this.transition();
    }
    get animateType() {
        return this.visible() ? 'show' : 'hide';
    }
    onAnimationDone($event) {
        this.show.set(this.visible());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabPanelComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: TabPanelComponent, isStandalone: true, selector: "c-tab-panel", inputs: { ariaLabelledBy: { classPropertyName: "ariaLabelledBy", publicName: "aria-labelledby", isSignal: true, isRequired: false, transformFunction: null }, id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, itemKey: { classPropertyName: "itemKey", publicName: "itemKey", isSignal: true, isRequired: true, transformFunction: null }, tabindex: { classPropertyName: "tabindex", publicName: "tabindex", isSignal: true, isRequired: false, transformFunction: null }, transition: { classPropertyName: "transition", publicName: "transition", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { visibleChange: "visibleChange" }, host: { attributes: { "role": "tabpanel" }, listeners: { "@fadeInOut.done": "onAnimationDone($event)" }, properties: { "class": "hostClasses()", "tabindex": "visible() ? tabindex(): -1", "attr.aria-labelledby": "attrAriaLabelledBy()", "id": "propId()", "@.disabled": "this.animationDisabled", "@fadeInOut": "this.animateType" } }, exportAs: ["cTabPanel"], ngImport: i0, template: '<ng-content />', isInline: true, animations: [
            trigger('fadeInOut', [
                state('show', style({ opacity: 1 })),
                state('hide', style({ opacity: 0 })),
                state('void', style({ opacity: 1 })),
                transition('* => *', [query('@*', [animateChild()], { optional: true }), animate('150ms linear')])
            ])
        ] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TabPanelComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'cTabPanel',
                    selector: 'c-tab-panel',
                    template: '<ng-content />',
                    host: {
                        '[class]': 'hostClasses()',
                        '[tabindex]': 'visible() ? tabindex(): -1',
                        '[attr.aria-labelledby]': 'attrAriaLabelledBy()',
                        '[id]': 'propId()',
                        role: 'tabpanel'
                    },
                    animations: [
                        trigger('fadeInOut', [
                            state('show', style({ opacity: 1 })),
                            state('hide', style({ opacity: 0 })),
                            state('void', style({ opacity: 1 })),
                            transition('* => *', [query('@*', [animateChild()], { optional: true }), animate('150ms linear')])
                        ])
                    ]
                }]
        }], propDecorators: { animationDisabled: [{
                type: HostBinding,
                args: ['@.disabled']
            }], animateType: [{
                type: HostBinding,
                args: ['@fadeInOut']
            }], onAnimationDone: [{
                type: HostListener,
                args: ['@fadeInOut.done', ['$event']]
            }] } });

class Tabs2Module {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: Tabs2Module, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: Tabs2Module, imports: [TabsComponent, TabsListComponent, TabDirective, TabsContentComponent, TabPanelComponent], exports: [TabsComponent, TabsListComponent, TabDirective, TabsContentComponent, TabPanelComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: Tabs2Module, providers: [TabsService] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: Tabs2Module, decorators: [{
            type: NgModule,
            args: [{
                    imports: [TabsComponent, TabsListComponent, TabDirective, TabsContentComponent, TabPanelComponent],
                    exports: [TabsComponent, TabsListComponent, TabDirective, TabsContentComponent, TabPanelComponent],
                    providers: [TabsService]
                }]
        }] });

class ToasterService {
    constructor() {
        this.#toasterState = new BehaviorSubject({});
        this.toasterState$ = this.#toasterState.asObservable();
    }
    #toasterState;
    setState(state) {
        this.#toasterState.next({ ...state });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ToasterService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ToasterService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ToasterService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }] });

class ToastComponent {
    constructor() {
        this.changeDetectorRef = inject(ChangeDetectorRef);
        this.hostElement = inject(ElementRef);
        this.renderer = inject(Renderer2);
        this.toasterService = inject(ToasterService);
        this.dynamic = input();
        this.placementInput = input(undefined, { alias: 'placement' });
        /**
         * Auto hide the toast.
         * @return boolean
         */
        this.autohide = input(true);
        /**
         * Sets the color context of the component to one of CoreUI’s themed colors.
         * @return Colors
         */
        this.color = input('');
        /**
         * Delay hiding the toast (ms).
         * @return number
         */
        this.delay = input(5000, { transform: numberAttribute });
        /**
         * Apply fade transition to the toast.
         * @return boolean
         */
        this.fade = input(true);
        /**
         * Toggle the visibility of component.
         * @return boolean
         */
        this.visibleInput = input(false, { transform: booleanAttribute, alias: 'visible' });
        this.#visibleInputEffect = effect(() => {
            this.visible = this.visibleInput();
        });
        this.#visible = false;
        /**
         * @ignore
         */
        this.index = input(0, { transform: numberAttribute });
        /**
         * Event emitted on visibility change. [docs]
         * @return <boolean>
         */
        this.visibleChange = output();
        /**
         * Event emitted on timer tick. [docs]
         * @return number
         */
        this.timer = output();
        this.animationDisabled = computed(() => {
            return !this.fade();
        });
        this.hostClasses = computed(() => {
            const color = this.color();
            return {
                toast: true,
                show: true,
                [`bg-${color}`]: !!color,
                'border-0': !!color
            };
        });
    }
    get placement() {
        return this.placementInput();
    }
    #visibleInputEffect;
    set visible(value) {
        const newValue = value;
        if (this.#visible !== newValue) {
            this.#visible = newValue;
            newValue ? this.setTimer() : this.clearTimer();
            this.visibleChange.emit(newValue);
            this.changeDetectorRef.markForCheck();
        }
    }
    get visible() {
        return this.#visible;
    }
    #visible;
    get clock() {
        return this._clock;
    }
    set clock(value) {
        this._clock = value;
        this.timer.emit(this._clock);
        this.changeDetectorRef.markForCheck();
    }
    get animateType() {
        return this.visible ? 'show' : 'hide';
    }
    ngOnInit() {
        if (this.visible) {
            this.toasterService.setState({
                toast: this,
                show: this.visible,
                placement: this.placement
            });
            this.clearTimer();
            this.setTimer();
        }
    }
    ngOnDestroy() {
        this.clearTimer();
    }
    setTimer() {
        this.clearTimer();
        if (this.autohide() && this.visible) {
            this.timerId = this.delay() > 0 ? setTimeout(() => this.onClose(), this.delay()) : undefined;
            this.setClock();
        }
    }
    clearTimer() {
        this.clearClock();
        clearTimeout(this.timerId);
        this.timerId = undefined;
    }
    onClose() {
        this.clearTimer();
        this.toasterService.setState({
            toast: this,
            show: false,
            placement: this.placement
        });
    }
    setClock() {
        this.clearClock();
        this.clock = 0;
        this.clockId = setInterval(() => {
            this.clock += 1;
            this.changeDetectorRef.markForCheck();
        }, 1000);
        this.clockTimerId = setTimeout(() => {
            this.clearClock();
        }, this.delay());
    }
    clearClock() {
        clearTimeout(this.clockTimerId);
        clearInterval(this.clockId);
        this.clockId = undefined;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ToastComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "19.2.2", type: ToastComponent, isStandalone: true, selector: "c-toast", inputs: { dynamic: { classPropertyName: "dynamic", publicName: "dynamic", isSignal: true, isRequired: false, transformFunction: null }, placementInput: { classPropertyName: "placementInput", publicName: "placement", isSignal: true, isRequired: false, transformFunction: null }, autohide: { classPropertyName: "autohide", publicName: "autohide", isSignal: true, isRequired: false, transformFunction: null }, color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null }, delay: { classPropertyName: "delay", publicName: "delay", isSignal: true, isRequired: false, transformFunction: null }, fade: { classPropertyName: "fade", publicName: "fade", isSignal: true, isRequired: false, transformFunction: null }, visibleInput: { classPropertyName: "visibleInput", publicName: "visible", isSignal: true, isRequired: false, transformFunction: null }, index: { classPropertyName: "index", publicName: "index", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { visibleChange: "visibleChange", timer: "timer" }, host: { listeners: { "mouseover": "clearTimer()", "mouseout": "setTimer()" }, properties: { "class": "hostClasses()", "@fadeInOut": "animateType", "@.disabled": "animationDisabled()" }, classAttribute: "toast show" }, exportAs: ["cToast"], ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block;overflow:hidden}\n"], animations: [
            trigger('fadeInOut', [
                state('show', style({ opacity: 1, height: '*', padding: '*', border: '*', margin: '*' })),
                state('hide', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                state('void', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                transition('show => hide', [animate('{{ time }} {{ easing }}')], {
                    params: { time: '300ms', easing: 'ease-out' }
                }),
                transition('hide => show', [animate('{{ time }} {{ easing }}')], {
                    params: { time: '300ms', easing: 'ease-in' }
                }),
                transition('show => void', [animate('{{ time }} {{ easing }}')], {
                    params: { time: '300ms', easing: 'ease-out' }
                }),
                transition('void => show', [animate('{{ time }} {{ easing }}')], {
                    params: { time: '300ms', easing: 'ease-in' }
                })
            ])
        ] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ToastComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-toast', template: '<ng-content />', exportAs: 'cToast', animations: [
                        trigger('fadeInOut', [
                            state('show', style({ opacity: 1, height: '*', padding: '*', border: '*', margin: '*' })),
                            state('hide', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                            state('void', style({ opacity: 0, height: 0, padding: 0, border: 0, margin: 0 })),
                            transition('show => hide', [animate('{{ time }} {{ easing }}')], {
                                params: { time: '300ms', easing: 'ease-out' }
                            }),
                            transition('hide => show', [animate('{{ time }} {{ easing }}')], {
                                params: { time: '300ms', easing: 'ease-in' }
                            }),
                            transition('show => void', [animate('{{ time }} {{ easing }}')], {
                                params: { time: '300ms', easing: 'ease-out' }
                            }),
                            transition('void => show', [animate('{{ time }} {{ easing }}')], {
                                params: { time: '300ms', easing: 'ease-in' }
                            })
                        ])
                    ], host: {
                        class: 'toast show',
                        '[class]': 'hostClasses()',
                        '(mouseover)': 'clearTimer()',
                        '(mouseout)': 'setTimer()',
                        '[@fadeInOut]': 'animateType',
                        '[@.disabled]': 'animationDisabled()'
                    }, styles: [":host{display:block;overflow:hidden}\n"] }]
        }] });

class ToastBodyComponent {
    constructor() {
        this.toast = inject(ToastComponent, { optional: true });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ToastBodyComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.2", type: ToastBodyComponent, isStandalone: true, selector: "c-toast-body", host: { classAttribute: "toast-body" }, exportAs: ["cToastBody"], ngImport: i0, template: '<ng-content />', isInline: true, styles: [":host{display:block}\n"] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ToastBodyComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-toast-body', template: '<ng-content />', exportAs: 'cToastBody', host: {
                        class: 'toast-body',
                    }, styles: [":host{display:block}\n"] }]
        }] });

class ToastCloseDirective {
    constructor() {
        this.#toasterService = inject(ToasterService);
        this.cToastClose = input();
    }
    #toasterService;
    toggleOpen($event) {
        $event.preventDefault();
        this.#toasterService.setState({ show: false, toast: this.cToastClose() });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ToastCloseDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: ToastCloseDirective, isStandalone: true, selector: "[cToastClose]", inputs: { cToastClose: { classPropertyName: "cToastClose", publicName: "cToastClose", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "toggleOpen($event)" } }, exportAs: ["cToastClose"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ToastCloseDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cToastClose]',
                    exportAs: 'cToastClose',
                    host: {
                        '(click)': 'toggleOpen($event)'
                    }
                }]
        }] });

class ToastHeaderComponent {
    constructor() {
        this.#toast = inject(ToastComponent, { optional: true });
        this.toast = signal(this.#toast ?? undefined);
        /**
         * Add close button to a toast header
         * @return boolean
         */
        this.closeButton = input(true);
    }
    #toast;
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ToastHeaderComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.2", type: ToastHeaderComponent, isStandalone: true, selector: "c-toast-header", inputs: { closeButton: { classPropertyName: "closeButton", publicName: "closeButton", isSignal: true, isRequired: false, transformFunction: null } }, host: { classAttribute: "toast-header" }, exportAs: ["cToastHeader"], ngImport: i0, template: "<ng-container>\n  <ng-content />\n  @if (closeButton()) {\n    <button [cToastClose]=\"toast()\" [style]=\"{outline: 0}\" aria-label=\"close\" cButtonClose class=\"ms-auto\"></button>\n  }\n</ng-container>\n", dependencies: [{ kind: "directive", type: ToastCloseDirective, selector: "[cToastClose]", inputs: ["cToastClose"], exportAs: ["cToastClose"] }, { kind: "directive", type: ButtonCloseDirective, selector: "[cButtonClose]", inputs: ["white"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ToastHeaderComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-toast-header', exportAs: 'cToastHeader', imports: [ToastCloseDirective, ButtonCloseDirective], host: {
                        class: 'toast-header'
                    }, template: "<ng-container>\n  <ng-content />\n  @if (closeButton()) {\n    <button [cToastClose]=\"toast()\" [style]=\"{outline: 0}\" aria-label=\"close\" cButtonClose class=\"ms-auto\"></button>\n  }\n</ng-container>\n" }]
        }] });

class ToasterHostDirective {
    constructor() {
        this.viewContainerRef = inject(ViewContainerRef);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ToasterHostDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.2", type: ToasterHostDirective, isStandalone: true, selector: "[cToasterHost]", exportAs: ["cToasterHost"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ToasterHostDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cToasterHost]',
                    exportAs: 'cToasterHost'
                }]
        }] });

var ToasterPlacement;
(function (ToasterPlacement) {
    ToasterPlacement["Static"] = "static";
    ToasterPlacement["TopStart"] = "top-start";
    ToasterPlacement["TopCenter"] = "top-center";
    ToasterPlacement["TopEnd"] = "top-end";
    ToasterPlacement["MiddleStart"] = "middle-start";
    ToasterPlacement["MiddleCenter"] = "middle-center";
    ToasterPlacement["MiddleEnd"] = "middle-end";
    ToasterPlacement["BottomStart"] = "bottom-start";
    ToasterPlacement["BottomCenter"] = "bottom-center";
    ToasterPlacement["BottomEnd"] = "bottom-end";
})(ToasterPlacement || (ToasterPlacement = {}));
class ToasterComponent {
    constructor() {
        this.#hostElement = inject(ElementRef);
        this.#renderer = inject(Renderer2);
        this.#toasterService = inject(ToasterService);
        this.#destroyRef = inject(DestroyRef);
        this.placements = Object.values(ToasterPlacement);
        this.toastsDynamic = [];
        /**
         * Toaster placement
         * @return TToasterPlacement
         */
        this.placementInput = input(ToasterPlacement.TopEnd, { alias: 'placement' });
        /**
         * Toaster position
         * @return (string | 'absolute' | 'fixed' | 'static')
         */
        this.position = input('absolute');
        this.toasterHost = viewChild.required(ToasterHostDirective);
        this.contentToasts = contentChildren(ToastComponent, { read: ViewContainerRef });
        this.hostClasses = computed(() => {
            const placement = this.placement;
            const position = this.position();
            return {
                toaster: true,
                'toast-container': true,
                [`position-${position}`]: !!position,
                'top-0': placement.includes('top'),
                'top-50': placement.includes('middle'),
                'bottom-0': placement.includes('bottom'),
                'start-0': placement.includes('start'),
                'start-50': placement.includes('center'),
                'end-0': placement.includes('end'),
                'translate-middle-x': placement.includes('center') && !placement.includes('middle'),
                'translate-middle-y': placement.includes('middle') && !placement.includes('center'),
                'translate-middle': placement.includes('middle') && placement.includes('center')
            };
        });
    }
    #hostElement;
    #renderer;
    #toasterService;
    #destroyRef;
    get placement() {
        return this.placementInput();
    }
    ngOnInit() {
        this.stateToasterSubscribe();
    }
    addToast(toast, props, options) {
        const componentRef = this.toasterHost().viewContainerRef.createComponent(toast, options);
        this.toastsDynamic.push(componentRef);
        const index = this.toastsDynamic.indexOf(componentRef);
        for (const [key, value] of Object.entries(props)) {
            componentRef.setInput(key, value);
        }
        componentRef.setInput('placement', this.placement);
        componentRef.setInput('dynamic', true);
        componentRef.setInput('index', index);
        componentRef.setInput('visible', true);
        componentRef.instance['visibleChange'].emit(true);
        componentRef.changeDetectorRef?.detectChanges();
        return componentRef;
    }
    removeToast(state) {
        this.toastsDynamic?.forEach((item) => {
            if (state.toast?.dynamic() && item.instance === state.toast) {
                item.setInput('visible', false);
                item.instance['visibleChange'].emit(false);
                item.destroy();
            }
        });
        this.contentToasts()?.forEach((item) => {
            if (state.toast && item.element.nativeElement === state.toast.hostElement.nativeElement) {
                if (!state.toast.dynamic()) {
                    state.toast['visible'] = false;
                }
            }
        });
    }
    stateToasterSubscribe() {
        this.#toasterService.toasterState$.pipe(takeUntilDestroyed(this.#destroyRef)).subscribe((state) => {
            if (state.show === false) {
                this.removeToast(state);
            }
            // if (state.show === true && state.toast?.dynamic() === undefined) {
            //   /* empty */
            // }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ToasterComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "19.2.2", type: ToasterComponent, isStandalone: true, selector: "c-toaster", inputs: { placementInput: { classPropertyName: "placementInput", publicName: "placement", isSignal: true, isRequired: false, transformFunction: null }, position: { classPropertyName: "position", publicName: "position", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "toaster toast-container" }, queries: [{ propertyName: "contentToasts", predicate: ToastComponent, read: ViewContainerRef, isSignal: true }], viewQueries: [{ propertyName: "toasterHost", first: true, predicate: ToasterHostDirective, descendants: true, isSignal: true }], exportAs: ["cToaster"], ngImport: i0, template: "<ng-template cToasterHost />\n<ng-content cToasterHost />\n", dependencies: [{ kind: "directive", type: ToasterHostDirective, selector: "[cToasterHost]", exportAs: ["cToasterHost"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ToasterComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-toaster', exportAs: 'cToaster', imports: [ToasterHostDirective], host: {
                        class: 'toaster toast-container',
                        '[class]': 'hostClasses()'
                    }, template: "<ng-template cToasterHost />\n<ng-content cToasterHost />\n" }]
        }] });

class ToastModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ToastModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: ToastModule, imports: [ToastBodyComponent,
            ToastComponent,
            ToastCloseDirective,
            ToastHeaderComponent,
            ToasterComponent,
            ToasterHostDirective], exports: [ToastBodyComponent,
            ToastComponent,
            ToastCloseDirective,
            ToastHeaderComponent,
            ToasterComponent,
            ToasterHostDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ToastModule, providers: [ToasterService] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: ToastModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        ToastBodyComponent,
                        ToastComponent,
                        ToastCloseDirective,
                        ToastHeaderComponent,
                        ToasterComponent,
                        ToasterHostDirective
                    ],
                    providers: [ToasterService],
                    exports: [
                        ToastBodyComponent,
                        ToastComponent,
                        ToastCloseDirective,
                        ToastHeaderComponent,
                        ToasterComponent,
                        ToasterHostDirective
                    ]
                }]
        }] });

class TooltipComponent {
    constructor() {
        this.renderer = inject(Renderer2);
        /**
         * Content of tooltip
         * @type {string | TemplateRef}
         */
        this.content = input('');
        this.#contentEffect = effect(() => {
            this.updateView(this.content());
        });
        /**
         * Toggle the visibility of popover component.
         * @type boolean
         */
        this.visible = input(false, { transform: booleanAttribute });
        this.id = input();
        this.role = input('tooltip');
        this.viewContainerRef = viewChild('tooltipTemplate', { read: ViewContainerRef });
        this.hostClasses = computed(() => {
            return {
                tooltip: true,
                fade: true,
                show: this.visible(),
                'bs-tooltip-auto': true
            };
        });
    }
    #contentEffect;
    ngOnDestroy() {
        this.clear();
    }
    clear() {
        this.viewContainerRef()?.clear();
        if (!!this.textNode) {
            this.renderer.removeChild(this.textNode.parentNode, this.textNode);
        }
    }
    updateView(content) {
        this.clear();
        if (!content) {
            return;
        }
        if (content instanceof TemplateRef) {
            this.viewContainerRef()?.createEmbeddedView(content);
        }
        else {
            this.textNode = this.renderer.createText(content);
            const element = this.viewContainerRef()?.element.nativeElement;
            this.renderer.appendChild(element.parentNode, this.textNode);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TooltipComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.2.0", version: "19.2.2", type: TooltipComponent, isStandalone: true, selector: "c-tooltip", inputs: { content: { classPropertyName: "content", publicName: "content", isSignal: true, isRequired: false, transformFunction: null }, visible: { classPropertyName: "visible", publicName: "visible", isSignal: true, isRequired: false, transformFunction: null }, id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "role", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()", "attr.role": "role()", "attr.id": "id()" }, classAttribute: "tooltip fade bs-tooltip-auto" }, viewQueries: [{ propertyName: "viewContainerRef", first: true, predicate: ["tooltipTemplate"], descendants: true, read: ViewContainerRef, isSignal: true }], ngImport: i0, template: "<ng-container>\n  <div class=\"tooltip-arrow\" data-popper-arrow></div>\n  <div class=\"tooltip-inner\">\n    <ng-container #tooltipTemplate />\n  </div>\n</ng-container>\n" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TooltipComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-tooltip', host: {
                        class: 'tooltip fade bs-tooltip-auto',
                        '[class]': 'hostClasses()',
                        '[attr.role]': 'role()',
                        '[attr.id]': 'id()'
                    }, template: "<ng-container>\n  <div class=\"tooltip-arrow\" data-popper-arrow></div>\n  <div class=\"tooltip-inner\">\n    <ng-container #tooltipTemplate />\n  </div>\n</ng-container>\n" }]
        }] });

class TooltipDirective {
    constructor() {
        this.#renderer = inject(Renderer2);
        this.#hostElement = inject(ElementRef);
        this.#viewContainerRef = inject(ViewContainerRef);
        this.#listenersService = inject(ListenersService);
        this.#changeDetectorRef = inject(ChangeDetectorRef);
        this.#intersectionService = inject(IntersectionService);
        this.#destroyRef = inject(DestroyRef);
        this.#document = inject(DOCUMENT);
        /**
         * Content of tooltip
         * @return {string | TemplateRef}
         */
        this.content = input(undefined, { alias: 'cTooltip' });
        this.#contentEffect = effect(() => {
            if (this.content()) {
                this.destroyTooltipElement();
            }
        });
        /**
         * Optional popper Options object, takes precedence over cPopoverPlacement prop
         * @return Partial<Options>
         */
        this.popperOptions = input({}, { alias: 'cTooltipOptions' });
        this.#popperOptionsEffect = effect(() => {
            this._popperOptions = {
                ...this._popperOptions,
                placement: this.placement(),
                ...this.popperOptions()
            };
        });
        this.popperOptionsComputed = computed(() => {
            return { placement: this.placement(), ...this._popperOptions };
        });
        /**
         * Describes the placement of your component after Popper.js has applied all the modifiers that may have flipped or altered the originally provided placement property.
         * @return: 'top' | 'bottom' | 'left' | 'right'
         * @default: 'top'
         */
        this.placement = input('top', { alias: 'cTooltipPlacement' });
        /**
         * ElementRefDirective for positioning the tooltip on reference element
         * @return: ElementRefDirective
         * @default: undefined
         */
        this.reference = input(undefined, { alias: 'cTooltipRef' });
        this.referenceRef = computed(() => this.reference()?.elementRef ?? this.#hostElement);
        /**
         * Sets which event handlers you’d like provided to your toggle prop. You can specify one trigger or an array of them.
         * @return: 'Triggers | Triggers[]
         */
        this.trigger = input('hover', { alias: 'cTooltipTrigger' });
        /**
         * Toggle the visibility of tooltip component.
         * @return boolean
         */
        this.visible = model(false, { alias: 'cTooltipVisible' });
        this.#visibleEffect = effect(() => {
            this.visible() ? this.addTooltipElement() : this.removeTooltipElement();
        });
        this._popperOptions = {
            modifiers: [
                {
                    name: 'offset',
                    options: {
                        offset: [0, 5]
                    }
                }
            ]
        };
    }
    #renderer;
    #hostElement;
    #viewContainerRef;
    #listenersService;
    #changeDetectorRef;
    #intersectionService;
    #destroyRef;
    #document;
    #contentEffect;
    #popperOptionsEffect;
    #visibleEffect;
    get ariaDescribedBy() {
        return this.tooltipId ? this.tooltipId : null;
    }
    ngAfterViewInit() {
        this.intersectionServiceSubscribe();
    }
    ngOnDestroy() {
        this.clearListeners();
        this.destroyTooltipElement();
    }
    ngOnInit() {
        this.setListeners();
    }
    setListeners() {
        const config = {
            hostElement: this.#hostElement,
            trigger: this.trigger(),
            callbackToggle: () => {
                this.visible.update((value) => !value);
            },
            callbackOff: () => {
                this.visible.set(false);
            },
            callbackOn: () => {
                this.visible.set(true);
            }
        };
        this.#listenersService.setListeners(config);
    }
    clearListeners() {
        this.#listenersService.clearListeners();
    }
    intersectionServiceSubscribe() {
        this.#intersectionService.createIntersectionObserver(this.referenceRef());
        this.#intersectionService.intersecting$
            .pipe(filter((next) => next.hostElement === this.referenceRef()), debounceTime(100), finalize(() => {
            this.#intersectionService.unobserve(this.referenceRef());
        }), takeUntilDestroyed(this.#destroyRef))
            .subscribe((next) => {
            this.visible.set(next.isIntersecting ? this.visible() : false);
        });
    }
    getUID(prefix) {
        let uid = prefix ?? 'random-id';
        do {
            uid = `${prefix}-${Math.floor(Math.random() * 1000000).toString(10)}`;
        } while (this.#document.getElementById(uid));
        return uid;
    }
    createTooltipElement() {
        if (!this.tooltipRef) {
            this.tooltipRef = this.#viewContainerRef.createComponent(TooltipComponent);
            // this.viewContainerRef.detach();
        }
    }
    destroyTooltipElement() {
        this.tooltip?.remove();
        this.tooltipRef?.destroy();
        // @ts-ignore
        this.tooltipRef = undefined;
        this.popperInstance?.destroy();
        this.#viewContainerRef?.detach();
        this.#viewContainerRef?.clear();
    }
    addTooltipElement() {
        if (!this.content()) {
            this.destroyTooltipElement();
            return;
        }
        if (!this.tooltipRef) {
            this.createTooltipElement();
        }
        this.tooltipRef?.setInput('content', this.content() ?? '');
        this.tooltip = this.tooltipRef?.location.nativeElement;
        this.#renderer.addClass(this.tooltip, 'd-none');
        this.#renderer.addClass(this.tooltip, 'fade');
        this.popperInstance?.destroy();
        this.#viewContainerRef.insert(this.tooltipRef.hostView);
        this.#renderer.appendChild(this.#document.body, this.tooltip);
        this.popperInstance = createPopper(this.referenceRef().nativeElement, this.tooltip, {
            ...this.popperOptionsComputed()
        });
        if (!this.visible()) {
            this.removeTooltipElement();
            return;
        }
        setTimeout(() => {
            this.tooltipId = this.getUID('tooltip');
            this.tooltipRef?.setInput('id', this.tooltipId);
            this.#renderer.removeClass(this.tooltip, 'd-none');
            this.tooltipRef?.setInput('visible', this.visible());
            this.popperInstance?.forceUpdate();
            this.#changeDetectorRef?.markForCheck();
        }, 100);
    }
    removeTooltipElement() {
        this.tooltipId = '';
        if (!this.tooltipRef) {
            return;
        }
        this.tooltipRef.setInput('visible', false);
        this.tooltipRef.setInput('id', undefined);
        this.#changeDetectorRef.markForCheck();
        setTimeout(() => {
            this.#viewContainerRef?.detach();
        }, 300);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TooltipDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.2", type: TooltipDirective, isStandalone: true, selector: "[cTooltip]", inputs: { content: { classPropertyName: "content", publicName: "cTooltip", isSignal: true, isRequired: false, transformFunction: null }, popperOptions: { classPropertyName: "popperOptions", publicName: "cTooltipOptions", isSignal: true, isRequired: false, transformFunction: null }, placement: { classPropertyName: "placement", publicName: "cTooltipPlacement", isSignal: true, isRequired: false, transformFunction: null }, reference: { classPropertyName: "reference", publicName: "cTooltipRef", isSignal: true, isRequired: false, transformFunction: null }, trigger: { classPropertyName: "trigger", publicName: "cTooltipTrigger", isSignal: true, isRequired: false, transformFunction: null }, visible: { classPropertyName: "visible", publicName: "cTooltipVisible", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { visible: "cTooltipVisibleChange" }, host: { properties: { "attr.aria-describedby": "ariaDescribedBy" } }, providers: [ListenersService, IntersectionService], exportAs: ["cTooltip"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TooltipDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[cTooltip]',
                    exportAs: 'cTooltip',
                    providers: [ListenersService, IntersectionService],
                    host: { '[attr.aria-describedby]': 'ariaDescribedBy' }
                }]
        }] });

class TooltipModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TooltipModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: TooltipModule, imports: [TooltipComponent,
            TooltipDirective], exports: [TooltipComponent,
            TooltipDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TooltipModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: TooltipModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [
                        TooltipComponent,
                        TooltipDirective
                    ],
                    imports: [
                        TooltipComponent,
                        TooltipDirective
                    ]
                }]
        }] });

class WidgetStatAComponent extends CardComponent {
    constructor() {
        super(...arguments);
        /**
         * Sets the color context of the component to one of CoreUI’s themed colors.
         * @type Colors
         */
        // override readonly color = input<Colors>();
        /**
         * Title of the widget to display
         * @type string
         */
        this.title = input();
        /**
         * Value for your widget to display
         * @type string
         */
        this.value = input();
        this.templates = {};
        this.contentTemplates = contentChildren(TemplateIdDirective, { descendants: true });
        this.#contentTemplatesEffect = effect(() => {
            this.contentTemplates().forEach((child) => {
                this.templates[child.id] = child.templateRef;
            });
        });
        this.hostClasses = computed(() => {
            const color = this.color();
            return {
                card: true,
                [`bg-${color}`]: !!color,
                'text-white': !!color
            };
        });
    }
    #contentTemplatesEffect;
    get bodyClasses() {
        return {
            'pb-0': true,
            'd-flex': true,
            'justify-content-between': true,
            'align-items-start': true
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: WidgetStatAComponent, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.2", type: WidgetStatAComponent, isStandalone: true, selector: "c-widget-stat-a", inputs: { title: { classPropertyName: "title", publicName: "title", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "value", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "card" }, queries: [{ propertyName: "contentTemplates", predicate: TemplateIdDirective, descendants: true, isSignal: true }], exportAs: ["cWidgetStatA"], usesInheritance: true, ngImport: i0, template: "<ng-container>\n  <c-card-body [ngClass]=\"bodyClasses\">\n    <div>\n      @if (!!value() || templates?.['widgetValueTemplate']) {\n        <div class=\"fs-4 fw-semibold\">\n          <ng-container *ngTemplateOutlet=\"templates?.['widgetValueTemplate'] || defaultWidgetValueTemplate\" />\n        </div>\n      }\n      @if (!!title() || templates?.['widgetTitleTemplate']) {\n        <div>\n          <ng-container *ngTemplateOutlet=\"templates?.['widgetTitleTemplate'] || defaultWidgetTitleTemplate\" />\n        </div>\n      }\n    </div>\n    <ng-container *ngTemplateOutlet=\"templates?.['widgetActionTemplate'] || defaultWidgetActionTemplate\" />\n  </c-card-body>\n  <ng-container *ngTemplateOutlet=\"templates?.['widgetChartTemplate'] || defaultWidgetChartTemplate\" />\n</ng-container>\n\n<ng-template #defaultWidgetTitleTemplate>\n  {{ title() }}\n</ng-template>\n\n<ng-template #defaultWidgetValueTemplate>\n  {{ value() }}\n</ng-template>\n\n<ng-template #defaultWidgetChartTemplate>\n  <ng-content select=\".chart-wrapper\" />\n</ng-template>\n\n<ng-template #defaultWidgetActionTemplate>\n  <ng-content />\n</ng-template>\n", dependencies: [{ kind: "component", type: CardBodyComponent, selector: "c-card-body, [c-card-body]" }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: WidgetStatAComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-widget-stat-a', exportAs: 'cWidgetStatA', imports: [CardBodyComponent, NgClass, NgTemplateOutlet], host: { class: 'card', '[class]': 'hostClasses()' }, template: "<ng-container>\n  <c-card-body [ngClass]=\"bodyClasses\">\n    <div>\n      @if (!!value() || templates?.['widgetValueTemplate']) {\n        <div class=\"fs-4 fw-semibold\">\n          <ng-container *ngTemplateOutlet=\"templates?.['widgetValueTemplate'] || defaultWidgetValueTemplate\" />\n        </div>\n      }\n      @if (!!title() || templates?.['widgetTitleTemplate']) {\n        <div>\n          <ng-container *ngTemplateOutlet=\"templates?.['widgetTitleTemplate'] || defaultWidgetTitleTemplate\" />\n        </div>\n      }\n    </div>\n    <ng-container *ngTemplateOutlet=\"templates?.['widgetActionTemplate'] || defaultWidgetActionTemplate\" />\n  </c-card-body>\n  <ng-container *ngTemplateOutlet=\"templates?.['widgetChartTemplate'] || defaultWidgetChartTemplate\" />\n</ng-container>\n\n<ng-template #defaultWidgetTitleTemplate>\n  {{ title() }}\n</ng-template>\n\n<ng-template #defaultWidgetValueTemplate>\n  {{ value() }}\n</ng-template>\n\n<ng-template #defaultWidgetChartTemplate>\n  <ng-content select=\".chart-wrapper\" />\n</ng-template>\n\n<ng-template #defaultWidgetActionTemplate>\n  <ng-content />\n</ng-template>\n" }]
        }] });

class WidgetStatBComponent extends CardComponent {
    constructor() {
        super();
        /**
         * Sets the color context of the component to one of CoreUI themed colors.
         * @type Colors
         */
        // override readonly color: InputSignal<Colors | undefined> = input();
        /**
         * Sets the text-color context of the component to one of CoreUI themed colors.
         * via TextColorDirective
         * @type TextColors
         */
        // override readonly textColor: InputSignal<TextColors | undefined> = input();
        /**
         * Title of the widget to display
         * @type string
         */
        this.title = input();
        /**
         * Helper text for your widget.
         * @type string
         */
        this.text = input();
        /**
         * Value for your widget to display
         * @type string
         */
        this.value = input();
        /**
         * Invert colors from their default dark shade.
         * @type boolean
         */
        this.inverse = input(false, { transform: booleanAttribute });
        this.hostClasses = computed(() => {
            const color = this.color();
            const textColor = this.textColor();
            return {
                card: true,
                [`bg-${color}`]: !!color,
                [`text-${textColor}`]: !!textColor,
                'text-white': this.inverse()
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: WidgetStatBComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.2", type: WidgetStatBComponent, isStandalone: true, selector: "c-widget-stat-b", inputs: { title: { classPropertyName: "title", publicName: "title", isSignal: true, isRequired: false, transformFunction: null }, text: { classPropertyName: "text", publicName: "text", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "value", isSignal: true, isRequired: false, transformFunction: null }, inverse: { classPropertyName: "inverse", publicName: "inverse", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "card" }, exportAs: ["cWidgetStatB"], usesInheritance: true, ngImport: i0, template: "<c-card-body>\n  @if (!!value()) {\n    <div class=\"fs-4 fw-semibold\">{{ value() }}</div>\n  }\n  @if (!!title()) {\n    <div>{{ title() }}</div>\n  }\n  <ng-content />\n  @if (text()) {\n    <small [ngClass]=\"inverse() ? 'text-white text-opacity-75' : 'text-body-secondary'\">\n      {{ text() }}\n    </small>\n  }\n</c-card-body>\n", dependencies: [{ kind: "component", type: CardBodyComponent, selector: "c-card-body, [c-card-body]" }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: WidgetStatBComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-widget-stat-b', exportAs: 'cWidgetStatB', imports: [CardBodyComponent, NgClass], host: { class: 'card', '[class]': 'hostClasses()' }, template: "<c-card-body>\n  @if (!!value()) {\n    <div class=\"fs-4 fw-semibold\">{{ value() }}</div>\n  }\n  @if (!!title()) {\n    <div>{{ title() }}</div>\n  }\n  <ng-content />\n  @if (text()) {\n    <small [ngClass]=\"inverse() ? 'text-white text-opacity-75' : 'text-body-secondary'\">\n      {{ text() }}\n    </small>\n  }\n</c-card-body>\n" }]
        }], ctorParameters: () => [] });

class WidgetStatCComponent extends CardComponent {
    constructor() {
        super();
        /**
         * Icon for your component.
         * @type string
         */
        this.icon = input();
        /**
         * Title of the widget to display
         * @type string
         */
        this.title = input();
        /**
         * Value for your widget to display
         * @type string|number
         */
        this.value = input();
        /**
         * Invert colors from their default dark shade.
         * @type boolean
         */
        this.inverse = input(false, { transform: booleanAttribute });
        this.templates = {};
        this.contentTemplates = contentChildren(TemplateIdDirective, { descendants: true });
        this.#contentTemplatesEffect = effect(() => {
            this.contentTemplates().forEach((child) => {
                this.templates[child.id] = child.templateRef;
            });
        });
        this.hostExtendedClass = computed(() => {
            return { ...this.hostClasses(), 'text-white': this.inverse() };
        });
        this.titleClasses = computed(() => {
            const inverse = this.inverse();
            return {
                'text-body-secondary': !inverse,
                'text-white': inverse,
                'text-opacity-75': inverse,
                [`text-${this.textColor()}`]: !!this.textColor()
            };
        });
        this.valueClasses = computed(() => {
            return {
                'fs-4': !this.textColor(),
                'fw-semibold': true,
                ...this.titleClasses(),
                'text-opacity-75': false
            };
        });
        this.iconClasses = computed(() => {
            return {
                'mb-4': !this.textColor(),
                'text-end': true,
                ...this.titleClasses()
            };
        });
    }
    #contentTemplatesEffect;
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: WidgetStatCComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.2", type: WidgetStatCComponent, isStandalone: true, selector: "c-widget-stat-c", inputs: { icon: { classPropertyName: "icon", publicName: "icon", isSignal: true, isRequired: false, transformFunction: null }, title: { classPropertyName: "title", publicName: "title", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "value", isSignal: true, isRequired: false, transformFunction: null }, inverse: { classPropertyName: "inverse", publicName: "inverse", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostExtendedClass()" } }, queries: [{ propertyName: "contentTemplates", predicate: TemplateIdDirective, descendants: true, isSignal: true }], exportAs: ["cWidgetStatC"], usesInheritance: true, ngImport: i0, template: "<c-card-body>\n  @if (icon() || templates?.['widgetIconTemplate']) {\n    <div [ngClass]=\"iconClasses()\">\n      <ng-container *ngTemplateOutlet=\"templates?.['widgetIconTemplate'] || defaultWidgetIconTemplate\" />\n    </div>\n  }\n  @if (!!value()) {\n    <div [ngClass]=\"valueClasses()\">\n      {{ value() }}\n    </div>\n  }\n  @if (!!title()) {\n    <div [ngClass]=\"titleClasses()\">\n      {{ title() }}\n    </div>\n  }\n  @if (templates?.['widgetProgressTemplate']) {\n    <ng-container *ngTemplateOutlet=\"templates?.['widgetProgressTemplate'] || defaultWidgetProgressTemplate\" />\n  }\n</c-card-body>\n\n<ng-template #defaultWidgetIconTemplate>\n  {{ icon() }}\n</ng-template>\n\n<ng-template #defaultWidgetProgressTemplate>\n  <ng-content />\n</ng-template>\n", dependencies: [{ kind: "component", type: CardBodyComponent, selector: "c-card-body, [c-card-body]" }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: WidgetStatCComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-widget-stat-c', exportAs: 'cWidgetStatC', imports: [CardBodyComponent, NgClass, NgTemplateOutlet], host: { '[class]': 'hostExtendedClass()' }, template: "<c-card-body>\n  @if (icon() || templates?.['widgetIconTemplate']) {\n    <div [ngClass]=\"iconClasses()\">\n      <ng-container *ngTemplateOutlet=\"templates?.['widgetIconTemplate'] || defaultWidgetIconTemplate\" />\n    </div>\n  }\n  @if (!!value()) {\n    <div [ngClass]=\"valueClasses()\">\n      {{ value() }}\n    </div>\n  }\n  @if (!!title()) {\n    <div [ngClass]=\"titleClasses()\">\n      {{ title() }}\n    </div>\n  }\n  @if (templates?.['widgetProgressTemplate']) {\n    <ng-container *ngTemplateOutlet=\"templates?.['widgetProgressTemplate'] || defaultWidgetProgressTemplate\" />\n  }\n</c-card-body>\n\n<ng-template #defaultWidgetIconTemplate>\n  {{ icon() }}\n</ng-template>\n\n<ng-template #defaultWidgetProgressTemplate>\n  <ng-content />\n</ng-template>\n" }]
        }], ctorParameters: () => [] });

class WidgetStatDComponent extends CardComponent {
    constructor() {
        super(...arguments);
        /**
         * Sets the color context of the component to one of CoreUI’s themed colors.
         * @type Colors
         */
        // override readonly color = input<Colors>();
        /**
         * Values and subtitles for your component.
         * @type WidgetStatDValue
         */
        this.values = input();
        this.headerClasses = computed(() => {
            return {
                'position-relative': true,
                'd-flex': true,
                'justify-content-center': true,
                'align-items-center': true,
                [`bg-${this.color()}`]: this.color()
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: WidgetStatDComponent, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.2", type: WidgetStatDComponent, isStandalone: true, selector: "c-widget-stat-d", inputs: { values: { classPropertyName: "values", publicName: "values", isSignal: true, isRequired: false, transformFunction: null } }, host: { classAttribute: "card" }, exportAs: ["cWidgetStatD"], usesInheritance: true, ngImport: i0, template: "<c-card-header [ngClass]=\"headerClasses()\">\n  <ng-content />\n</c-card-header>\n<c-card-body cRow class=\"text-center\">\n  @for (item of values(); track item; let i = $index) {\n    @if (i % 2 !== 0) {\n      <div class=\"vr\"></div>\n    }\n    <c-col>\n      <div class=\"fs-5 fw-semibold\">{{ item.value }}</div>\n      <div class=\"text-uppercase text-body-secondary small\">{{ item.title }}</div>\n    </c-col>\n  }\n</c-card-body>\n", dependencies: [{ kind: "component", type: CardHeaderComponent, selector: "c-card-header, [c-card-header]" }, { kind: "component", type: CardBodyComponent, selector: "c-card-body, [c-card-body]" }, { kind: "component", type: ColComponent, selector: "c-col" }, { kind: "directive", type: RowDirective, selector: "[cRow]", inputs: ["xs", "sm", "md", "lg", "xl", "xxl"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: WidgetStatDComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-widget-stat-d', exportAs: 'cWidgetStatD', imports: [CardHeaderComponent, CardBodyComponent, ColComponent, RowDirective, NgClass], host: { class: 'card' }, template: "<c-card-header [ngClass]=\"headerClasses()\">\n  <ng-content />\n</c-card-header>\n<c-card-body cRow class=\"text-center\">\n  @for (item of values(); track item; let i = $index) {\n    @if (i % 2 !== 0) {\n      <div class=\"vr\"></div>\n    }\n    <c-col>\n      <div class=\"fs-5 fw-semibold\">{{ item.value }}</div>\n      <div class=\"text-uppercase text-body-secondary small\">{{ item.title }}</div>\n    </c-col>\n  }\n</c-card-body>\n" }]
        }] });

class WidgetStatEComponent extends CardComponent {
    constructor() {
        super();
        /**
         * Title of the widget to display
         * @type string
         */
        this.title = input();
        /**
         * Value for your widget to display
         * @type string | number
         */
        this.value = input();
        this.titleClasses = computed(() => {
            const textColor = this.textColor();
            return {
                'text-body-secondary': !textColor,
                small: true,
                'text-uppercase': true,
                'fw-semibold': true,
                [`text-${textColor}`]: !!textColor
            };
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: WidgetStatEComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.2", type: WidgetStatEComponent, isStandalone: true, selector: "c-widget-stat-e", inputs: { title: { classPropertyName: "title", publicName: "title", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "value", isSignal: true, isRequired: false, transformFunction: null } }, exportAs: ["cWidgetStatE"], usesInheritance: true, ngImport: i0, template: "<c-card-body class=\"text-center\">\n  @if (!!title()) {\n    <div [ngClass]=\"titleClasses()\">{{ title() }}</div>\n  }\n  @if (!!value()) {\n    <div class=\"fs-6 fw-semibold py-3\">{{ value() }}</div>\n  }\n  <ng-content />\n</c-card-body>\n", dependencies: [{ kind: "component", type: CardBodyComponent, selector: "c-card-body, [c-card-body]" }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: WidgetStatEComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-widget-stat-e', exportAs: 'cWidgetStatE', imports: [CardBodyComponent, NgClass], template: "<c-card-body class=\"text-center\">\n  @if (!!title()) {\n    <div [ngClass]=\"titleClasses()\">{{ title() }}</div>\n  }\n  @if (!!value()) {\n    <div class=\"fs-6 fw-semibold py-3\">{{ value() }}</div>\n  }\n  <ng-content />\n</c-card-body>\n" }]
        }], ctorParameters: () => [] });

class WidgetStatFComponent extends CardComponent {
    constructor() {
        super(...arguments);
        /**
         * Sets the color context of the component to one of CoreUI’s themed colors.
         * @type Colors
         */
        // override readonly color = input<Colors>();
        /**
         * Sets the text-color context of the component to one of CoreUI’s themed colors.
         * @type Colors
         */
        // override readonly textColor = input<TextColors | 'white' | 'muted'>();
        /**
         * Footer for your widget
         * @type string
         */
        this.footer = input();
        /**
         * Icon for your widget
         * @type string
         */
        this.icon = input();
        /**
         * Set padding of your component.
         * @type boolean
         */
        this.padding = input(false, { transform: booleanAttribute });
        /**
         * Title of the widget to display
         * @type string
         */
        this.title = input();
        /**
         * Value for your widget to display
         * @type string
         */
        this.value = input();
        this.templates = {};
        this.contentTemplates = contentChildren(TemplateIdDirective, { descendants: true });
        this.#contentTemplatesEffect = effect(() => {
            this.contentTemplates().forEach((child) => {
                this.templates[child.id] = child.templateRef;
            });
        });
        this.cardBodyClasses = computed(() => {
            return {
                'd-flex': true,
                'align-items-center': true,
                'p-0': !this.padding()
            };
        });
        this.iconClasses = computed(() => {
            const color = this.color();
            const padding = this.padding();
            return {
                'me-3': !this.textColor(),
                'text-white': true,
                [`bg-${color}`]: !!color,
                'p-3': padding,
                'p-4': !padding,
                'rounded-start-1': !padding
            };
        });
        this.titleClasses = computed(() => {
            const textColor = this.textColor();
            return {
                'text-body-secondary': !textColor,
                small: true,
                'text-uppercase': true,
                'fw-semibold': true,
                [`text-${textColor}`]: !!textColor
            };
        });
        this.valueClasses = computed(() => {
            const textColor = this.textColor();
            return {
                'fs-6': !textColor,
                'fw-semibold': true,
                [`text-${textColor}`]: !!textColor
            };
        });
    }
    #contentTemplatesEffect;
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: WidgetStatFComponent, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "19.2.2", type: WidgetStatFComponent, isStandalone: true, selector: "c-widget-stat-f", inputs: { footer: { classPropertyName: "footer", publicName: "footer", isSignal: true, isRequired: false, transformFunction: null }, icon: { classPropertyName: "icon", publicName: "icon", isSignal: true, isRequired: false, transformFunction: null }, padding: { classPropertyName: "padding", publicName: "padding", isSignal: true, isRequired: false, transformFunction: null }, title: { classPropertyName: "title", publicName: "title", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "value", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "class": "hostClasses()" }, classAttribute: "card" }, queries: [{ propertyName: "contentTemplates", predicate: TemplateIdDirective, descendants: true, isSignal: true }], exportAs: ["cWidgetStatB"], usesInheritance: true, ngImport: i0, template: "<ng-container>\n  <c-card-body [ngClass]=\"cardBodyClasses()\">\n    <div [ngClass]=\"iconClasses()\">\n      <ng-container *ngTemplateOutlet=\"templates?.['widgetIconTemplate'] || defaultWidgetIconTemplate\" />\n    </div>\n    <div>\n      <div [ngClass]=\"valueClasses()\">{{ value() }}</div>\n      <div [ngClass]=\"titleClasses()\">{{ title() }}</div>\n    </div>\n  </c-card-body>\n  @if (footer() || templates?.['widgetFooterTemplate']) {\n    <c-card-footer>\n      <ng-container *ngTemplateOutlet=\"templates?.['widgetFooterTemplate'] || defaultFooterIconTemplate\" />\n    </c-card-footer>\n  }\n</ng-container>\n\n<ng-template #defaultWidgetIconTemplate>\n  <span>{{ icon() }}</span>\n</ng-template>\n\n<ng-template #defaultFooterIconTemplate>\n  <span>{{ footer() }}</span>\n</ng-template>\n", dependencies: [{ kind: "component", type: CardBodyComponent, selector: "c-card-body, [c-card-body]" }, { kind: "component", type: CardFooterComponent, selector: "c-card-footer, [c-card-footer]" }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: WidgetStatFComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c-widget-stat-f', exportAs: 'cWidgetStatB', imports: [CardBodyComponent, CardFooterComponent, NgClass, NgTemplateOutlet], host: { class: 'card', '[class]': 'hostClasses()' }, template: "<ng-container>\n  <c-card-body [ngClass]=\"cardBodyClasses()\">\n    <div [ngClass]=\"iconClasses()\">\n      <ng-container *ngTemplateOutlet=\"templates?.['widgetIconTemplate'] || defaultWidgetIconTemplate\" />\n    </div>\n    <div>\n      <div [ngClass]=\"valueClasses()\">{{ value() }}</div>\n      <div [ngClass]=\"titleClasses()\">{{ title() }}</div>\n    </div>\n  </c-card-body>\n  @if (footer() || templates?.['widgetFooterTemplate']) {\n    <c-card-footer>\n      <ng-container *ngTemplateOutlet=\"templates?.['widgetFooterTemplate'] || defaultFooterIconTemplate\" />\n    </c-card-footer>\n  }\n</ng-container>\n\n<ng-template #defaultWidgetIconTemplate>\n  <span>{{ icon() }}</span>\n</ng-template>\n\n<ng-template #defaultFooterIconTemplate>\n  <span>{{ footer() }}</span>\n</ng-template>\n" }]
        }] });

class WidgetModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: WidgetModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "19.2.2", ngImport: i0, type: WidgetModule, imports: [WidgetStatAComponent,
            WidgetStatBComponent,
            WidgetStatCComponent,
            WidgetStatDComponent,
            WidgetStatEComponent,
            WidgetStatFComponent], exports: [WidgetStatAComponent,
            WidgetStatBComponent,
            WidgetStatCComponent,
            WidgetStatDComponent,
            WidgetStatEComponent,
            WidgetStatFComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: WidgetModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.2", ngImport: i0, type: WidgetModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        WidgetStatAComponent,
                        WidgetStatBComponent,
                        WidgetStatCComponent,
                        WidgetStatDComponent,
                        WidgetStatEComponent,
                        WidgetStatFComponent
                    ],
                    exports: [
                        WidgetStatAComponent,
                        WidgetStatBComponent,
                        WidgetStatCComponent,
                        WidgetStatDComponent,
                        WidgetStatEComponent,
                        WidgetStatFComponent
                    ]
                }]
        }] });

/*
 * Public API Surface of coreui-angular
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AccordionButtonDirective, AccordionComponent, AccordionItemComponent, AccordionModule, AlertComponent, AlertHeadingDirective, AlertLinkDirective, AlertModule, AlignDirective, AvatarComponent, AvatarModule, BackdropService, BadgeComponent, BadgeModule, BgColorDirective, BorderDirective, BreadcrumbComponent, BreadcrumbItemComponent, BreadcrumbModule, BreadcrumbRouterComponent, BreadcrumbRouterService, BreakpointInfix, ButtonCloseDirective, ButtonDirective, ButtonGroupComponent, ButtonGroupModule, ButtonModule, ButtonToolbarComponent, CalloutComponent, CalloutModule, CardBodyComponent, CardComponent, CardFooterComponent, CardGroupComponent, CardHeaderActionsComponent, CardHeaderComponent, CardImgDirective, CardImgOverlayComponent, CardLinkDirective, CardModule, CardSubtitleDirective, CardTextDirective, CardTitleDirective, CarouselCaptionComponent, CarouselComponent, CarouselConfig, CarouselControlComponent, CarouselIndicatorsComponent, CarouselInnerComponent, CarouselItemComponent, CarouselModule, ClassToggleService, ColComponent, ColDirective, CollapseDirective, CollapseModule, ColorModeService, ContainerComponent, DropdownCloseDirective, DropdownComponent, DropdownDividerDirective, DropdownHeaderDirective, DropdownItemDirective, DropdownItemPlainDirective, DropdownMenuDirective, DropdownModule, DropdownService, DropdownToggleDirective, ElementRefDirective, FooterComponent, FooterModule, FormCheckComponent, FormCheckInputDirective, FormCheckLabelDirective, FormControlDirective, FormDirective, FormFeedbackComponent, FormFloatingDirective, FormLabelDirective, FormModule, FormSelectDirective, FormTextDirective, GridModule, GutterDirective, HeaderBrandComponent, HeaderComponent, HeaderDividerComponent, HeaderModule, HeaderNavComponent, HeaderTextComponent, HeaderTogglerDirective, HtmlAttributesDirective, ImgDirective, ImgModule, InMemoryStorageService, InputGroupComponent, InputGroupTextDirective, IntersectionService, ListGroupDirective, ListGroupItemDirective, ListGroupModule, ListenersService, LocalStorageService, ModalBodyComponent, ModalComponent, ModalContentComponent, ModalDialogComponent, ModalFooterComponent, ModalHeaderComponent, ModalModule, ModalService, ModalTitleDirective, ModalToggleDirective, NavComponent, NavItemComponent, NavLinkDirective, NavModule, NavbarBrandDirective, NavbarComponent, NavbarModule, NavbarNavComponent, NavbarTextComponent, NavbarTogglerDirective, OffcanvasBodyComponent, OffcanvasComponent, OffcanvasHeaderComponent, OffcanvasModule, OffcanvasService, OffcanvasTitleDirective, OffcanvasToggleDirective, PageItemComponent, PageItemDirective, PageLinkDirective, PaginationComponent, PaginationModule, PlaceholderAnimationDirective, PlaceholderDirective, PlaceholderModule, PopoverComponent, PopoverDirective, PopoverModule, ProgressBarComponent, ProgressBarDirective, ProgressComponent, ProgressModule, ProgressStackedComponent, RoundedDirective, RowComponent, RowDirective, RtlService, ShadowOnScrollDirective, SharedModule, SidebarBrandComponent, SidebarComponent, SidebarFooterComponent, SidebarHeaderComponent, SidebarModule, SidebarNavComponent, SidebarNavHelper, SidebarService, SidebarToggleDirective, SidebarTogglerDirective, SpinnerComponent, SpinnerModule, TabContentComponent, TabContentRefDirective, TabDirective, TabPaneComponent, TabPanelComponent, TabService, TableActiveDirective, TableColorDirective, TableDirective, TableModule, Tabs2Module, TabsComponent, TabsContentComponent, TabsListComponent, TabsModule, TabsService, TemplateIdDirective, TextBgColorDirective, TextColorDirective, ThemeDirective, ToastBodyComponent, ToastCloseDirective, ToastComponent, ToastHeaderComponent, ToastModule, ToasterComponent, ToasterHostDirective, ToasterPlacement, ToasterService, TooltipComponent, TooltipDirective, TooltipModule, UIDService, UtilitiesModule, WidgetModule, WidgetStatAComponent, WidgetStatBComponent, WidgetStatCComponent, WidgetStatDComponent, WidgetStatEComponent, WidgetStatFComponent };
//# sourceMappingURL=coreui-angular.mjs.map
