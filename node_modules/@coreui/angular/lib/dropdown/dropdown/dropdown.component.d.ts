import { AfterContentInit, AfterViewInit, ChangeDetectorRef, ElementRef, NgZone, OnDestroy, OnInit, Renderer2 } from '@angular/core';
import { Options, Placement } from '@popperjs/core';
import { DropdownMenuDirective } from '../dropdown-menu/dropdown-menu.directive';
import { DropdownService } from '../dropdown.service';
import * as i0 from "@angular/core";
import * as i1 from "../../shared/theme.directive";
export declare abstract class DropdownToken {
}
export declare class DropdownToggleDirective implements AfterViewInit {
    #private;
    readonly elementRef: ElementRef<any>;
    dropdown: DropdownToken | null;
    /**
     * Reference to dropdown component.
     * @return DropdownComponent | undefined
     * @default undefined
     */
    readonly dropdownComponent: import("@angular/core").InputSignal<DropdownComponent | undefined>;
    /**
     * Disables the toggler.
     * @return boolean
     * @default false
     */
    readonly disabled: import("@angular/core").InputSignalWithTransform<boolean, unknown>;
    /**
     * Enables pseudo element caret on toggler.
     * @return boolean
     */
    readonly caret: import("@angular/core").InputSignal<boolean>;
    /**
     * Create split button dropdowns with virtually the same markup as single button dropdowns,
     * but with the addition of `.dropdown-toggle-split` class for proper spacing around the dropdown caret.
     * @return boolean
     * @default false
     */
    readonly split: import("@angular/core").InputSignalWithTransform<boolean, unknown>;
    readonly hostClasses: import("@angular/core").Signal<Record<string, boolean>>;
    get ariaExpanded(): boolean;
    onClick($event: MouseEvent): void;
    ngAfterViewInit(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<DropdownToggleDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DropdownToggleDirective, "[cDropdownToggle]", ["cDropdownToggle"], { "dropdownComponent": { "alias": "dropdownComponent"; "required": false; "isSignal": true; }; "disabled": { "alias": "disabled"; "required": false; "isSignal": true; }; "caret": { "alias": "caret"; "required": false; "isSignal": true; }; "split": { "alias": "split"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}
export declare class DropdownComponent implements AfterContentInit, OnDestroy, OnInit {
    #private;
    private document;
    private elementRef;
    private renderer;
    private ngZone;
    private changeDetectorRef;
    dropdownService: DropdownService;
    constructor(document: Document, elementRef: ElementRef, renderer: Renderer2, ngZone: NgZone, changeDetectorRef: ChangeDetectorRef, dropdownService: DropdownService);
    /**
     * Set alignment of dropdown menu.
     * @return {'start' | 'end' | { xs: 'start' | 'end' } | { sm: 'start' | 'end' } | { md: 'start' | 'end' } | { lg: 'start' | 'end' } | { xl: 'start' | 'end'} | { xxl: 'start' | 'end'}}
     */
    readonly alignment: import("@angular/core").InputSignal<string | undefined>;
    /**
     * Automatically close dropdown when clicking outside the dropdown menu.
     */
    readonly autoClose: import("@angular/core").InputSignal<boolean | "inside" | "outside">;
    /**
     * Sets a specified  direction and location of the dropdown menu.
     * @return 'dropup' | 'dropend' | 'dropstart'
     */
    readonly direction: import("@angular/core").InputSignal<"center" | "dropup" | "dropup-center" | "dropend" | "dropstart" | undefined>;
    /**
     * Describes the placement of your component after Popper.js has applied all the modifiers
     * that may have flipped or altered the originally provided placement property.
     * @return Placement
     */
    readonly placement: import("@angular/core").InputSignal<Placement>;
    /**
     * If you want to disable dynamic positioning set this property to `false`.
     * @return boolean
     * @default true
     */
    readonly popper: import("@angular/core").InputSignalWithTransform<boolean, unknown>;
    /**
     * Optional popper Options object, placement prop takes precedence over
     * @return Partial<Options>
     */
    readonly popperOptionsInput: import("@angular/core").InputSignal<Partial<Options>>;
    readonly popperOptionsEffect: import("@angular/core").EffectRef;
    set popperOptions(value: Partial<Options>);
    get popperOptions(): Partial<Options>;
    /**
     * Set the dropdown variant to a btn-group, dropdown, input-group, and nav-item.
     */
    readonly variant: import("@angular/core").InputSignal<"btn-group" | "dropdown" | "input-group" | "nav-item" | undefined>;
    /**
     * Toggle the visibility of dropdown menu component.
     * @return boolean
     * @default false
     */
    readonly visibleInput: import("@angular/core").InputSignalWithTransform<boolean, unknown>;
    readonly visible: import("@angular/core").WritableSignal<boolean>;
    readonly visibleEffect: import("@angular/core").EffectRef;
    readonly visibleChange: import("@angular/core").OutputEmitterRef<boolean>;
    dropdownContext: {
        $implicit: boolean;
    };
    _toggler: DropdownToggleDirective;
    _menu: DropdownMenuDirective;
    _menuElementRef: ElementRef;
    activeTrap: boolean;
    private dropdownStateSubscription;
    private popperInstance;
    private listeners;
    readonly hostClasses: import("@angular/core").Signal<Record<string, boolean>>;
    readonly hostStyle: import("@angular/core").Signal<{
        display: string;
    } | {
        display?: undefined;
    }>;
    private clickedTarget;
    onHostClick($event: MouseEvent): void;
    dropdownStateSubscribe(subscribe?: boolean): void;
    toggleDropdown(): void;
    onClick(event: any): void;
    ngAfterContentInit(): void;
    ngOnInit(): void;
    ngOnDestroy(): void;
    setVisibleState(value: boolean): void;
    createPopperInstance(): void;
    destroyPopperInstance(): void;
    private setListeners;
    private clearListeners;
    static ɵfac: i0.ɵɵFactoryDeclaration<DropdownComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<DropdownComponent, "c-dropdown", ["cDropdown"], { "alignment": { "alias": "alignment"; "required": false; "isSignal": true; }; "autoClose": { "alias": "autoClose"; "required": false; "isSignal": true; }; "direction": { "alias": "direction"; "required": false; "isSignal": true; }; "placement": { "alias": "placement"; "required": false; "isSignal": true; }; "popper": { "alias": "popper"; "required": false; "isSignal": true; }; "popperOptionsInput": { "alias": "popperOptions"; "required": false; "isSignal": true; }; "variant": { "alias": "variant"; "required": false; "isSignal": true; }; "visibleInput": { "alias": "visible"; "required": false; "isSignal": true; }; }, { "visibleChange": "visibleChange"; }, ["_toggler", "_menu", "_menuElementRef"], ["*"], true, [{ directive: typeof i1.ThemeDirective; inputs: { "dark": "dark"; }; outputs: {}; }]>;
}
